<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/internal/pkg/auth/auth_middleware.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/internal/pkg/auth/auth_middleware.go" />
              <option name="updatedContent" value="package auth&#10;&#10;import (&#10;&#9;&quot;net/http&quot;&#10;&#9;&quot;strings&quot;&#10;&#9;&quot;time&quot;&#10;&#10;&#9;&quot;github.com/gin-gonic/gin&quot;&#10;&#9;&quot;github.com/golang-jwt/jwt/v4&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/internal/pkg/logger&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/internal/pkg/rest&quot;&#10;)&#10;&#10;type SharedAuthMiddleware struct {&#10;&#9;logger    logger.Logger&#10;&#9;jwtSecret string&#10;}&#10;&#10;type JWTClaims struct {&#10;&#9;UserID           int64     `json:&quot;user_id&quot;`&#10;&#9;Email            string    `json:&quot;email&quot;`&#10;&#9;Roles            []string  `json:&quot;roles&quot;`&#10;&#9;Permissions      []string  `json:&quot;permissions&quot;`&#10;&#9;RefreshExpiresAt time.Time `json:&quot;refresh_expires_at&quot;`&#10;&#9;jwt.RegisteredClaims&#10;}&#10;&#10;func NewSharedAuthMiddleware(logger logger.Logger, jwtSecret string) *SharedAuthMiddleware {&#10;&#9;return &amp;SharedAuthMiddleware{&#10;&#9;&#9;logger:    logger,&#10;&#9;&#9;jwtSecret: jwtSecret,&#10;&#9;}&#10;}&#10;&#10;// AuthRequired validates JWT token and sets user info in context&#10;func (m *SharedAuthMiddleware) AuthRequired() gin.HandlerFunc {&#10;&#9;return func(c *gin.Context) {&#10;&#9;&#9;authHeader := c.GetHeader(&quot;Authorization&quot;)&#10;&#9;&#9;if authHeader == &quot;&quot; {&#10;&#9;&#9;&#9;c.JSON(http.StatusUnauthorized, rest.ErrorResponse{&#10;&#9;&#9;&#9;&#9;ApiError: rest.UnauthorizedError,&#10;&#9;&#9;&#9;&#9;Message:  &quot;Authorization header required&quot;,&#10;&#9;&#9;&#9;})&#10;&#9;&#9;&#9;c.Abort()&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#10;&#9;&#9;tokenString := strings.TrimPrefix(authHeader, &quot;Bearer &quot;)&#10;&#9;&#9;if tokenString == authHeader {&#10;&#9;&#9;&#9;c.JSON(http.StatusUnauthorized, rest.ErrorResponse{&#10;&#9;&#9;&#9;&#9;ApiError: rest.UnauthorizedError,&#10;&#9;&#9;&#9;&#9;Message:  &quot;Bearer token required&quot;,&#10;&#9;&#9;&#9;})&#10;&#9;&#9;&#9;c.Abort()&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#10;&#9;&#9;claims, err := m.validateToken(tokenString)&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;m.logger.Error(&quot;Failed to validate JWT token&quot;, &quot;error&quot;, err)&#10;&#9;&#9;&#9;c.JSON(http.StatusUnauthorized, rest.ErrorResponse{&#10;&#9;&#9;&#9;&#9;ApiError: rest.UnauthorizedError,&#10;&#9;&#9;&#9;&#9;Message:  &quot;Invalid token&quot;,&#10;&#9;&#9;&#9;})&#10;&#9;&#9;&#9;c.Abort()&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// Set user info in context for all services to use&#10;&#9;&#9;c.Set(&quot;user_id&quot;, claims.UserID)&#10;&#9;&#9;c.Set(&quot;email&quot;, claims.Email)&#10;&#9;&#9;c.Set(&quot;roles&quot;, claims.Roles)&#10;&#9;&#9;c.Set(&quot;permissions&quot;, claims.Permissions)&#10;&#10;&#9;&#9;c.Next()&#10;&#9;}&#10;}&#10;&#10;// RequirePermissions checks if user has ALL specified permissions&#10;func (m *SharedAuthMiddleware) RequirePermissions(requiredPermissions ...string) gin.HandlerFunc {&#10;&#9;return func(c *gin.Context) {&#10;&#9;&#9;permissions, exists := c.Get(&quot;permissions&quot;)&#10;&#9;&#9;if !exists {&#10;&#9;&#9;&#9;c.JSON(http.StatusUnauthorized, rest.ErrorResponse{&#10;&#9;&#9;&#9;&#9;ApiError: rest.UnauthorizedError,&#10;&#9;&#9;&#9;&#9;Message:  &quot;User not authenticated&quot;,&#10;&#9;&#9;&#9;})&#10;&#9;&#9;&#9;c.Abort()&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#10;&#9;&#9;userPermissions := permissions.([]string)&#10;&#9;&#9;userPermMap := make(map[string]bool)&#10;&#9;&#9;for _, perm := range userPermissions {&#10;&#9;&#9;&#9;userPermMap[perm] = true&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// Check if user has all required permissions&#10;&#9;&#9;for _, requiredPerm := range requiredPermissions {&#10;&#9;&#9;&#9;if !userPermMap[requiredPerm] {&#10;&#9;&#9;&#9;&#9;m.logger.Warn(&quot;Access denied - missing permission&quot;, &#10;&#9;&#9;&#9;&#9;&#9;&quot;user_id&quot;, c.Get(&quot;user_id&quot;), &#10;&#9;&#9;&#9;&#9;&#9;&quot;required_permission&quot;, requiredPerm)&#10;&#9;&#9;&#9;&#9;c.JSON(http.StatusForbidden, rest.ErrorResponse{&#10;&#9;&#9;&#9;&#9;&#9;ApiError: rest.ForbiddenError,&#10;&#9;&#9;&#9;&#9;&#9;Message:  &quot;Insufficient permissions&quot;,&#10;&#9;&#9;&#9;&#9;})&#10;&#9;&#9;&#9;&#9;c.Abort()&#10;&#9;&#9;&#9;&#9;return&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#10;&#9;&#9;c.Next()&#10;&#9;}&#10;}&#10;&#10;// RequireAnyPermission checks if user has ANY of the specified permissions&#10;func (m *SharedAuthMiddleware) RequireAnyPermission(permissions ...string) gin.HandlerFunc {&#10;&#9;return func(c *gin.Context) {&#10;&#9;&#9;userPermissions, exists := c.Get(&quot;permissions&quot;)&#10;&#9;&#9;if !exists {&#10;&#9;&#9;&#9;c.JSON(http.StatusUnauthorized, rest.ErrorResponse{&#10;&#9;&#9;&#9;&#9;ApiError: rest.UnauthorizedError,&#10;&#9;&#9;&#9;&#9;Message:  &quot;User not authenticated&quot;,&#10;&#9;&#9;&#9;})&#10;&#9;&#9;&#9;c.Abort()&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#10;&#9;&#9;userPerms := userPermissions.([]string)&#10;&#9;&#9;for _, userPerm := range userPerms {&#10;&#9;&#9;&#9;for _, requiredPerm := range permissions {&#10;&#9;&#9;&#9;&#9;if userPerm == requiredPerm {&#10;&#9;&#9;&#9;&#9;&#9;c.Next()&#10;&#9;&#9;&#9;&#9;&#9;return&#10;&#9;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#10;&#9;&#9;c.JSON(http.StatusForbidden, rest.ErrorResponse{&#10;&#9;&#9;&#9;ApiError: rest.ForbiddenError,&#10;&#9;&#9;&#9;Message:  &quot;Insufficient permissions&quot;,&#10;&#9;&#9;})&#10;&#9;&#9;c.Abort()&#10;&#9;}&#10;}&#10;&#10;// RequireRole checks if user has specific role&#10;func (m *SharedAuthMiddleware) RequireRole(role string) gin.HandlerFunc {&#10;&#9;return func(c *gin.Context) {&#10;&#9;&#9;roles, exists := c.Get(&quot;roles&quot;)&#10;&#9;&#9;if !exists {&#10;&#9;&#9;&#9;c.JSON(http.StatusUnauthorized, rest.ErrorResponse{&#10;&#9;&#9;&#9;&#9;ApiError: rest.UnauthorizedError,&#10;&#9;&#9;&#9;&#9;Message:  &quot;User not authenticated&quot;,&#10;&#9;&#9;&#9;})&#10;&#9;&#9;&#9;c.Abort()&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#10;&#9;&#9;userRoles := roles.([]string)&#10;&#9;&#9;for _, userRole := range userRoles {&#10;&#9;&#9;&#9;if userRole == role {&#10;&#9;&#9;&#9;&#9;c.Next()&#10;&#9;&#9;&#9;&#9;return&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#10;&#9;&#9;c.JSON(http.StatusForbidden, rest.ErrorResponse{&#10;&#9;&#9;&#9;ApiError: rest.ForbiddenError,&#10;&#9;&#9;&#9;Message:  &quot;Insufficient role permissions&quot;,&#10;&#9;&#9;})&#10;&#9;&#9;c.Abort()&#10;&#9;}&#10;}&#10;&#10;func (m *SharedAuthMiddleware) validateToken(tokenString string) (*JWTClaims, error) {&#10;&#9;token, err := jwt.ParseWithClaims(tokenString, &amp;JWTClaims{}, func(token *jwt.Token) (interface{}, error) {&#10;&#9;&#9;return []byte(m.jwtSecret), nil&#10;&#9;})&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;claims, ok := token.Claims.(*JWTClaims)&#10;&#9;if !ok {&#10;&#9;&#9;return nil, jwt.ErrTokenMalformed&#10;&#9;}&#10;&#10;&#9;now := time.Now()&#10;&#10;&#9;// Check if refresh token is expired (hard expiration)&#10;&#9;if !claims.RefreshExpiresAt.IsZero() &amp;&amp; now.After(claims.RefreshExpiresAt) {&#10;&#9;&#9;m.logger.Warn(&quot;Refresh token has expired&quot;, &quot;user_id&quot;, claims.UserID)&#10;&#9;&#9;return nil, jwt.NewValidationError(&quot;refresh token expired&quot;, jwt.ValidationErrorExpired)&#10;&#9;}&#10;&#10;&#9;// Check if access token is expired&#10;&#9;if claims.ExpiresAt != nil &amp;&amp; now.After(claims.ExpiresAt.Time) {&#10;&#9;&#9;m.logger.Info(&quot;Access token expired&quot;, &quot;user_id&quot;, claims.UserID)&#10;&#9;&#9;return nil, jwt.NewValidationError(&quot;access token expired&quot;, jwt.ValidationErrorExpired)&#10;&#9;}&#10;&#10;&#9;// Check not before&#10;&#9;if claims.NotBefore != nil &amp;&amp; now.Before(claims.NotBefore.Time) {&#10;&#9;&#9;return nil, jwt.NewValidationError(&quot;token used before valid&quot;, jwt.ValidationErrorNotValidYet)&#10;&#9;}&#10;&#10;&#9;// Check issued at&#10;&#9;if claims.IssuedAt != nil &amp;&amp; now.Before(claims.IssuedAt.Time) {&#10;&#9;&#9;return nil, jwt.NewValidationError(&quot;token issued in the future&quot;, jwt.ValidationErrorIssuedAt)&#10;&#9;}&#10;&#10;&#9;return claims, nil&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/internal/pkg/gateway/api_gateway.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/internal/pkg/gateway/api_gateway.go" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/internal/services/gateway/internal/router/router.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/internal/services/gateway/internal/router/router.go" />
              <option name="originalContent" value="package router&#10;&#10;import (&#10;&#9;&quot;encoding/json&quot;&#10;&#9;&quot;fmt&quot;&#10;&#9;&quot;io&quot;&#10;&#9;&quot;net/http&quot;&#10;&#9;&quot;strings&quot;&#10;&#10;&#9;&quot;github.com/gin-gonic/gin&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/internal/pkg/logger&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/internal/pkg/rest&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/services/gateway/internal/config&quot;&#10;)&#10;&#10;type Gateway struct {&#10;&#9;config *config.GatewayConfig&#10;&#9;logger logger.Logger&#10;&#9;client *http.Client&#10;}&#10;&#10;type VerifyResponse struct {&#10;&#9;UserID      string   `json:&quot;user_id&quot;`&#10;&#9;Roles       []string `json:&quot;roles&quot;`&#10;&#9;Permissions []string `json:&quot;permissions&quot;`&#10;}&#10;&#10;func NewGateway(cfg *config.GatewayConfig, logger logger.Logger) *Gateway {&#10;&#9;return &amp;Gateway{&#10;&#9;&#9;config: cfg,&#10;&#9;&#9;logger: logger,&#10;&#9;&#9;client: &amp;http.Client{},&#10;&#9;}&#10;}&#10;&#10;func (g *Gateway) SetupRoutes(r *gin.Engine) {&#10;&#9;r.Any(&quot;/*path&quot;, g.handleRequest)&#10;}&#10;&#10;// Public endpoints that don't require authentication&#10;var publicEndpoints = map[string][]string{&#10;&#9;&quot;/api/v1/auth/login&quot;:    {&quot;POST&quot;},&#10;&#9;&quot;/api/v1/auth/register&quot;: {&quot;POST&quot;},&#10;&#9;&quot;/api/v1/auth/refresh&quot;:  {&quot;POST&quot;},&#10;&#9;&quot;/api/v1/products/:id&quot;:  {&quot;GET&quot;}, // Public product details&#10;&#9;&quot;/api/v1/products&quot;:      {&quot;GET&quot;},&#10;}&#10;&#10;func (g *Gateway) handleRequest(c *gin.Context) {&#10;&#9;path := c.Request.URL.Path&#10;&#9;method := c.Request.Method&#10;&#10;&#9;g.logger.Info(&quot;Received request, &quot;, &quot;path: &quot;, path, &quot; | &quot;, &quot;method: &quot;, method)&#10;&#10;&#9;// Check if endpoint is public&#10;&#9;if g.isPublicEndpoint(path, method) {&#10;&#9;&#9;g.forwardToService(c, path)&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;// For non-public endpoints, verify auth with identity service&#10;&#9;authToken := c.GetHeader(&quot;Authorization&quot;)&#10;&#9;if authToken == &quot;&quot; {&#10;&#9;&#9;c.JSON(http.StatusUnauthorized, gin.H{&quot;error&quot;: &quot;Authorization header required&quot;})&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;// Verify token with identity service&#10;&#9;authResp, err := g.verifyWithIdentityService(authToken)&#10;&#9;if err != nil {&#10;&#9;&#9;g.logger.Error(&quot;Auth verification failed, error: &quot;, err)&#10;&#9;&#9;c.JSON(http.StatusUnauthorized, gin.H{&quot;error&quot;: &quot;Invalid token&quot;})&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;// Add user info to headers&#10;&#9;c.Request.Header.Set(&quot;X-User-ID&quot;, authResp.UserID)&#10;&#9;c.Request.Header.Set(&quot;X-User-Roles&quot;, strings.Join(authResp.Roles, &quot;,&quot;))&#10;&#9;c.Request.Header.Set(&quot;X-User-Permissions&quot;, strings.Join(authResp.Permissions, &quot;,&quot;))&#10;&#10;&#9;// Forward to appropriate service&#10;&#9;g.forwardToService(c, path)&#10;}&#10;&#10;func (g *Gateway) isPublicEndpoint(path, method string) bool {&#10;&#9;for publicPath, methods := range publicEndpoints {&#10;&#9;&#9;if strings.HasPrefix(path, publicPath) {&#10;&#9;&#9;&#9;for _, acceptMethod := range methods {&#10;&#9;&#9;&#9;&#9;if acceptMethod == method {&#10;&#9;&#9;&#9;&#9;&#9;return true&#10;&#9;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;return false&#10;}&#10;&#10;func (g *Gateway) verifyWithIdentityService(authToken string) (*VerifyResponse, error) {&#10;&#9;req, err := http.NewRequest(&quot;GET&quot;,&#10;&#9;&#9;g.config.IdentityServiceURL+&quot;/&quot;+config.ApiVersionV1+&quot;/auth/verify&quot;, nil)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;req.Header.Set(&quot;Authorization&quot;, authToken)&#10;&#10;&#9;resp, err := g.client.Do(req)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#9;defer resp.Body.Close()&#10;&#10;&#9;if resp.StatusCode != http.StatusOK {&#10;&#9;&#9;return nil, fmt.Errorf(&quot;auth verification failed with status: %d&quot;, resp.StatusCode)&#10;&#9;}&#10;&#10;&#9;var apiResponse rest.APIResponse&#10;&#9;if err := json.NewDecoder(resp.Body).Decode(&amp;apiResponse); err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#9;if apiResponse.Data == nil {&#10;&#9;&#9;return nil, fmt.Errorf(&quot;invalid response from identity service&quot;)&#10;&#9;}&#10;&#10;&#9;authResp, ok := apiResponse.Data.(*VerifyResponse)&#10;&#9;if !ok {&#10;&#9;&#9;return nil, fmt.Errorf(&quot;unexpected data type from identity service: %T, data: %s&quot;, apiResponse.Data, apiResponse.Data)&#10;&#9;}&#10;&#10;&#9;return authResp, nil&#10;}&#10;&#10;func (g *Gateway) forwardToService(c *gin.Context, path string) {&#10;&#9;var targetURL string&#10;&#10;&#9;// Route to appropriate service based on path&#10;&#9;if strings.HasPrefix(path, &quot;/&quot;+config.ApiVersionV1+&quot;/auth&quot;) ||&#10;&#9;&#9;strings.HasPrefix(path, &quot;/&quot;+config.ApiVersionV1+&quot;/users&quot;) {&#10;&#9;&#9;targetURL = g.config.IdentityServiceURL + path&#10;&#9;} else if strings.HasPrefix(path, &quot;/&quot;+config.ApiVersionV1+&quot;/products&quot;) {&#10;&#9;&#9;targetURL = g.config.ProductServiceURL + path&#10;&#9;} else {&#10;&#9;&#9;g.logger.Warn(&quot;No service found for path&quot;, &quot; path: &quot;, path)&#10;&#9;&#9;c.JSON(http.StatusNotFound, gin.H{&quot;error&quot;: &quot;page not found&quot;})&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;// Create new request&#10;&#9;req, err := http.NewRequest(c.Request.Method, targetURL, c.Request.Body)&#10;&#9;if err != nil {&#10;&#9;&#9;g.logger.Error(&quot;Failed to create request&quot;, err)&#10;&#9;&#9;c.JSON(http.StatusInternalServerError, gin.H{&quot;error&quot;: &quot;Internal server error&quot;})&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;// Copy headers&#10;&#9;for key, values := range c.Request.Header {&#10;&#9;&#9;for _, value := range values {&#10;&#9;&#9;&#9;req.Header.Add(key, value)&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;// Forward request&#10;&#9;resp, err := g.client.Do(req)&#10;&#9;if err != nil {&#10;&#9;&#9;g.logger.Error(&quot;Failed to forward request&quot;, err)&#10;&#9;&#9;c.JSON(http.StatusInternalServerError, gin.H{&quot;error&quot;: &quot;Service unavailable&quot;})&#10;&#9;&#9;return&#10;&#9;}&#10;&#9;defer resp.Body.Close()&#10;&#10;&#9;// Copy response headers&#10;&#9;for key, values := range resp.Header {&#10;&#9;&#9;for _, value := range values {&#10;&#9;&#9;&#9;c.Header(key, value)&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;// Copy response&#10;&#9;c.Status(resp.StatusCode)&#10;&#9;io.Copy(c.Writer, resp.Body)&#10;}&#10;" />
              <option name="updatedContent" value="package router&#10;&#10;import (&#10;&#9;&quot;encoding/json&quot;&#10;&#9;&quot;fmt&quot;&#10;&#9;&quot;io&quot;&#10;&#9;&quot;net/http&quot;&#10;&#9;&quot;strings&quot;&#10;&#10;&#9;&quot;github.com/gin-gonic/gin&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/internal/pkg/logger&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/internal/pkg/rest&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/services/gateway/internal/config&quot;&#10;)&#10;&#10;type Gateway struct {&#10;&#9;config *config.GatewayConfig&#10;&#9;logger logger.Logger&#10;&#9;client *http.Client&#10;}&#10;&#10;type VerifyResponse struct {&#10;&#9;UserID      string   `json:&quot;user_id&quot;`&#10;&#9;Roles       []string `json:&quot;roles&quot;`&#10;&#9;Permissions []string `json:&quot;permissions&quot;`&#10;}&#10;&#10;func NewGateway(cfg *config.GatewayConfig, logger logger.Logger) *Gateway {&#10;&#9;return &amp;Gateway{&#10;&#9;&#9;config: cfg,&#10;&#9;&#9;logger: logger,&#10;&#9;&#9;client: &amp;http.Client{},&#10;&#9;}&#10;}&#10;&#10;func (g *Gateway) SetupRoutes(r *gin.Engine) {&#10;&#9;r.Any(&quot;/*path&quot;, g.handleRequest)&#10;}&#10;&#10;// Public endpoints that don't require authentication&#10;var publicEndpoints = map[string][]string{&#10;&#9;&quot;/api/v1/auth/login&quot;:    {&quot;POST&quot;},&#10;&#9;&quot;/api/v1/auth/register&quot;: {&quot;POST&quot;},&#10;&#9;&quot;/api/v1/auth/refresh&quot;:  {&quot;POST&quot;},&#10;&#9;&quot;/api/v1/products/:id&quot;:  {&quot;GET&quot;}, // Public product details&#10;&#9;&quot;/api/v1/products&quot;:      {&quot;GET&quot;},&#10;}&#10;&#10;func (g *Gateway) handleRequest(c *gin.Context) {&#10;&#9;path := c.Request.URL.Path&#10;&#9;method := c.Request.Method&#10;&#10;&#9;g.logger.Info(&quot;Received request, &quot;, &quot;path: &quot;, path, &quot; | &quot;, &quot;method: &quot;, method)&#10;&#10;&#9;// Check if endpoint is public&#10;&#9;if g.isPublicEndpoint(path, method) {&#10;&#9;&#9;g.forwardToService(c, path)&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;// For non-public endpoints, verify auth with identity service&#10;&#9;authToken := c.GetHeader(&quot;Authorization&quot;)&#10;&#9;if authToken == &quot;&quot; {&#10;&#9;&#9;c.JSON(http.StatusUnauthorized, gin.H{&quot;error&quot;: &quot;Authorization header required&quot;})&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;// Verify token with identity service&#10;&#9;authResp, err := g.verifyWithIdentityService(authToken)&#10;&#9;if err != nil {&#10;&#9;&#9;g.logger.Error(&quot;Auth verification failed, error: &quot;, err)&#10;&#9;&#9;c.JSON(http.StatusUnauthorized, gin.H{&quot;error&quot;: &quot;Invalid token&quot;})&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;// Add user info to headers&#10;&#9;c.Request.Header.Set(&quot;X-User-ID&quot;, authResp.UserID)&#10;&#9;c.Request.Header.Set(&quot;X-User-Roles&quot;, strings.Join(authResp.Roles, &quot;,&quot;))&#10;&#9;c.Request.Header.Set(&quot;X-User-Permissions&quot;, strings.Join(authResp.Permissions, &quot;,&quot;))&#10;&#10;&#9;// Forward to appropriate service&#10;&#9;g.forwardToService(c, path)&#10;}&#10;&#10;func (g *Gateway) isPublicEndpoint(path, method string) bool {&#10;&#9;for publicPath, methods := range publicEndpoints {&#10;&#9;&#9;if strings.HasPrefix(path, publicPath) {&#10;&#9;&#9;&#9;for _, acceptMethod := range methods {&#10;&#9;&#9;&#9;&#9;if acceptMethod == method {&#10;&#9;&#9;&#9;&#9;&#9;return true&#10;&#9;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;return false&#10;}&#10;&#10;func (g *Gateway) verifyWithIdentityService(authToken string) (*VerifyResponse, error) {&#10;&#9;req, err := http.NewRequest(&quot;GET&quot;,&#10;&#9;&#9;g.config.IdentityServiceURL+&quot;/&quot;+config.ApiVersionV1+&quot;/auth/verify&quot;, nil)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;req.Header.Set(&quot;Authorization&quot;, authToken)&#10;&#10;&#9;resp, err := g.client.Do(req)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#9;defer resp.Body.Close()&#10;&#10;&#9;if resp.StatusCode != http.StatusOK {&#10;&#9;&#9;return nil, fmt.Errorf(&quot;auth verification failed with status: %d&quot;, resp.StatusCode)&#10;&#9;}&#10;&#10;&#9;var apiResponse rest.APIResponse&#10;&#9;if err := json.NewDecoder(resp.Body).Decode(&amp;apiResponse); err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#9;if apiResponse.Data == nil {&#10;&#9;&#9;return nil, fmt.Errorf(&quot;invalid response from identity service&quot;)&#10;&#9;}&#10;&#10;&#9;authResp, ok := apiResponse.Data.(*VerifyResponse)&#10;&#9;if !ok {&#10;&#9;&#9;return nil, fmt.Errorf(&quot;unexpected data type from identity service: %T, data: %s&quot;, apiResponse.Data, apiResponse.Data)&#10;&#9;}&#10;&#10;&#9;return authResp, nil&#10;}&#10;&#10;func (g *Gateway) forwardToService(c *gin.Context, path string) {&#10;&#9;var targetURL string&#10;&#10;&#9;// Route to appropriate service based on path&#10;&#9;if strings.HasPrefix(path, &quot;/&quot;+config.ApiVersionV1+&quot;/auth&quot;) ||&#10;&#9;&#9;strings.HasPrefix(path, &quot;/&quot;+config.ApiVersionV1+&quot;/users&quot;) {&#10;&#9;&#9;targetURL = g.config.IdentityServiceURL + path&#10;&#9;} else if strings.HasPrefix(path, &quot;/&quot;+config.ApiVersionV1+&quot;/products&quot;) {&#10;&#9;&#9;targetURL = g.config.ProductServiceURL + path&#10;&#9;} else {&#10;&#9;&#9;g.logger.Warn(&quot;No service found for path&quot;, &quot; path: &quot;, path)&#10;&#9;&#9;c.JSON(http.StatusNotFound, gin.H{&quot;error&quot;: &quot;page not found&quot;})&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;// Create new request&#10;&#9;req, err := http.NewRequest(c.Request.Method, targetURL, c.Request.Body)&#10;&#9;if err != nil {&#10;&#9;&#9;g.logger.Error(&quot;Failed to create request&quot;, err)&#10;&#9;&#9;c.JSON(http.StatusInternalServerError, gin.H{&quot;error&quot;: &quot;Internal server error&quot;})&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;// Copy headers&#10;&#9;for key, values := range c.Request.Header {&#10;&#9;&#9;for _, value := range values {&#10;&#9;&#9;&#9;req.Header.Add(key, value)&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;// Forward request&#10;&#9;resp, err := g.client.Do(req)&#10;&#9;if err != nil {&#10;&#9;&#9;g.logger.Error(&quot;Failed to forward request&quot;, err)&#10;&#9;&#9;c.JSON(http.StatusInternalServerError, gin.H{&quot;error&quot;: &quot;Service unavailable&quot;})&#10;&#9;&#9;return&#10;&#9;}&#10;&#9;defer resp.Body.Close()&#10;&#10;&#9;// Copy response headers&#10;&#9;for key, values := range resp.Header {&#10;&#9;&#9;for _, value := range values {&#10;&#9;&#9;&#9;c.Header(key, value)&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;// Copy response&#10;&#9;c.Status(resp.StatusCode)&#10;&#9;io.Copy(c.Writer, resp.Body)&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/internal/services/identity/internal/dto/request/refresh_token_request.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/internal/services/identity/internal/dto/request/refresh_token_request.go" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>