<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/benchmarks/README.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/benchmarks/README.md" />
              <option name="updatedContent" value="# Benchmarking Suite for GoStore Platform&#10;&#10;This directory contains comprehensive benchmarking tools to measure the performance of your microservices ecosystem.&#10;&#10;## Benchmark Types&#10;&#10;### 1. Load Testing (`load/`)&#10;- HTTP endpoint load testing&#10;- Concurrent user simulation&#10;- Response time analysis&#10;&#10;### 2. Database Benchmarks (`database/`)&#10;- Query performance testing&#10;- Connection pool efficiency&#10;- Transaction throughput&#10;&#10;### 3. API Benchmarks (`api/`)&#10;- Individual endpoint performance&#10;- Service-to-service communication&#10;- Authentication overhead&#10;&#10;### 4. System Benchmarks (`system/`)&#10;- Memory usage analysis&#10;- CPU utilization&#10;- Goroutine profiling&#10;&#10;## Running Benchmarks&#10;&#10;```bash&#10;# Run all benchmarks&#10;make benchmark-all&#10;&#10;# Run specific benchmark categories&#10;make benchmark-load&#10;make benchmark-db&#10;make benchmark-api&#10;&#10;# Generate performance reports&#10;make benchmark-report&#10;```&#10;&#10;## Benchmark Results&#10;&#10;Results are stored in `results/` directory with timestamps for comparison." />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/benchmarks/cmd/load_tester/main.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/benchmarks/cmd/load_tester/main.go" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/benchmarks/go.mod">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/benchmarks/go.mod" />
              <option name="updatedContent" value="module github.com/hthinh24/go-store/benchmarks&#10;&#10;go 1.21&#10;&#10;require (&#10;&#9;github.com/gin-gonic/gin v1.10.0&#10;&#9;github.com/go-resty/resty/v2 v2.7.0&#10;&#9;github.com/montanaflynn/stats v0.7.1&#10;&#9;github.com/stretchr/testify v1.8.4&#10;&#9;golang.org/x/time v0.3.0&#10;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/benchmarks/pkg/api/api_benchmarks.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/benchmarks/pkg/api/api_benchmarks.go" />
              <option name="updatedContent" value="package api&#10;&#10;import (&#10;&#9;&quot;context&quot;&#10;&#9;&quot;encoding/json&quot;&#10;&#9;&quot;fmt&quot;&#10;&#9;&quot;math/rand&quot;&#10;&#9;&quot;time&quot;&#10;&#10;&#9;&quot;github.com/hthinh24/go-store/benchmarks/pkg/benchmark&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/benchmarks/pkg/load&quot;&#10;)&#10;&#10;// APIBenchmarkSuite contains benchmarks for your GoStore APIs&#10;type APIBenchmarkSuite struct {&#10;&#9;httpTester *load.HTTPLoadTester&#10;&#9;baseURL    string&#10;&#9;authToken  string&#10;}&#10;&#10;// NewAPIBenchmarkSuite creates a new API benchmark suite&#10;func NewAPIBenchmarkSuite(baseURL string, config benchmark.BenchmarkConfig) *APIBenchmarkSuite {&#10;&#9;return &amp;APIBenchmarkSuite{&#10;&#9;&#9;httpTester: load.NewHTTPLoadTester(config),&#10;&#9;&#9;baseURL:    baseURL,&#10;&#9;}&#10;}&#10;&#10;// SetAuthToken sets the authentication token for protected endpoints&#10;func (abs *APIBenchmarkSuite) SetAuthToken(token string) {&#10;&#9;abs.authToken = token&#10;}&#10;&#10;// BenchmarkProductService tests product service endpoints&#10;func (abs *APIBenchmarkSuite) BenchmarkProductService() []*benchmark.BenchmarkResult {&#10;&#9;testConfig := load.HTTPTestConfig{&#10;&#9;&#9;BaseURL:   abs.baseURL,&#10;&#9;&#9;AuthToken: abs.authToken,&#10;&#9;&#9;Headers: map[string]string{&#10;&#9;&#9;&#9;&quot;Content-Type&quot;: &quot;application/json&quot;,&#10;&#9;&#9;},&#10;&#9;&#9;Timeout: 30 * time.Second,&#10;&#9;}&#10;&#10;&#9;endpoints := []load.EndpointTest{&#10;&#9;&#9;{&#10;&#9;&#9;&#9;Name:     &quot;Get Product Health&quot;,&#10;&#9;&#9;&#9;Method:   &quot;GET&quot;,&#10;&#9;&#9;&#9;Path:     &quot;/health&quot;,&#10;&#9;&#9;&#9;Expected: 200,&#10;&#9;&#9;},&#10;&#9;&#9;{&#10;&#9;&#9;&#9;Name:     &quot;Get Product by ID&quot;,&#10;&#9;&#9;&#9;Method:   &quot;GET&quot;,&#10;&#9;&#9;&#9;Path:     &quot;/api/v1/products/1&quot;,&#10;&#9;&#9;&#9;Expected: 200,&#10;&#9;&#9;},&#10;&#9;&#9;{&#10;&#9;&#9;&#9;Name:     &quot;Get Product Detail&quot;,&#10;&#9;&#9;&#9;Method:   &quot;GET&quot;,&#10;&#9;&#9;&#9;Path:     &quot;/api/v1/products/1/detail&quot;,&#10;&#9;&#9;&#9;Expected: 200,&#10;&#9;&#9;},&#10;&#9;&#9;{&#10;&#9;&#9;&#9;Name:     &quot;Get Product SKU&quot;,&#10;&#9;&#9;&#9;Method:   &quot;GET&quot;,&#10;&#9;&#9;&#9;Path:     &quot;/api/v1/products/skus/1&quot;,&#10;&#9;&#9;&#9;Expected: 200,&#10;&#9;&#9;},&#10;&#9;}&#10;&#10;&#9;testConfig.Endpoints = endpoints&#10;&#9;return abs.httpTester.TestAllEndpoints(testConfig)&#10;}&#10;&#10;// BenchmarkIdentityService tests identity service endpoints&#10;func (abs *APIBenchmarkSuite) BenchmarkIdentityService() []*benchmark.BenchmarkResult {&#10;&#9;testConfig := load.HTTPTestConfig{&#10;&#9;&#9;BaseURL: abs.baseURL,&#10;&#9;&#9;Headers: map[string]string{&#10;&#9;&#9;&#9;&quot;Content-Type&quot;: &quot;application/json&quot;,&#10;&#9;&#9;},&#10;&#9;&#9;Timeout: 30 * time.Second,&#10;&#9;}&#10;&#10;&#9;// Sample user data for testing&#10;&#9;userData := map[string]interface{}{&#10;&#9;&#9;&quot;email&quot;:      fmt.Sprintf(&quot;test%d@example.com&quot;, rand.Intn(10000)),&#10;&#9;&#9;&quot;password&quot;:   &quot;TestPassword123!&quot;,&#10;&#9;&#9;&quot;first_name&quot;: &quot;Test&quot;,&#10;&#9;&#9;&quot;last_name&quot;:  &quot;User&quot;,&#10;&#9;}&#10;&#10;&#9;endpoints := []load.EndpointTest{&#10;&#9;&#9;{&#10;&#9;&#9;&#9;Name:     &quot;Identity Health&quot;,&#10;&#9;&#9;&#9;Method:   &quot;GET&quot;,&#10;&#9;&#9;&#9;Path:     &quot;/health&quot;,&#10;&#9;&#9;&#9;Expected: 200,&#10;&#9;&#9;},&#10;&#9;&#9;{&#10;&#9;&#9;&#9;Name:     &quot;Create User&quot;,&#10;&#9;&#9;&#9;Method:   &quot;POST&quot;,&#10;&#9;&#9;&#9;Path:     &quot;/api/v1/users&quot;,&#10;&#9;&#9;&#9;Body:     userData,&#10;&#9;&#9;&#9;Expected: 201,&#10;&#9;&#9;},&#10;&#9;}&#10;&#10;&#9;testConfig.Endpoints = endpoints&#10;&#9;return abs.httpTester.TestAllEndpoints(testConfig)&#10;}&#10;&#10;// BenchmarkCartService tests cart service endpoints&#10;func (abs *APIBenchmarkSuite) BenchmarkCartService() []*benchmark.BenchmarkResult {&#10;&#9;testConfig := load.HTTPTestConfig{&#10;&#9;&#9;BaseURL:   abs.baseURL,&#10;&#9;&#9;AuthToken: abs.authToken,&#10;&#9;&#9;Headers: map[string]string{&#10;&#9;&#9;&#9;&quot;Content-Type&quot;: &quot;application/json&quot;,&#10;&#9;&#9;},&#10;&#9;&#9;Timeout: 30 * time.Second,&#10;&#9;}&#10;&#10;&#9;endpoints := []load.EndpointTest{&#10;&#9;&#9;{&#10;&#9;&#9;&#9;Name:     &quot;Cart Health&quot;,&#10;&#9;&#9;&#9;Method:   &quot;GET&quot;,&#10;&#9;&#9;&#9;Path:     &quot;/health&quot;,&#10;&#9;&#9;&#9;Expected: 200,&#10;&#9;&#9;},&#10;&#9;&#9;{&#10;&#9;&#9;&#9;Name:     &quot;Create Cart&quot;,&#10;&#9;&#9;&#9;Method:   &quot;POST&quot;,&#10;&#9;&#9;&#9;Path:     &quot;/api/v1/cart&quot;,&#10;&#9;&#9;&#9;Body: map[string]interface{}{&#10;&#9;&#9;&#9;&#9;&quot;user_id&quot;: 1,&#10;&#9;&#9;&#9;},&#10;&#9;&#9;&#9;Expected: 201,&#10;&#9;&#9;},&#10;&#9;}&#10;&#10;&#9;testConfig.Endpoints = endpoints&#10;&#9;return abs.httpTester.TestAllEndpoints(testConfig)&#10;}&#10;&#10;// BenchmarkECommerceUserJourney simulates a complete user shopping journey&#10;func (abs *APIBenchmarkSuite) BenchmarkECommerceUserJourney() *benchmark.BenchmarkResult {&#10;&#9;testConfig := load.HTTPTestConfig{&#10;&#9;&#9;BaseURL:   abs.baseURL,&#10;&#9;&#9;AuthToken: abs.authToken,&#10;&#9;&#9;Headers: map[string]string{&#10;&#9;&#9;&#9;&quot;Content-Type&quot;: &quot;application/json&quot;,&#10;&#9;&#9;},&#10;&#9;&#9;Timeout: 30 * time.Second,&#10;&#9;}&#10;&#10;&#9;// Define a typical e-commerce user journey&#10;&#9;journey := []load.EndpointTest{&#10;&#9;&#9;{&#10;&#9;&#9;&#9;Name:     &quot;Browse Products&quot;,&#10;&#9;&#9;&#9;Method:   &quot;GET&quot;,&#10;&#9;&#9;&#9;Path:     &quot;/api/v1/products/1&quot;,&#10;&#9;&#9;&#9;Expected: 200,&#10;&#9;&#9;},&#10;&#9;&#9;{&#10;&#9;&#9;&#9;Name:     &quot;View Product Details&quot;,&#10;&#9;&#9;&#9;Method:   &quot;GET&quot;,&#10;&#9;&#9;&#9;Path:     &quot;/api/v1/products/1/detail&quot;,&#10;&#9;&#9;&#9;Expected: 200,&#10;&#9;&#9;},&#10;&#9;&#9;{&#10;&#9;&#9;&#9;Name:     &quot;Check Product SKUs&quot;,&#10;&#9;&#9;&#9;Method:   &quot;GET&quot;,&#10;&#9;&#9;&#9;Path:     &quot;/api/v1/products/skus/1&quot;,&#10;&#9;&#9;&#9;Expected: 200,&#10;&#9;&#9;},&#10;&#9;&#9;{&#10;&#9;&#9;&#9;Name:     &quot;Add to Cart&quot;,&#10;&#9;&#9;&#9;Method:   &quot;POST&quot;,&#10;&#9;&#9;&#9;Path:     &quot;/api/v1/cart/items&quot;,&#10;&#9;&#9;&#9;Body: map[string]interface{}{&#10;&#9;&#9;&#9;&#9;&quot;product_sku_id&quot;: 1,&#10;&#9;&#9;&#9;&#9;&quot;quantity&quot;:       2,&#10;&#9;&#9;&#9;},&#10;&#9;&#9;&#9;Expected: 201,&#10;&#9;&#9;},&#10;&#9;&#9;{&#10;&#9;&#9;&#9;Name:     &quot;View Cart&quot;,&#10;&#9;&#9;&#9;Method:   &quot;GET&quot;,&#10;&#9;&#9;&#9;Path:     &quot;/api/v1/cart/1&quot;,&#10;&#9;&#9;&#9;Expected: 200,&#10;&#9;&#9;},&#10;&#9;}&#10;&#10;&#9;return abs.httpTester.TestUserJourney(testConfig, journey)&#10;}&#10;&#10;// BenchmarkCreateProductStress tests product creation under load&#10;func (abs *APIBenchmarkSuite) BenchmarkCreateProductStress() *benchmark.BenchmarkResult {&#10;&#9;testConfig := load.HTTPTestConfig{&#10;&#9;&#9;BaseURL:   abs.baseURL,&#10;&#9;&#9;AuthToken: abs.authToken,&#10;&#9;&#9;Headers: map[string]string{&#10;&#9;&#9;&#9;&quot;Content-Type&quot;: &quot;application/json&quot;,&#10;&#9;&#9;},&#10;&#9;&#9;Timeout: 30 * time.Second,&#10;&#9;}&#10;&#10;&#9;// Sample product data&#10;&#9;productData := map[string]interface{}{&#10;&#9;&#9;&quot;name&quot;:        fmt.Sprintf(&quot;Stress Test Product %d&quot;, rand.Intn(10000)),&#10;&#9;&#9;&quot;description&quot;: &quot;Product created during stress testing&quot;,&#10;&#9;&#9;&quot;base_price&quot;:  99.99,&#10;&#9;&#9;&quot;category_id&quot;: 1,&#10;&#9;&#9;&quot;status&quot;:      &quot;ACTIVE&quot;,&#10;&#9;&#9;&quot;options&quot;: map[string][]string{&#10;&#9;&#9;&#9;&quot;1&quot;: {&quot;Red&quot;, &quot;Blue&quot;},&#10;&#9;&#9;&#9;&quot;2&quot;: {&quot;S&quot;, &quot;M&quot;, &quot;L&quot;},&#10;&#9;&#9;},&#10;&#9;}&#10;&#10;&#9;endpoint := load.EndpointTest{&#10;&#9;&#9;Name:     &quot;Create Product Under Load&quot;,&#10;&#9;&#9;Method:   &quot;POST&quot;,&#10;&#9;&#9;Path:     &quot;/api/v1/products&quot;,&#10;&#9;&#9;Body:     productData,&#10;&#9;&#9;Expected: 201,&#10;&#9;}&#10;&#10;&#9;return abs.httpTester.TestEndpoint(testConfig, endpoint)&#10;}&#10;&#10;// BenchmarkMicroservicesCommunication tests inter-service communication&#10;func (abs *APIBenchmarkSuite) BenchmarkMicroservicesCommunication() []*benchmark.BenchmarkResult {&#10;&#9;results := make([]*benchmark.BenchmarkResult, 0)&#10;&#10;&#9;// Test scenarios that involve multiple services&#10;&#9;scenarios := []struct {&#10;&#9;&#9;name        string&#10;&#9;&#9;description string&#10;&#9;&#9;endpoints   []load.EndpointTest&#10;&#9;}{&#10;&#9;&#9;{&#10;&#9;&#9;&#9;name:        &quot;User Registration Flow&quot;,&#10;&#9;&#9;&#9;description: &quot;Tests identity + cart service communication&quot;,&#10;&#9;&#9;&#9;endpoints: []load.EndpointTest{&#10;&#9;&#9;&#9;&#9;{&#10;&#9;&#9;&#9;&#9;&#9;Name:   &quot;Create User&quot;,&#10;&#9;&#9;&#9;&#9;&#9;Method: &quot;POST&quot;,&#10;&#9;&#9;&#9;&#9;&#9;Path:   &quot;/api/v1/users&quot;,&#10;&#9;&#9;&#9;&#9;&#9;Body: map[string]interface{}{&#10;&#9;&#9;&#9;&#9;&#9;&#9;&quot;email&quot;:      fmt.Sprintf(&quot;micro%d@test.com&quot;, rand.Intn(10000)),&#10;&#9;&#9;&#9;&#9;&#9;&#9;&quot;password&quot;:   &quot;Test123!&quot;,&#10;&#9;&#9;&#9;&#9;&#9;&#9;&quot;first_name&quot;: &quot;Micro&quot;,&#10;&#9;&#9;&#9;&#9;&#9;&#9;&quot;last_name&quot;:  &quot;Test&quot;,&#10;&#9;&#9;&#9;&#9;&#9;},&#10;&#9;&#9;&#9;&#9;&#9;Expected: 201,&#10;&#9;&#9;&#9;&#9;},&#10;&#9;&#9;&#9;},&#10;&#9;&#9;},&#10;&#9;&#9;{&#10;&#9;&#9;&#9;name:        &quot;Product to Cart Flow&quot;,&#10;&#9;&#9;&#9;description: &quot;Tests product + cart service communication&quot;,&#10;&#9;&#9;&#9;endpoints: []load.EndpointTest{&#10;&#9;&#9;&#9;&#9;{&#10;&#9;&#9;&#9;&#9;&#9;Name:     &quot;Get Product&quot;,&#10;&#9;&#9;&#9;&#9;&#9;Method:   &quot;GET&quot;,&#10;&#9;&#9;&#9;&#9;&#9;Path:     &quot;/api/v1/products/1&quot;,&#10;&#9;&#9;&#9;&#9;&#9;Expected: 200,&#10;&#9;&#9;&#9;&#9;},&#10;&#9;&#9;&#9;&#9;{&#10;&#9;&#9;&#9;&#9;&#9;Name:     &quot;Get Product SKU&quot;,&#10;&#9;&#9;&#9;&#9;&#9;Method:   &quot;GET&quot;,&#10;&#9;&#9;&#9;&#9;&#9;Path:     &quot;/api/v1/products/skus/1&quot;,&#10;&#9;&#9;&#9;&#9;&#9;Expected: 200,&#10;&#9;&#9;&#9;&#9;},&#10;&#9;&#9;&#9;},&#10;&#9;&#9;},&#10;&#9;}&#10;&#10;&#9;testConfig := load.HTTPTestConfig{&#10;&#9;&#9;BaseURL:   abs.baseURL,&#10;&#9;&#9;AuthToken: abs.authToken,&#10;&#9;&#9;Headers: map[string]string{&#10;&#9;&#9;&#9;&quot;Content-Type&quot;: &quot;application/json&quot;,&#10;&#9;&#9;},&#10;&#9;&#9;Timeout: 30 * time.Second,&#10;&#9;}&#10;&#10;&#9;for _, scenario := range scenarios {&#10;&#9;&#9;result := abs.httpTester.TestUserJourney(testConfig, scenario.endpoints)&#10;&#9;&#9;result.TestName = scenario.name&#10;&#9;&#9;results = append(results, result)&#10;&#9;}&#10;&#10;&#9;return results&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/benchmarks/pkg/benchmark/runner.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/benchmarks/pkg/benchmark/runner.go" />
              <option name="updatedContent" value="package benchmark&#10;&#10;import (&#10;&#9;&quot;context&quot;&#10;&#9;&quot;fmt&quot;&#10;&#9;&quot;log&quot;&#10;&#9;&quot;sync&quot;&#10;&#9;&quot;time&quot;&#10;&#10;&#9;&quot;github.com/montanaflynn/stats&quot;&#10;)&#10;&#10;// BenchmarkConfig holds configuration for benchmark tests&#10;type BenchmarkConfig struct {&#10;&#9;Duration     time.Duration&#10;&#9;Concurrency  int&#10;&#9;RampUpTime   time.Duration&#10;&#9;Iterations   int&#10;&#9;WarmupTime   time.Duration&#10;&#9;OutputFormat string // json, table, csv&#10;}&#10;&#10;// BenchmarkResult contains the results of a benchmark test&#10;type BenchmarkResult struct {&#10;&#9;TestName        string            `json:&quot;test_name&quot;`&#10;&#9;Duration        time.Duration     `json:&quot;duration&quot;`&#10;&#9;TotalRequests   int64             `json:&quot;total_requests&quot;`&#10;&#9;SuccessRequests int64             `json:&quot;success_requests&quot;`&#10;&#9;FailedRequests  int64             `json:&quot;failed_requests&quot;`&#10;&#9;RequestsPerSec  float64           `json:&quot;requests_per_sec&quot;`&#10;&#9;AvgResponseTime time.Duration     `json:&quot;avg_response_time&quot;`&#10;&#9;MinResponseTime time.Duration     `json:&quot;min_response_time&quot;`&#10;&#9;MaxResponseTime time.Duration     `json:&quot;max_response_time&quot;`&#10;&#9;P50ResponseTime time.Duration     `json:&quot;p50_response_time&quot;`&#10;&#9;P95ResponseTime time.Duration     `json:&quot;p95_response_time&quot;`&#10;&#9;P99ResponseTime time.Duration     `json:&quot;p99_response_time&quot;`&#10;&#9;ErrorRate       float64           `json:&quot;error_rate&quot;`&#10;&#9;Errors          map[string]int64  `json:&quot;errors&quot;`&#10;&#9;CustomMetrics   map[string]interface{} `json:&quot;custom_metrics&quot;`&#10;&#9;Timestamp       time.Time         `json:&quot;timestamp&quot;`&#10;}&#10;&#10;// BenchmarkRunner manages benchmark execution&#10;type BenchmarkRunner struct {&#10;&#9;config   BenchmarkConfig&#10;&#9;results  []BenchmarkResult&#10;&#9;mu       sync.RWMutex&#10;}&#10;&#10;// NewBenchmarkRunner creates a new benchmark runner&#10;func NewBenchmarkRunner(config BenchmarkConfig) *BenchmarkRunner {&#10;&#9;return &amp;BenchmarkRunner{&#10;&#9;&#9;config:  config,&#10;&#9;&#9;results: make([]BenchmarkResult, 0),&#10;&#9;}&#10;}&#10;&#10;// TestFunc represents a function to be benchmarked&#10;type TestFunc func(ctx context.Context) error&#10;&#10;// Run executes a benchmark test&#10;func (br *BenchmarkRunner) Run(testName string, testFunc TestFunc) *BenchmarkResult {&#10;&#9;log.Printf(&quot; Starting benchmark: %s&quot;, testName)&#10;&#9;log.Printf(&quot; Config: Duration=%v, Concurrency=%d, Iterations=%d&quot;, &#10;&#9;&#9;br.config.Duration, br.config.Concurrency, br.config.Iterations)&#10;&#10;&#9;result := &amp;BenchmarkResult{&#10;&#9;&#9;TestName:      testName,&#10;&#9;&#9;Errors:        make(map[string]int64),&#10;&#9;&#9;CustomMetrics: make(map[string]interface{}),&#10;&#9;&#9;Timestamp:     time.Now(),&#10;&#9;}&#10;&#10;&#9;// Warmup phase&#10;&#9;if br.config.WarmupTime &gt; 0 {&#10;&#9;&#9;log.Printf(&quot; Warming up for %v...&quot;, br.config.WarmupTime)&#10;&#9;&#9;br.warmup(testFunc)&#10;&#9;}&#10;&#10;&#9;// Main benchmark execution&#10;&#9;responseTimes := make([]float64, 0)&#10;&#9;var responseTimesMu sync.Mutex&#10;&#10;&#9;var wg sync.WaitGroup&#10;&#9;results := make(chan benchmarkAttempt, br.config.Concurrency*2)&#10;&#10;&#9;startTime := time.Now()&#10;&#9;ctx, cancel := context.WithTimeout(context.Background(), br.config.Duration)&#10;&#9;defer cancel()&#10;&#10;&#9;// Start workers&#10;&#9;for i := 0; i &lt; br.config.Concurrency; i++ {&#10;&#9;&#9;wg.Add(1)&#10;&#9;&#9;go func(workerID int) {&#10;&#9;&#9;&#9;defer wg.Done()&#10;&#9;&#9;&#9;br.worker(ctx, workerID, testFunc, results)&#10;&#9;&#9;}(i)&#10;&#9;}&#10;&#10;&#9;// Collect results&#10;&#9;go func() {&#10;&#9;&#9;wg.Wait()&#10;&#9;&#9;close(results)&#10;&#9;}()&#10;&#10;&#9;// Process results&#10;&#9;for attempt := range results {&#10;&#9;&#9;result.TotalRequests++&#10;&#9;&#9;&#10;&#9;&#9;if attempt.err != nil {&#10;&#9;&#9;&#9;result.FailedRequests++&#10;&#9;&#9;&#9;errorMsg := attempt.err.Error()&#10;&#9;&#9;&#9;result.Errors[errorMsg]++&#10;&#9;&#9;} else {&#10;&#9;&#9;&#9;result.SuccessRequests++&#10;&#9;&#9;&#9;responseTimesMu.Lock()&#10;&#9;&#9;&#9;responseTimes = append(responseTimes, float64(attempt.responseTime.Nanoseconds()))&#10;&#9;&#9;&#9;responseTimesMu.Unlock()&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;result.Duration = time.Since(startTime)&#10;&#10;&#9;// Calculate statistics&#10;&#9;if len(responseTimes) &gt; 0 {&#10;&#9;&#9;br.calculateStatistics(result, responseTimes)&#10;&#9;}&#10;&#10;&#9;result.RequestsPerSec = float64(result.TotalRequests) / result.Duration.Seconds()&#10;&#9;result.ErrorRate = float64(result.FailedRequests) / float64(result.TotalRequests) * 100&#10;&#10;&#9;br.mu.Lock()&#10;&#9;br.results = append(br.results, *result)&#10;&#9;br.mu.Unlock()&#10;&#10;&#9;br.printResult(result)&#10;&#9;return result&#10;}&#10;&#10;type benchmarkAttempt struct {&#10;&#9;responseTime time.Duration&#10;&#9;err          error&#10;}&#10;&#10;func (br *BenchmarkRunner) worker(ctx context.Context, workerID int, testFunc TestFunc, results chan&lt;- benchmarkAttempt) {&#10;&#9;for {&#10;&#9;&#9;select {&#10;&#9;&#9;case &lt;-ctx.Done():&#10;&#9;&#9;&#9;return&#10;&#9;&#9;default:&#10;&#9;&#9;&#9;start := time.Now()&#10;&#9;&#9;&#9;err := testFunc(ctx)&#10;&#9;&#9;&#9;responseTime := time.Since(start)&#10;&#9;&#9;&#9;&#10;&#9;&#9;&#9;results &lt;- benchmarkAttempt{&#10;&#9;&#9;&#9;&#9;responseTime: responseTime,&#10;&#9;&#9;&#9;&#9;err:          err,&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#9;}&#10;}&#10;&#10;func (br *BenchmarkRunner) warmup(testFunc TestFunc) {&#10;&#9;ctx, cancel := context.WithTimeout(context.Background(), br.config.WarmupTime)&#10;&#9;defer cancel()&#10;&#10;&#9;for i := 0; i &lt; br.config.Concurrency; i++ {&#10;&#9;&#9;go func() {&#10;&#9;&#9;&#9;for {&#10;&#9;&#9;&#9;&#9;select {&#10;&#9;&#9;&#9;&#9;case &lt;-ctx.Done():&#10;&#9;&#9;&#9;&#9;&#9;return&#10;&#9;&#9;&#9;&#9;default:&#10;&#9;&#9;&#9;&#9;&#9;testFunc(ctx)&#10;&#9;&#9;&#9;&#9;&#9;time.Sleep(10 * time.Millisecond)&#10;&#9;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}()&#10;&#9;}&#10;&#10;&#9;&lt;-ctx.Done()&#10;}&#10;&#10;func (br *BenchmarkRunner) calculateStatistics(result *BenchmarkResult, responseTimes []float64) {&#10;&#9;if len(responseTimes) == 0 {&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;// Convert to time.Duration for easier handling&#10;&#9;avg, _ := stats.Mean(responseTimes)&#10;&#9;min, _ := stats.Min(responseTimes)&#10;&#9;max, _ := stats.Max(responseTimes)&#10;&#9;p50, _ := stats.Percentile(responseTimes, 50)&#10;&#9;p95, _ := stats.Percentile(responseTimes, 95)&#10;&#9;p99, _ := stats.Percentile(responseTimes, 99)&#10;&#10;&#9;result.AvgResponseTime = time.Duration(avg)&#10;&#9;result.MinResponseTime = time.Duration(min)&#10;&#9;result.MaxResponseTime = time.Duration(max)&#10;&#9;result.P50ResponseTime = time.Duration(p50)&#10;&#9;result.P95ResponseTime = time.Duration(p95)&#10;&#9;result.P99ResponseTime = time.Duration(p99)&#10;}&#10;&#10;func (br *BenchmarkRunner) printResult(result *BenchmarkResult) {&#10;&#9;log.Printf(&quot;✅ Benchmark completed: %s&quot;, result.TestName)&#10;&#9;log.Printf(&quot;⏱️  Duration: %v&quot;, result.Duration)&#10;&#9;log.Printf(&quot; Requests: %d total, %d success, %d failed&quot;, &#10;&#9;&#9;result.TotalRequests, result.SuccessRequests, result.FailedRequests)&#10;&#9;log.Printf(&quot; RPS: %.2f&quot;, result.RequestsPerSec)&#10;&#9;log.Printf(&quot; Response Times - Avg: %v, P50: %v, P95: %v, P99: %v&quot;, &#10;&#9;&#9;result.AvgResponseTime, result.P50ResponseTime, result.P95ResponseTime, result.P99ResponseTime)&#10;&#9;log.Printf(&quot;❌ Error Rate: %.2f%%&quot;, result.ErrorRate)&#10;&#9;&#10;&#9;if len(result.Errors) &gt; 0 {&#10;&#9;&#9;log.Printf(&quot; Errors:&quot;)&#10;&#9;&#9;for err, count := range result.Errors {&#10;&#9;&#9;&#9;log.Printf(&quot;   - %s: %d&quot;, err, count)&#10;&#9;&#9;}&#10;&#9;}&#10;&#9;log.Printf(&quot;=&quot; + fmt.Sprintf(&quot;%*s&quot;, 50, &quot;=&quot;))&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/benchmarks/pkg/database/db_benchmarker.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/benchmarks/pkg/database/db_benchmarker.go" />
              <option name="updatedContent" value="package database&#10;&#10;import (&#10;&#9;&quot;context&quot;&#10;&#9;&quot;database/sql&quot;&#10;&#9;&quot;fmt&quot;&#10;&#9;&quot;time&quot;&#10;&#10;&#9;&quot;github.com/hthinh24/go-store/benchmarks/pkg/benchmark&quot;&#10;&#9;&quot;gorm.io/gorm&quot;&#10;)&#10;&#10;// DBBenchmarker handles database performance testing&#10;type DBBenchmarker struct {&#10;&#9;db     *gorm.DB&#10;&#9;runner *benchmark.BenchmarkRunner&#10;}&#10;&#10;// QueryTest defines a database query to benchmark&#10;type QueryTest struct {&#10;&#9;Name        string&#10;&#9;Query       string&#10;&#9;Args        []interface{}&#10;&#9;ExpectedRows int&#10;}&#10;&#10;// NewDBBenchmarker creates a new database benchmarker&#10;func NewDBBenchmarker(db *gorm.DB, config benchmark.BenchmarkConfig) *DBBenchmarker {&#10;&#9;return &amp;DBBenchmarker{&#10;&#9;&#9;db:     db,&#10;&#9;&#9;runner: benchmark.NewBenchmarkRunner(config),&#10;&#9;}&#10;}&#10;&#10;// BenchmarkQuery tests query performance&#10;func (db *DBBenchmarker) BenchmarkQuery(test QueryTest) *benchmark.BenchmarkResult {&#10;&#9;testFunc := func(ctx context.Context) error {&#10;&#9;&#9;rows, err := db.db.Raw(test.Query, test.Args...).Rows()&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;return fmt.Errorf(&quot;query failed: %w&quot;, err)&#10;&#9;&#9;}&#10;&#9;&#9;defer rows.Close()&#10;&#10;&#9;&#9;count := 0&#10;&#9;&#9;for rows.Next() {&#10;&#9;&#9;&#9;count++&#10;&#9;&#9;}&#10;&#10;&#9;&#9;if test.ExpectedRows &gt; 0 &amp;&amp; count != test.ExpectedRows {&#10;&#9;&#9;&#9;return fmt.Errorf(&quot;unexpected row count: got %d, expected %d&quot;, count, test.ExpectedRows)&#10;&#9;&#9;}&#10;&#10;&#9;&#9;return rows.Err()&#10;&#9;}&#10;&#10;&#9;return db.runner.Run(fmt.Sprintf(&quot;Query: %s&quot;, test.Name), testFunc)&#10;}&#10;&#10;// BenchmarkConnectionPool tests database connection pool performance&#10;func (db *DBBenchmarker) BenchmarkConnectionPool() *benchmark.BenchmarkResult {&#10;&#9;testFunc := func(ctx context.Context) error {&#10;&#9;&#9;sqlDB, err := db.db.DB()&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;return err&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// Simple ping to test connection acquisition&#10;&#9;&#9;return sqlDB.PingContext(ctx)&#10;&#9;}&#10;&#10;&#9;return db.runner.Run(&quot;Connection Pool&quot;, testFunc)&#10;}&#10;&#10;// BenchmarkTransaction tests transaction performance&#10;func (db *DBBenchmarker) BenchmarkTransaction(operations []func(*gorm.DB) error) *benchmark.BenchmarkResult {&#10;&#9;testFunc := func(ctx context.Context) error {&#10;&#9;&#9;return db.db.Transaction(func(tx *gorm.DB) error {&#10;&#9;&#9;&#9;for _, op := range operations {&#10;&#9;&#9;&#9;&#9;if err := op(tx); err != nil {&#10;&#9;&#9;&#9;&#9;&#9;return err&#10;&#9;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;return nil&#10;&#9;&#9;})&#10;&#9;}&#10;&#10;&#9;return db.runner.Run(&quot;Transaction&quot;, testFunc)&#10;}&#10;&#10;// BenchmarkProductQueries tests common product-related queries&#10;func (db *DBBenchmarker) BenchmarkProductQueries() []*benchmark.BenchmarkResult {&#10;&#9;queries := []QueryTest{&#10;&#9;&#9;{&#10;&#9;&#9;&#9;Name:  &quot;Get Product by ID&quot;,&#10;&#9;&#9;&#9;Query: &quot;SELECT * FROM products WHERE id = ?&quot;,&#10;&#9;&#9;&#9;Args:  []interface{}{1},&#10;&#9;&#9;},&#10;&#9;&#9;{&#10;&#9;&#9;&#9;Name:  &quot;Get Products by Category&quot;,&#10;&#9;&#9;&#9;Query: &quot;SELECT * FROM products WHERE category_id = ? LIMIT 20&quot;,&#10;&#9;&#9;&#9;Args:  []interface{}{1},&#10;&#9;&#9;},&#10;&#9;&#9;{&#10;&#9;&#9;&#9;Name:  &quot;Search Products&quot;,&#10;&#9;&#9;&#9;Query: &quot;SELECT * FROM products WHERE name ILIKE ? OR description ILIKE ? LIMIT 20&quot;,&#10;&#9;&#9;&#9;Args:  []interface{}{&quot;%shirt%&quot;, &quot;%shirt%&quot;},&#10;&#9;&#9;},&#10;&#9;&#9;{&#10;&#9;&#9;&#9;Name:  &quot;Get Product with SKUs&quot;,&#10;&#9;&#9;&#9;Query: `SELECT p.*, ps.* FROM products p &#10;&#9;&#9;&#9;&#9;&#9;LEFT JOIN product_skus ps ON p.id = ps.product_id &#10;&#9;&#9;&#9;&#9;&#9;WHERE p.id = ?`,&#10;&#9;&#9;&#9;Args:  []interface{}{1},&#10;&#9;&#9;},&#10;&#9;&#9;{&#10;&#9;&#9;&#9;Name:  &quot;Get Active Products Count&quot;,&#10;&#9;&#9;&#9;Query: &quot;SELECT COUNT(*) FROM products WHERE status = 'ACTIVE'&quot;,&#10;&#9;&#9;},&#10;&#9;}&#10;&#10;&#9;results := make([]*benchmark.BenchmarkResult, 0, len(queries))&#10;&#9;for _, query := range queries {&#10;&#9;&#9;result := db.BenchmarkQuery(query)&#10;&#9;&#9;results = append(results, result)&#10;&#9;}&#10;&#10;&#9;return results&#10;}&#10;&#10;// BenchmarkUserQueries tests common user-related queries&#10;func (db *DBBenchmarker) BenchmarkUserQueries() []*benchmark.BenchmarkResult {&#10;&#9;queries := []QueryTest{&#10;&#9;&#9;{&#10;&#9;&#9;&#9;Name:  &quot;Get User by ID&quot;,&#10;&#9;&#9;&#9;Query: &quot;SELECT * FROM users WHERE id = ?&quot;,&#10;&#9;&#9;&#9;Args:  []interface{}{1},&#10;&#9;&#9;},&#10;&#9;&#9;{&#10;&#9;&#9;&#9;Name:  &quot;Get User by Email&quot;,&#10;&#9;&#9;&#9;Query: &quot;SELECT * FROM users WHERE email = ?&quot;,&#10;&#9;&#9;&#9;Args:  []interface{}{&quot;test@example.com&quot;},&#10;&#9;&#9;},&#10;&#9;&#9;{&#10;&#9;&#9;&#9;Name:  &quot;Get User with Cart&quot;,&#10;&#9;&#9;&#9;Query: `SELECT u.*, c.* FROM users u &#10;&#9;&#9;&#9;&#9;&#9;LEFT JOIN carts c ON u.id = c.user_id &#10;&#9;&#9;&#9;&#9;&#9;WHERE u.id = ?`,&#10;&#9;&#9;&#9;Args:  []interface{}{1},&#10;&#9;&#9;},&#10;&#9;}&#10;&#10;&#9;results := make([]*benchmark.BenchmarkResult, 0, len(queries))&#10;&#9;for _, query := range queries {&#10;&#9;&#9;result := db.BenchmarkQuery(query)&#10;&#9;&#9;results = append(results, result)&#10;&#9;}&#10;&#10;&#9;return results&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/benchmarks/pkg/load/http_tester.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/benchmarks/pkg/load/http_tester.go" />
              <option name="updatedContent" value="package load&#10;&#10;import (&#10;&#9;&quot;context&quot;&#10;&#9;&quot;fmt&quot;&#10;&#9;&quot;net/http&quot;&#10;&#9;&quot;time&quot;&#10;&#10;&#9;&quot;github.com/go-resty/resty/v2&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/benchmarks/pkg/benchmark&quot;&#10;)&#10;&#10;// HTTPLoadTester handles HTTP endpoint load testing&#10;type HTTPLoadTester struct {&#10;&#9;client *resty.Client&#10;&#9;runner *benchmark.BenchmarkRunner&#10;}&#10;&#10;// HTTPTestConfig holds HTTP-specific test configuration&#10;type HTTPTestConfig struct {&#10;&#9;BaseURL     string&#10;&#9;Endpoints   []EndpointTest&#10;&#9;Headers     map[string]string&#10;&#9;Timeout     time.Duration&#10;&#9;RetryCount  int&#10;&#9;AuthToken   string&#10;}&#10;&#10;// EndpointTest defines a specific endpoint to test&#10;type EndpointTest struct {&#10;&#9;Name     string&#10;&#9;Method   string&#10;&#9;Path     string&#10;&#9;Body     interface{}&#10;&#9;Headers  map[string]string&#10;&#9;Expected int // Expected status code&#10;}&#10;&#10;// NewHTTPLoadTester creates a new HTTP load tester&#10;func NewHTTPLoadTester(config benchmark.BenchmarkConfig) *HTTPLoadTester {&#10;&#9;client := resty.New().&#10;&#9;&#9;SetTimeout(30 * time.Second).&#10;&#9;&#9;SetRetryCount(3).&#10;&#9;&#9;SetRetryWaitTime(100 * time.Millisecond)&#10;&#10;&#9;return &amp;HTTPLoadTester{&#10;&#9;&#9;client: client,&#10;&#9;&#9;runner: benchmark.NewBenchmarkRunner(config),&#10;&#9;}&#10;}&#10;&#10;// TestEndpoint performs load testing on a specific endpoint&#10;func (ht *HTTPLoadTester) TestEndpoint(testConfig HTTPTestConfig, endpoint EndpointTest) *benchmark.BenchmarkResult {&#10;&#9;// Setup client with base configuration&#10;&#9;if testConfig.AuthToken != &quot;&quot; {&#10;&#9;&#9;ht.client.SetAuthToken(testConfig.AuthToken)&#10;&#9;}&#10;&#9;&#10;&#9;if testConfig.Headers != nil {&#10;&#9;&#9;ht.client.SetHeaders(testConfig.Headers)&#10;&#9;}&#10;&#10;&#9;testFunc := func(ctx context.Context) error {&#10;&#9;&#9;req := ht.client.R()&#10;&#9;&#9;&#10;&#9;&#9;// Add endpoint-specific headers&#10;&#9;&#9;if endpoint.Headers != nil {&#10;&#9;&#9;&#9;req.SetHeaders(endpoint.Headers)&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// Add body if present&#10;&#9;&#9;if endpoint.Body != nil {&#10;&#9;&#9;&#9;req.SetBody(endpoint.Body)&#10;&#9;&#9;}&#10;&#10;&#9;&#9;url := testConfig.BaseURL + endpoint.Path&#10;&#9;&#9;var resp *resty.Response&#10;&#9;&#9;var err error&#10;&#10;&#9;&#9;switch endpoint.Method {&#10;&#9;&#9;case &quot;GET&quot;:&#10;&#9;&#9;&#9;resp, err = req.Get(url)&#10;&#9;&#9;case &quot;POST&quot;:&#10;&#9;&#9;&#9;resp, err = req.Post(url)&#10;&#9;&#9;case &quot;PUT&quot;:&#10;&#9;&#9;&#9;resp, err = req.Put(url)&#10;&#9;&#9;case &quot;DELETE&quot;:&#10;&#9;&#9;&#9;resp, err = req.Delete(url)&#10;&#9;&#9;case &quot;PATCH&quot;:&#10;&#9;&#9;&#9;resp, err = req.Patch(url)&#10;&#9;&#9;default:&#10;&#9;&#9;&#9;return fmt.Errorf(&quot;unsupported HTTP method: %s&quot;, endpoint.Method)&#10;&#9;&#9;}&#10;&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;return fmt.Errorf(&quot;request failed: %w&quot;, err)&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// Check expected status code&#10;&#9;&#9;if endpoint.Expected != 0 &amp;&amp; resp.StatusCode() != endpoint.Expected {&#10;&#9;&#9;&#9;return fmt.Errorf(&quot;unexpected status code: got %d, expected %d&quot;, resp.StatusCode(), endpoint.Expected)&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// Check for HTTP errors&#10;&#9;&#9;if resp.StatusCode() &gt;= 400 {&#10;&#9;&#9;&#9;return fmt.Errorf(&quot;HTTP error: %d - %s&quot;, resp.StatusCode(), resp.Status())&#10;&#9;&#9;}&#10;&#10;&#9;&#9;return nil&#10;&#9;}&#10;&#10;&#9;testName := fmt.Sprintf(&quot;%s %s %s&quot;, endpoint.Method, endpoint.Name, endpoint.Path)&#10;&#9;return ht.runner.Run(testName, testFunc)&#10;}&#10;&#10;// TestAllEndpoints runs load tests on all configured endpoints&#10;func (ht *HTTPLoadTester) TestAllEndpoints(testConfig HTTPTestConfig) []*benchmark.BenchmarkResult {&#10;&#9;results := make([]*benchmark.BenchmarkResult, 0, len(testConfig.Endpoints))&#10;&#9;&#10;&#9;for _, endpoint := range testConfig.Endpoints {&#10;&#9;&#9;result := ht.TestEndpoint(testConfig, endpoint)&#10;&#9;&#9;results = append(results, result)&#10;&#9;&#9;&#10;&#9;&#9;// Small delay between endpoint tests&#10;&#9;&#9;time.Sleep(1 * time.Second)&#10;&#9;}&#10;&#9;&#10;&#9;return results&#10;}&#10;&#10;// TestUserJourney simulates a complete user journey with multiple API calls&#10;func (ht *HTTPLoadTester) TestUserJourney(testConfig HTTPTestConfig, journey []EndpointTest) *benchmark.BenchmarkResult {&#10;&#9;testFunc := func(ctx context.Context) error {&#10;&#9;&#9;for _, step := range journey {&#10;&#9;&#9;&#9;req := ht.client.R()&#10;&#9;&#9;&#9;&#10;&#9;&#9;&#9;if step.Headers != nil {&#10;&#9;&#9;&#9;&#9;req.SetHeaders(step.Headers)&#10;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;&#10;&#9;&#9;&#9;if step.Body != nil {&#10;&#9;&#9;&#9;&#9;req.SetBody(step.Body)&#10;&#9;&#9;&#9;}&#10;&#10;&#9;&#9;&#9;url := testConfig.BaseURL + step.Path&#10;&#9;&#9;&#9;var resp *resty.Response&#10;&#9;&#9;&#9;var err error&#10;&#10;&#9;&#9;&#9;switch step.Method {&#10;&#9;&#9;&#9;case &quot;GET&quot;:&#10;&#9;&#9;&#9;&#9;resp, err = req.Get(url)&#10;&#9;&#9;&#9;case &quot;POST&quot;:&#10;&#9;&#9;&#9;&#9;resp, err = req.Post(url)&#10;&#9;&#9;&#9;case &quot;PUT&quot;:&#10;&#9;&#9;&#9;&#9;resp, err = req.Put(url)&#10;&#9;&#9;&#9;case &quot;DELETE&quot;:&#10;&#9;&#9;&#9;&#9;resp, err = req.Delete(url)&#10;&#9;&#9;&#9;default:&#10;&#9;&#9;&#9;&#9;return fmt.Errorf(&quot;unsupported HTTP method: %s&quot;, step.Method)&#10;&#9;&#9;&#9;}&#10;&#10;&#9;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;&#9;return fmt.Errorf(&quot;step '%s' failed: %w&quot;, step.Name, err)&#10;&#9;&#9;&#9;}&#10;&#10;&#9;&#9;&#9;if step.Expected != 0 &amp;&amp; resp.StatusCode() != step.Expected {&#10;&#9;&#9;&#9;&#9;return fmt.Errorf(&quot;step '%s': unexpected status code: got %d, expected %d&quot;, &#10;&#9;&#9;&#9;&#9;&#9;step.Name, resp.StatusCode(), step.Expected)&#10;&#9;&#9;&#9;}&#10;&#10;&#9;&#9;&#9;if resp.StatusCode() &gt;= 400 {&#10;&#9;&#9;&#9;&#9;return fmt.Errorf(&quot;step '%s': HTTP error: %d - %s&quot;, &#10;&#9;&#9;&#9;&#9;&#9;step.Name, resp.StatusCode(), resp.Status())&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#9;&#9;return nil&#10;&#9;}&#10;&#10;&#9;return ht.runner.Run(&quot;User Journey&quot;, testFunc)&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/internal/pkg/auth/auth_middleware.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/internal/pkg/auth/auth_middleware.go" />
              <option name="updatedContent" value="package auth&#10;&#10;import (&#10;&#9;&quot;net/http&quot;&#10;&#9;&quot;strings&quot;&#10;&#9;&quot;time&quot;&#10;&#10;&#9;&quot;github.com/gin-gonic/gin&quot;&#10;&#9;&quot;github.com/golang-jwt/jwt/v4&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/internal/pkg/logger&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/internal/pkg/rest&quot;&#10;)&#10;&#10;type SharedAuthMiddleware struct {&#10;&#9;logger    logger.Logger&#10;&#9;jwtSecret string&#10;}&#10;&#10;type JWTClaims struct {&#10;&#9;UserID           int64     `json:&quot;user_id&quot;`&#10;&#9;Email            string    `json:&quot;email&quot;`&#10;&#9;Roles            []string  `json:&quot;roles&quot;`&#10;&#9;Permissions      []string  `json:&quot;permissions&quot;`&#10;&#9;RefreshExpiresAt time.Time `json:&quot;refresh_expires_at&quot;`&#10;&#9;jwt.RegisteredClaims&#10;}&#10;&#10;func NewSharedAuthMiddleware(logger logger.Logger, jwtSecret string) *SharedAuthMiddleware {&#10;&#9;return &amp;SharedAuthMiddleware{&#10;&#9;&#9;logger:    logger,&#10;&#9;&#9;jwtSecret: jwtSecret,&#10;&#9;}&#10;}&#10;&#10;// AuthRequired validates JWT token and sets user info in context&#10;func (m *SharedAuthMiddleware) AuthRequired() gin.HandlerFunc {&#10;&#9;return func(c *gin.Context) {&#10;&#9;&#9;authHeader := c.GetHeader(&quot;Authorization&quot;)&#10;&#9;&#9;if authHeader == &quot;&quot; {&#10;&#9;&#9;&#9;c.JSON(http.StatusUnauthorized, rest.ErrorResponse{&#10;&#9;&#9;&#9;&#9;ApiError: rest.UnauthorizedError,&#10;&#9;&#9;&#9;&#9;Message:  &quot;Authorization header required&quot;,&#10;&#9;&#9;&#9;})&#10;&#9;&#9;&#9;c.Abort()&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#10;&#9;&#9;tokenString := strings.TrimPrefix(authHeader, &quot;Bearer &quot;)&#10;&#9;&#9;if tokenString == authHeader {&#10;&#9;&#9;&#9;c.JSON(http.StatusUnauthorized, rest.ErrorResponse{&#10;&#9;&#9;&#9;&#9;ApiError: rest.UnauthorizedError,&#10;&#9;&#9;&#9;&#9;Message:  &quot;Bearer token required&quot;,&#10;&#9;&#9;&#9;})&#10;&#9;&#9;&#9;c.Abort()&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#10;&#9;&#9;claims, err := m.validateToken(tokenString)&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;m.logger.Error(&quot;Failed to validate JWT token&quot;, &quot;error&quot;, err)&#10;&#9;&#9;&#9;c.JSON(http.StatusUnauthorized, rest.ErrorResponse{&#10;&#9;&#9;&#9;&#9;ApiError: rest.UnauthorizedError,&#10;&#9;&#9;&#9;&#9;Message:  &quot;Invalid token&quot;,&#10;&#9;&#9;&#9;})&#10;&#9;&#9;&#9;c.Abort()&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// Set user info in context for all services to use&#10;&#9;&#9;c.Set(&quot;user_id&quot;, claims.UserID)&#10;&#9;&#9;c.Set(&quot;email&quot;, claims.Email)&#10;&#9;&#9;c.Set(&quot;roles&quot;, claims.Roles)&#10;&#9;&#9;c.Set(&quot;permissions&quot;, claims.Permissions)&#10;&#10;&#9;&#9;c.Next()&#10;&#9;}&#10;}&#10;&#10;// RequirePermissions checks if user has ALL specified permissions&#10;func (m *SharedAuthMiddleware) RequirePermissions(requiredPermissions ...string) gin.HandlerFunc {&#10;&#9;return func(c *gin.Context) {&#10;&#9;&#9;permissions, exists := c.Get(&quot;permissions&quot;)&#10;&#9;&#9;if !exists {&#10;&#9;&#9;&#9;c.JSON(http.StatusUnauthorized, rest.ErrorResponse{&#10;&#9;&#9;&#9;&#9;ApiError: rest.UnauthorizedError,&#10;&#9;&#9;&#9;&#9;Message:  &quot;User not authenticated&quot;,&#10;&#9;&#9;&#9;})&#10;&#9;&#9;&#9;c.Abort()&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#10;&#9;&#9;userPermissions := permissions.([]string)&#10;&#9;&#9;userPermMap := make(map[string]bool)&#10;&#9;&#9;for _, perm := range userPermissions {&#10;&#9;&#9;&#9;userPermMap[perm] = true&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// Check if user has all required permissions&#10;&#9;&#9;for _, requiredPerm := range requiredPermissions {&#10;&#9;&#9;&#9;if !userPermMap[requiredPerm] {&#10;&#9;&#9;&#9;&#9;m.logger.Warn(&quot;Access denied - missing permission&quot;, &#10;&#9;&#9;&#9;&#9;&#9;&quot;user_id&quot;, c.Get(&quot;user_id&quot;), &#10;&#9;&#9;&#9;&#9;&#9;&quot;required_permission&quot;, requiredPerm)&#10;&#9;&#9;&#9;&#9;c.JSON(http.StatusForbidden, rest.ErrorResponse{&#10;&#9;&#9;&#9;&#9;&#9;ApiError: rest.ForbiddenError,&#10;&#9;&#9;&#9;&#9;&#9;Message:  &quot;Insufficient permissions&quot;,&#10;&#9;&#9;&#9;&#9;})&#10;&#9;&#9;&#9;&#9;c.Abort()&#10;&#9;&#9;&#9;&#9;return&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#10;&#9;&#9;c.Next()&#10;&#9;}&#10;}&#10;&#10;// RequireAnyPermission checks if user has ANY of the specified permissions&#10;func (m *SharedAuthMiddleware) RequireAnyPermission(permissions ...string) gin.HandlerFunc {&#10;&#9;return func(c *gin.Context) {&#10;&#9;&#9;userPermissions, exists := c.Get(&quot;permissions&quot;)&#10;&#9;&#9;if !exists {&#10;&#9;&#9;&#9;c.JSON(http.StatusUnauthorized, rest.ErrorResponse{&#10;&#9;&#9;&#9;&#9;ApiError: rest.UnauthorizedError,&#10;&#9;&#9;&#9;&#9;Message:  &quot;User not authenticated&quot;,&#10;&#9;&#9;&#9;})&#10;&#9;&#9;&#9;c.Abort()&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#10;&#9;&#9;userPerms := userPermissions.([]string)&#10;&#9;&#9;for _, userPerm := range userPerms {&#10;&#9;&#9;&#9;for _, requiredPerm := range permissions {&#10;&#9;&#9;&#9;&#9;if userPerm == requiredPerm {&#10;&#9;&#9;&#9;&#9;&#9;c.Next()&#10;&#9;&#9;&#9;&#9;&#9;return&#10;&#9;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#10;&#9;&#9;c.JSON(http.StatusForbidden, rest.ErrorResponse{&#10;&#9;&#9;&#9;ApiError: rest.ForbiddenError,&#10;&#9;&#9;&#9;Message:  &quot;Insufficient permissions&quot;,&#10;&#9;&#9;})&#10;&#9;&#9;c.Abort()&#10;&#9;}&#10;}&#10;&#10;// RequireRole checks if user has specific role&#10;func (m *SharedAuthMiddleware) RequireRole(role string) gin.HandlerFunc {&#10;&#9;return func(c *gin.Context) {&#10;&#9;&#9;roles, exists := c.Get(&quot;roles&quot;)&#10;&#9;&#9;if !exists {&#10;&#9;&#9;&#9;c.JSON(http.StatusUnauthorized, rest.ErrorResponse{&#10;&#9;&#9;&#9;&#9;ApiError: rest.UnauthorizedError,&#10;&#9;&#9;&#9;&#9;Message:  &quot;User not authenticated&quot;,&#10;&#9;&#9;&#9;})&#10;&#9;&#9;&#9;c.Abort()&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#10;&#9;&#9;userRoles := roles.([]string)&#10;&#9;&#9;for _, userRole := range userRoles {&#10;&#9;&#9;&#9;if userRole == role {&#10;&#9;&#9;&#9;&#9;c.Next()&#10;&#9;&#9;&#9;&#9;return&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#10;&#9;&#9;c.JSON(http.StatusForbidden, rest.ErrorResponse{&#10;&#9;&#9;&#9;ApiError: rest.ForbiddenError,&#10;&#9;&#9;&#9;Message:  &quot;Insufficient role permissions&quot;,&#10;&#9;&#9;})&#10;&#9;&#9;c.Abort()&#10;&#9;}&#10;}&#10;&#10;func (m *SharedAuthMiddleware) validateToken(tokenString string) (*JWTClaims, error) {&#10;&#9;token, err := jwt.ParseWithClaims(tokenString, &amp;JWTClaims{}, func(token *jwt.Token) (interface{}, error) {&#10;&#9;&#9;return []byte(m.jwtSecret), nil&#10;&#9;})&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;claims, ok := token.Claims.(*JWTClaims)&#10;&#9;if !ok {&#10;&#9;&#9;return nil, jwt.ErrTokenMalformed&#10;&#9;}&#10;&#10;&#9;now := time.Now()&#10;&#10;&#9;// Check if refresh token is expired (hard expiration)&#10;&#9;if !claims.RefreshExpiresAt.IsZero() &amp;&amp; now.After(claims.RefreshExpiresAt) {&#10;&#9;&#9;m.logger.Warn(&quot;Refresh token has expired&quot;, &quot;user_id&quot;, claims.UserID)&#10;&#9;&#9;return nil, jwt.NewValidationError(&quot;refresh token expired&quot;, jwt.ValidationErrorExpired)&#10;&#9;}&#10;&#10;&#9;// Check if access token is expired&#10;&#9;if claims.ExpiresAt != nil &amp;&amp; now.After(claims.ExpiresAt.Time) {&#10;&#9;&#9;m.logger.Info(&quot;Access token expired&quot;, &quot;user_id&quot;, claims.UserID)&#10;&#9;&#9;return nil, jwt.NewValidationError(&quot;access token expired&quot;, jwt.ValidationErrorExpired)&#10;&#9;}&#10;&#10;&#9;// Check not before&#10;&#9;if claims.NotBefore != nil &amp;&amp; now.Before(claims.NotBefore.Time) {&#10;&#9;&#9;return nil, jwt.NewValidationError(&quot;token used before valid&quot;, jwt.ValidationErrorNotValidYet)&#10;&#9;}&#10;&#10;&#9;// Check issued at&#10;&#9;if claims.IssuedAt != nil &amp;&amp; now.Before(claims.IssuedAt.Time) {&#10;&#9;&#9;return nil, jwt.NewValidationError(&quot;token issued in the future&quot;, jwt.ValidationErrorIssuedAt)&#10;&#9;}&#10;&#10;&#9;return claims, nil&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/internal/pkg/config/pg/pg.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/internal/pkg/config/pg/pg.go" />
              <option name="updatedContent" value="package pg&#10;&#10;import &quot;fmt&quot;&#10;&#10;// PG holds PostgreSQL database configuration&#10;type PG struct {&#10;&#9;Host            string `mapstructure:&quot;host&quot; env:&quot;PG_HOST&quot;`&#10;&#9;Port            string `mapstructure:&quot;port&quot; env:&quot;PG_PORT&quot;`&#10;&#9;User            string `mapstructure:&quot;user&quot; env:&quot;PG_USER&quot;`&#10;&#9;Password        string `mapstructure:&quot;password&quot; env:&quot;PG_PASSWORD&quot;`&#10;&#9;Database        string `mapstructure:&quot;database&quot; env:&quot;PG_DATABASE&quot;`&#10;&#9;SSLMode         string `mapstructure:&quot;ssl_mode&quot; env:&quot;PG_SSL_MODE&quot;`&#10;&#9;MaxOpenConns    int    `mapstructure:&quot;max_open_conns&quot; env:&quot;PG_MAX_OPEN_CONNS&quot;`&#10;&#9;MaxIdleConns    int    `mapstructure:&quot;max_idle_conns&quot; env:&quot;PG_MAX_IDLE_CONNS&quot;`&#10;&#9;ConnMaxLifetime int    `mapstructure:&quot;conn_max_lifetime&quot; env:&quot;PG_CONN_MAX_LIFETIME&quot;`&#10;&#9;ConnMaxIdleTime int    `mapstructure:&quot;conn_max_idle_time&quot; env:&quot;PG_CONN_MAX_IDLE_TIME&quot;`&#10;}&#10;&#10;// GetDSN returns the PostgreSQL connection string&#10;func (p *PG) GetDSN() string {&#10;&#9;return fmt.Sprintf(&quot;host=%s port=%s user=%s password=%s dbname=%s sslmode=%s&quot;,&#10;&#9;&#9;p.Host, p.Port, p.User, p.Password, p.Database, p.SSLMode)&#10;}&#10;&#10;// IsValid checks if all required PostgreSQL fields are set&#10;func (p *PG) IsValid() bool {&#10;&#9;return p.Host != &quot;&quot; &amp;&amp; p.Port != &quot;&quot; &amp;&amp; p.User != &quot;&quot; &amp;&amp; p.Database != &quot;&quot;&#10;}&#10;&#10;// SetDefaults sets default values for PostgreSQL configuration&#10;func (p *PG) SetDefaults() {&#10;&#9;if p.Host == &quot;&quot; {&#10;&#9;&#9;p.Host = &quot;localhost&quot;&#10;&#9;}&#10;&#9;if p.Port == &quot;&quot; {&#10;&#9;&#9;p.Port = &quot;5432&quot;&#10;&#9;}&#10;&#9;if p.SSLMode == &quot;&quot; {&#10;&#9;&#9;p.SSLMode = &quot;disable&quot;&#10;&#9;}&#10;&#9;if p.MaxOpenConns == 0 {&#10;&#9;&#9;p.MaxOpenConns = 25&#10;&#9;}&#10;&#9;if p.MaxIdleConns == 0 {&#10;&#9;&#9;p.MaxIdleConns = 10&#10;&#9;}&#10;&#9;if p.ConnMaxLifetime == 0 {&#10;&#9;&#9;p.ConnMaxLifetime = 300 // 5 minutes in seconds&#10;&#9;}&#10;&#9;if p.ConnMaxIdleTime == 0 {&#10;&#9;&#9;p.ConnMaxIdleTime = 60 // 1 minute in seconds&#10;&#9;}&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/internal/pkg/gateway/api_gateway.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/internal/pkg/gateway/api_gateway.go" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/internal/services/cart/internal/controller/cart_controller.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/internal/services/cart/internal/controller/cart_controller.go" />
              <option name="originalContent" value="package controller&#10;&#10;import (&#10;&#9;&quot;errors&quot;&#10;&#9;&quot;github.com/gin-gonic/gin&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/internal/pkg/logger&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/internal/pkg/rest&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/services/cart/internal&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/services/cart/internal/dto/request&quot;&#10;&#9;customErr &quot;github.com/hthinh24/go-store/services/cart/internal/errors&quot;&#10;&#9;&quot;net/http&quot;&#10;&#9;&quot;strconv&quot;&#10;)&#10;&#10;type CartController struct {&#10;&#9;logger      logger.Logger&#10;&#9;cartService internal.CartService&#10;}&#10;&#10;func NewCartController(logger logger.Logger, cartService internal.CartService) *CartController {&#10;&#9;return &amp;CartController{&#10;&#9;&#9;logger:      logger,&#10;&#9;&#9;cartService: cartService,&#10;&#9;}&#10;}&#10;&#10;func (c *CartController) GetCartItemsByUserID() func(c *gin.Context) {&#10;&#9;return func(ctx *gin.Context) {&#10;&#9;&#9;userID, err := c.getUserIDFromContext(ctx)&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;ctx.JSON(http.StatusUnauthorized, rest.NewErrorResponse(rest.UnauthorizedError, &quot;User not authenticated&quot;))&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#10;&#9;&#9;cartItems, err := c.cartService.FindCartItemsByCartID(userID)&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;c.handleCartError(ctx, err)&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#10;&#9;&#9;ctx.JSON(http.StatusOK, rest.NewAPIResponse(http.StatusOK, &quot;Get cart items by user id successfully&quot;, cartItems))&#10;&#9;}&#10;}&#10;&#10;func (c *CartController) AddItemToCart() func(c *gin.Context) {&#10;&#9;return func(ctx *gin.Context) {&#10;&#9;&#9;var item request.AddItemRequest&#10;&#9;&#9;if err := ctx.ShouldBindJSON(&amp;item); err != nil {&#10;&#9;&#9;&#9;ctx.JSON(http.StatusBadRequest, rest.NewErrorResponse(rest.BadRequestError, &quot;Invalid input&quot;))&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#10;&#9;&#9;userID, err := c.getUserIDFromContext(ctx)&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;ctx.JSON(http.StatusUnauthorized, rest.NewErrorResponse(rest.UnauthorizedError, err.Error()))&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#10;&#9;&#9;if err := c.cartService.AddItemToCart(userID, &amp;item); err != nil {&#10;&#9;&#9;&#9;c.handleCartError(ctx, err)&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#10;&#9;&#9;ctx.JSON(http.StatusCreated, rest.NewAPIResponse(http.StatusCreated, &quot;Item added to cart successfully&quot;, nil))&#10;&#9;}&#10;}&#10;&#10;func (c *CartController) UpdateItemQuantity() func(c *gin.Context) {&#10;&#9;return func(ctx *gin.Context) {&#10;&#9;&#9;var item request.UpdateItemQuantityRequest&#10;&#9;&#9;if err := ctx.ShouldBindJSON(&amp;item); err != nil {&#10;&#9;&#9;&#9;ctx.JSON(http.StatusBadRequest, rest.NewErrorResponse(rest.BadRequestError, &quot;Invalid input&quot;))&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#10;&#9;&#9;userID, err := c.getUserIDFromContext(ctx)&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;ctx.JSON(http.StatusUnauthorized, rest.NewErrorResponse(rest.UnauthorizedError, err.Error()))&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#10;&#9;&#9;if err := c.cartService.UpdateItemQuantity(userID, item.ItemID, item.Quantity); err != nil {&#10;&#9;&#9;&#9;c.handleCartError(ctx, err)&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#10;&#9;&#9;ctx.JSON(http.StatusOK, rest.NewAPIResponse(http.StatusOK, &quot;Item quantity updated successfully&quot;, nil))&#10;&#9;}&#10;}&#10;&#10;func (c *CartController) RemoveItemFromCart() func(c *gin.Context) {&#10;&#9;return func(ctx *gin.Context) {&#10;&#9;&#9;itemID := ctx.Param(&quot;item_id&quot;)&#10;&#9;&#9;itemIDInt, err := strconv.Atoi(itemID)&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;ctx.JSON(http.StatusBadRequest, rest.NewErrorResponse(rest.BadRequestError, &quot;Invalid item ID format&quot;))&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#10;&#9;&#9;userID, err := c.getUserIDFromContext(ctx)&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;ctx.JSON(http.StatusUnauthorized, rest.NewErrorResponse(rest.UnauthorizedError, err.Error()))&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#10;&#9;&#9;if err := c.cartService.RemoveItemFromCart(userID, int64(itemIDInt)); err != nil {&#10;&#9;&#9;&#9;c.handleCartError(ctx, err)&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#10;&#9;&#9;ctx.JSON(http.StatusOK, rest.NewAPIResponse(http.StatusOK, &quot;Item removed from cart successfully&quot;, nil))&#10;&#9;}&#10;}&#10;&#10;func (c *CartController) getUserIDFromContext(ctx *gin.Context) (int64, error) {&#10;&#9;userID, exists := ctx.Get(&quot;user_id&quot;)&#10;&#9;if !exists {&#10;&#9;&#9;return 0, errors.New(&quot;user ID not found in context&quot;)&#10;&#9;}&#10;&#10;&#9;userIDInt64, ok := userID.(int64)&#10;&#9;if !ok {&#10;&#9;&#9;return 0, errors.New(&quot;invalid user ID type&quot;)&#10;&#9;}&#10;&#10;&#9;return userIDInt64, nil&#10;}&#10;&#10;func (c *CartController) handleCartError(ctx *gin.Context, err error) {&#10;&#9;switch {&#10;&#9;case errors.Is(err, customErr.ErrCartNotFound):&#10;&#9;&#9;ctx.JSON(http.StatusNotFound, rest.NewErrorResponse(rest.NotFoundError, err.Error()))&#10;&#9;case errors.Is(err, customErr.ErrCartItemNotFound):&#10;&#9;&#9;ctx.JSON(http.StatusNotFound, rest.NewErrorResponse(rest.NotFoundError, err.Error()))&#10;&#9;case errors.Is(err, customErr.ErrCartItemAlreadyExists):&#10;&#9;&#9;ctx.JSON(http.StatusConflict, rest.NewErrorResponse(rest.ConflictError, err.Error()))&#10;&#9;default:&#10;&#9;&#9;ctx.JSON(http.StatusInternalServerError, rest.NewErrorResponse(rest.InternalServerErrorError, &quot;An unexpected error occurred&quot;))&#10;&#9;}&#10;}&#10;" />
              <option name="updatedContent" value="package controller&#13;&#10;&#13;&#10;import (&#13;&#10;&#9;&quot;errors&quot;&#13;&#10;&#9;&quot;github.com/gin-gonic/gin&quot;&#13;&#10;&#9;&quot;github.com/hthinh24/go-store/internal/pkg/logger&quot;&#13;&#10;&#9;&quot;github.com/hthinh24/go-store/internal/pkg/rest&quot;&#13;&#10;&#9;&quot;github.com/hthinh24/go-store/services/cart/internal&quot;&#13;&#10;&#9;&quot;github.com/hthinh24/go-store/services/cart/internal/dto/request&quot;&#13;&#10;&#9;customErr &quot;github.com/hthinh24/go-store/services/cart/internal/errors&quot;&#13;&#10;&#9;&quot;net/http&quot;&#13;&#10;&#9;&quot;strconv&quot;&#13;&#10;)&#13;&#10;&#13;&#10;type CartController struct {&#13;&#10;&#9;logger      logger.Logger&#13;&#10;&#9;cartService internal.CartService&#13;&#10;}&#13;&#10;&#13;&#10;func NewCartController(logger logger.Logger, cartService internal.CartService) *CartController {&#13;&#10;&#9;return &amp;CartController{&#13;&#10;&#9;&#9;logger:      logger,&#13;&#10;&#9;&#9;cartService: cartService,&#13;&#10;&#9;}&#13;&#10;}&#13;&#10;&#13;&#10;func (c *CartController) CreateCart() func(c *gin.Context) {&#13;&#10;&#9;return func(ctx *gin.Context) {&#13;&#10;&#9;&#9;var createCartRequest request.CreateCartRequest&#13;&#10;&#9;&#9;if err := ctx.ShouldBindJSON(&amp;createCartRequest); err != nil {&#13;&#10;&#9;&#9;&#9;c.logger.Error(&quot;Invalid create cart request&quot;, &quot;error&quot;, err)&#13;&#10;&#9;&#9;&#9;ctx.JSON(http.StatusBadRequest, rest.NewErrorResponse(rest.BadRequestError, &quot;Invalid input&quot;))&#13;&#10;&#9;&#9;&#9;return&#13;&#10;&#9;&#9;}&#13;&#10;&#13;&#10;&#9;&#9;cart, err := c.cartService.CreateCart(&amp;createCartRequest)&#13;&#10;&#9;&#9;if err != nil {&#13;&#10;&#9;&#9;&#9;c.handleCartError(ctx, err)&#13;&#10;&#9;&#9;&#9;return&#13;&#10;&#9;&#9;}&#13;&#10;&#13;&#10;&#9;&#9;ctx.JSON(http.StatusCreated, rest.NewAPIResponse(http.StatusCreated, &quot;Cart created successfully&quot;, cart))&#13;&#10;&#9;}&#13;&#10;}&#13;&#10;&#13;&#10;func (c *CartController) GetCartItemsByUserID() func(c *gin.Context) {&#13;&#10;&#9;return func(ctx *gin.Context) {&#13;&#10;&#9;&#9;userID, err := c.getUserIDFromContext(ctx)&#13;&#10;&#9;&#9;if err != nil {&#13;&#10;&#9;&#9;&#9;ctx.JSON(http.StatusUnauthorized, rest.NewErrorResponse(rest.UnauthorizedError, &quot;User not authenticated&quot;))&#13;&#10;&#9;&#9;&#9;return&#13;&#10;&#9;&#9;}&#13;&#10;&#13;&#10;&#9;&#9;cartItems, err := c.cartService.FindCartItemsByCartID(userID)&#13;&#10;&#9;&#9;if err != nil {&#13;&#10;&#9;&#9;&#9;c.handleCartError(ctx, err)&#13;&#10;&#9;&#9;&#9;return&#13;&#10;&#9;&#9;}&#13;&#10;&#13;&#10;&#9;&#9;ctx.JSON(http.StatusOK, rest.NewAPIResponse(http.StatusOK, &quot;Get cart items by user id successfully&quot;, cartItems))&#13;&#10;&#9;}&#13;&#10;}&#13;&#10;&#13;&#10;func (c *CartController) AddItemToCart() func(c *gin.Context) {&#13;&#10;&#9;return func(ctx *gin.Context) {&#13;&#10;&#9;&#9;var item request.AddItemRequest&#13;&#10;&#9;&#9;if err := ctx.ShouldBindJSON(&amp;item); err != nil {&#13;&#10;&#9;&#9;&#9;ctx.JSON(http.StatusBadRequest, rest.NewErrorResponse(rest.BadRequestError, &quot;Invalid input&quot;))&#13;&#10;&#9;&#9;&#9;return&#13;&#10;&#9;&#9;}&#13;&#10;&#13;&#10;&#9;&#9;userID, err := c.getUserIDFromContext(ctx)&#13;&#10;&#9;&#9;if err != nil {&#13;&#10;&#9;&#9;&#9;ctx.JSON(http.StatusUnauthorized, rest.NewErrorResponse(rest.UnauthorizedError, err.Error()))&#13;&#10;&#9;&#9;&#9;return&#13;&#10;&#9;&#9;}&#13;&#10;&#13;&#10;&#9;&#9;if err := c.cartService.AddItemToCart(userID, &amp;item); err != nil {&#13;&#10;&#9;&#9;&#9;c.handleCartError(ctx, err)&#13;&#10;&#9;&#9;&#9;return&#13;&#10;&#9;&#9;}&#13;&#10;&#13;&#10;&#9;&#9;ctx.JSON(http.StatusCreated, rest.NewAPIResponse(http.StatusCreated, &quot;Item added to cart successfully&quot;, nil))&#13;&#10;&#9;}&#13;&#10;}&#13;&#10;&#13;&#10;func (c *CartController) UpdateItemQuantity() func(c *gin.Context) {&#13;&#10;&#9;return func(ctx *gin.Context) {&#13;&#10;&#9;&#9;var item request.UpdateItemQuantityRequest&#13;&#10;&#9;&#9;if err := ctx.ShouldBindJSON(&amp;item); err != nil {&#13;&#10;&#9;&#9;&#9;ctx.JSON(http.StatusBadRequest, rest.NewErrorResponse(rest.BadRequestError, &quot;Invalid input&quot;))&#13;&#10;&#9;&#9;&#9;return&#13;&#10;&#9;&#9;}&#13;&#10;&#13;&#10;&#9;&#9;userID, err := c.getUserIDFromContext(ctx)&#13;&#10;&#9;&#9;if err != nil {&#13;&#10;&#9;&#9;&#9;ctx.JSON(http.StatusUnauthorized, rest.NewErrorResponse(rest.UnauthorizedError, err.Error()))&#13;&#10;&#9;&#9;&#9;return&#13;&#10;&#9;&#9;}&#13;&#10;&#13;&#10;&#9;&#9;if err := c.cartService.UpdateItemQuantity(userID, item.ItemID, item.Quantity); err != nil {&#13;&#10;&#9;&#9;&#9;c.handleCartError(ctx, err)&#13;&#10;&#9;&#9;&#9;return&#13;&#10;&#9;&#9;}&#13;&#10;&#13;&#10;&#9;&#9;ctx.JSON(http.StatusOK, rest.NewAPIResponse(http.StatusOK, &quot;Item quantity updated successfully&quot;, nil))&#13;&#10;&#9;}&#13;&#10;}&#13;&#10;&#13;&#10;func (c *CartController) RemoveItemFromCart() func(c *gin.Context) {&#13;&#10;&#9;return func(ctx *gin.Context) {&#13;&#10;&#9;&#9;itemID := ctx.Param(&quot;item_id&quot;)&#13;&#10;&#9;&#9;itemIDInt, err := strconv.Atoi(itemID)&#13;&#10;&#9;&#9;if err != nil {&#13;&#10;&#9;&#9;&#9;ctx.JSON(http.StatusBadRequest, rest.NewErrorResponse(rest.BadRequestError, &quot;Invalid item ID format&quot;))&#13;&#10;&#9;&#9;&#9;return&#13;&#10;&#9;&#9;}&#13;&#10;&#13;&#10;&#9;&#9;userID, err := c.getUserIDFromContext(ctx)&#13;&#10;&#9;&#9;if err != nil {&#13;&#10;&#9;&#9;&#9;ctx.JSON(http.StatusUnauthorized, rest.NewErrorResponse(rest.UnauthorizedError, err.Error()))&#13;&#10;&#9;&#9;&#9;return&#13;&#10;&#9;&#9;}&#13;&#10;&#13;&#10;&#9;&#9;if err := c.cartService.RemoveItemFromCart(userID, int64(itemIDInt)); err != nil {&#13;&#10;&#9;&#9;&#9;c.handleCartError(ctx, err)&#13;&#10;&#9;&#9;&#9;return&#13;&#10;&#9;&#9;}&#13;&#10;&#13;&#10;&#9;&#9;ctx.JSON(http.StatusOK, rest.NewAPIResponse(http.StatusOK, &quot;Item removed from cart successfully&quot;, nil))&#13;&#10;&#9;}&#13;&#10;}&#13;&#10;&#13;&#10;func (c *CartController) getUserIDFromContext(ctx *gin.Context) (int64, error) {&#13;&#10;&#9;userID, exists := ctx.Get(&quot;user_id&quot;)&#13;&#10;&#9;if !exists {&#13;&#10;&#9;&#9;return 0, errors.New(&quot;user ID not found in context&quot;)&#13;&#10;&#9;}&#13;&#10;&#13;&#10;&#9;userIDInt64, ok := userID.(int64)&#13;&#10;&#9;if !ok {&#13;&#10;&#9;&#9;return 0, errors.New(&quot;invalid user ID type&quot;)&#13;&#10;&#9;}&#13;&#10;&#13;&#10;&#9;return userIDInt64, nil&#13;&#10;}&#13;&#10;&#13;&#10;func (c *CartController) handleCartError(ctx *gin.Context, err error) {&#13;&#10;&#9;switch {&#13;&#10;&#9;case errors.Is(err, customErr.ErrCartNotFound):&#13;&#10;&#9;&#9;ctx.JSON(http.StatusNotFound, rest.NewErrorResponse(rest.NotFoundError, err.Error()))&#13;&#10;&#9;case errors.Is(err, customErr.ErrCartItemNotFound):&#13;&#10;&#9;&#9;ctx.JSON(http.StatusNotFound, rest.NewErrorResponse(rest.NotFoundError, err.Error()))&#13;&#10;&#9;case errors.Is(err, customErr.ErrCartItemAlreadyExists):&#13;&#10;&#9;&#9;ctx.JSON(http.StatusConflict, rest.NewErrorResponse(rest.ConflictError, err.Error()))&#13;&#10;&#9;default:&#13;&#10;&#9;&#9;ctx.JSON(http.StatusInternalServerError, rest.NewErrorResponse(rest.InternalServerErrorError, &quot;An unexpected error occurred&quot;))&#13;&#10;&#9;}&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/internal/services/identity/internal/client/cart_client.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/internal/services/identity/internal/client/cart_client.go" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/internal/services/identity/internal/dto/request/refresh_token_request.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/internal/services/identity/internal/dto/request/refresh_token_request.go" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/internal/services/inventory/db/schema.sql">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/internal/services/inventory/db/schema.sql" />
              <option name="originalContent" value="-- Inventory Service Database Schema&#10;&#10;CREATE TABLE inventory (&#10;    id                BIGSERIAL    NOT NULL,&#10;    product_sku_id    int8         NOT NULL UNIQUE, -- References product service's product_sku&#10;    available_stock   int4         NOT NULL DEFAULT 0,&#10;    reserved_stock    int4         NOT NULL DEFAULT 0,&#10;    total_stock       int4         NOT NULL GENERATED ALWAYS AS (available_stock + reserved_stock) STORED,&#10;    reorder_level     int4         NOT NULL DEFAULT 10, -- Minimum stock level before reorder&#10;    max_stock_level   int4,        -- Maximum stock capacity&#10;    warehouse_location varchar(255),&#10;    last_updated_by   varchar(255) NOT NULL,&#10;    created_by        varchar(255) NOT NULL,&#10;    updated_by        varchar(255) NOT NULL,&#10;    created_at        timestamp    NOT NULL DEFAULT CURRENT_TIMESTAMP,&#10;    updated_at        timestamp    NOT NULL DEFAULT CURRENT_TIMESTAMP,&#10;    version           int          NOT NULL DEFAULT 1,&#10;    PRIMARY KEY (id)&#10;);&#10;&#10;CREATE TABLE inventory_movements (&#10;    id              BIGSERIAL    NOT NULL,&#10;    inventory_id    int8         NOT NULL,&#10;    movement_type   varchar(50)  NOT NULL, -- IN, OUT, RESERVED, RELEASED, ADJUSTMENT&#10;    quantity        int4         NOT NULL,&#10;    reference_type  varchar(50)  NOT NULL, -- ORDER, PURCHASE, RETURN, ADJUSTMENT, MANUAL&#10;    reference_id    int8,&#10;    reason          varchar(500),&#10;    previous_stock  int4         NOT NULL,&#10;    new_stock       int4         NOT NULL,&#10;    created_by      varchar(255) NOT NULL,&#10;    updated_by      varchar(255) NOT NULL,&#10;    created_at      timestamp    NOT NULL DEFAULT CURRENT_TIMESTAMP,&#10;    updated_at      timestamp    NOT NULL DEFAULT CURRENT_TIMESTAMP,&#10;    version         int          NOT NULL DEFAULT 1,&#10;    PRIMARY KEY (id)&#10;);&#10;&#10;CREATE TABLE stock_reservations (&#10;    id               BIGSERIAL    NOT NULL,&#10;    inventory_id     int8         NOT NULL,&#10;    reference_type   varchar(50)  NOT NULL, -- ORDER, CART&#10;    reference_id     int8         NOT NULL, -- order_id or cart_id&#10;    reserved_quantity int4        NOT NULL,&#10;    expiry_time      timestamp    NOT NULL, -- When reservation expires&#10;    status           varchar(50)  NOT NULL DEFAULT 'ACTIVE', -- ACTIVE, EXPIRED, CONFIRMED, CANCELLED&#10;    created_by       varchar(255) NOT NULL,&#10;    updated_by       varchar(255) NOT NULL,&#10;    created_at       timestamp    NOT NULL DEFAULT CURRENT_TIMESTAMP,&#10;    updated_at       timestamp    NOT NULL DEFAULT CURRENT_TIMESTAMP,&#10;    version          int          NOT NULL DEFAULT 1,&#10;    PRIMARY KEY (id)&#10;);&#10;&#10;-- Add constraints&#10;ALTER TABLE inventory&#10;    ADD CONSTRAINT CHK_inventory_available_stock CHECK (available_stock &gt;= 0),&#10;    ADD CONSTRAINT CHK_inventory_reserved_stock CHECK (reserved_stock &gt;= 0),&#10;    ADD CONSTRAINT CHK_inventory_reorder_level CHECK (reorder_level &gt;= 0),&#10;    ADD CONSTRAINT CHK_inventory_max_stock CHECK (max_stock_level IS NULL OR max_stock_level &gt;= 0);&#10;&#10;ALTER TABLE inventory_movements&#10;    ADD CONSTRAINT CHK_movements_quantity CHECK (quantity != 0),&#10;    ADD CONSTRAINT CHK_movements_previous_stock CHECK (previous_stock &gt;= 0),&#10;    ADD CONSTRAINT CHK_movements_new_stock CHECK (new_stock &gt;= 0);&#10;&#10;ALTER TABLE stock_reservations&#10;    ADD CONSTRAINT CHK_reservations_quantity CHECK (reserved_quantity &gt; 0),&#10;    ADD CONSTRAINT CHK_reservations_expiry CHECK (expiry_time &gt; created_at);&#10;&#10;-- Add foreign key constraints&#10;ALTER TABLE inventory_movements&#10;    ADD CONSTRAINT FK_movements_inventory FOREIGN KEY (inventory_id) REFERENCES inventory (id) ON DELETE CASCADE;&#10;&#10;ALTER TABLE stock_reservations&#10;    ADD CONSTRAINT FK_reservations_inventory FOREIGN KEY (inventory_id) REFERENCES inventory (id) ON DELETE CASCADE;&#10;" />
              <option name="updatedContent" value="-- Inventory Service Database Schema&#10;&#10;CREATE TABLE inventory (&#10;    id                BIGSERIAL    NOT NULL,&#10;    product_sku_id    int8         NOT NULL UNIQUE, -- References product service's product_sku&#10;    available_stock   int4         NOT NULL DEFAULT 0,&#10;    reserved_stock    int4         NOT NULL DEFAULT 0,&#10;    total_stock       int4         NOT NULL GENERATED ALWAYS AS (available_stock + reserved_stock) STORED,&#10;    reorder_level     int4         NOT NULL DEFAULT 10, -- Minimum stock level before reorder&#10;    max_stock_level   int4,        -- Maximum stock capacity&#10;    warehouse_location varchar(255),&#10;    last_updated_by   varchar(255) NOT NULL,&#10;    created_by        varchar(255) NOT NULL,&#10;    updated_by        varchar(255) NOT NULL,&#10;    created_at        timestamp    NOT NULL DEFAULT CURRENT_TIMESTAMP,&#10;    updated_at        timestamp    NOT NULL DEFAULT CURRENT_TIMESTAMP,&#10;    version           int          NOT NULL DEFAULT 1,&#10;    PRIMARY KEY (id)&#10;);&#10;&#10;CREATE TABLE inventory_movements (&#10;    id              BIGSERIAL    NOT NULL,&#10;    inventory_id    int8         NOT NULL,&#10;    movement_type   varchar(50)  NOT NULL, -- IN, OUT, RESERVED, RELEASED, ADJUSTMENT&#10;    quantity        int4         NOT NULL,&#10;    reference_type  varchar(50)  NOT NULL, -- ORDER, PURCHASE, RETURN, ADJUSTMENT, MANUAL&#10;    reference_id    int8,&#10;    reason          varchar(500),&#10;    previous_stock  int4         NOT NULL,&#10;    new_stock       int4         NOT NULL,&#10;    created_by      varchar(255) NOT NULL,&#10;    updated_by      varchar(255) NOT NULL,&#10;    created_at      timestamp    NOT NULL DEFAULT CURRENT_TIMESTAMP,&#10;    updated_at      timestamp    NOT NULL DEFAULT CURRENT_TIMESTAMP,&#10;    version         int          NOT NULL DEFAULT 1,&#10;    PRIMARY KEY (id)&#10;);&#10;&#10;CREATE TABLE stock_reservations (&#10;    id               BIGSERIAL    NOT NULL,&#10;    inventory_id     int8         NOT NULL,&#10;    reference_type   varchar(50)  NOT NULL, -- CHECKOUT, ORDER&#10;    reference_id     int8         NOT NULL, -- checkout_session_id or order_id&#10;    reserved_quantity int4        NOT NULL,&#10;    expiry_time      timestamp    NOT NULL, -- When reservation expires (e.g., 15 minutes for checkout)&#10;    status           varchar(50)  NOT NULL DEFAULT 'ACTIVE', -- ACTIVE, EXPIRED, CONFIRMED, CANCELLED&#10;    created_by       varchar(255) NOT NULL,&#10;    updated_by       varchar(255) NOT NULL,&#10;    created_at       timestamp    NOT NULL DEFAULT CURRENT_TIMESTAMP,&#10;    updated_at       timestamp    NOT NULL DEFAULT CURRENT_TIMESTAMP,&#10;    version          int          NOT NULL DEFAULT 1,&#10;    PRIMARY KEY (id)&#10;);&#10;&#10;-- Add constraints&#10;ALTER TABLE inventory&#10;    ADD CONSTRAINT CHK_inventory_available_stock CHECK (available_stock &gt;= 0),&#10;    ADD CONSTRAINT CHK_inventory_reserved_stock CHECK (reserved_stock &gt;= 0),&#10;    ADD CONSTRAINT CHK_inventory_reorder_level CHECK (reorder_level &gt;= 0),&#10;    ADD CONSTRAINT CHK_inventory_max_stock CHECK (max_stock_level IS NULL OR max_stock_level &gt;= 0);&#10;&#10;ALTER TABLE inventory_movements&#10;    ADD CONSTRAINT CHK_movements_quantity CHECK (quantity != 0),&#10;    ADD CONSTRAINT CHK_movements_previous_stock CHECK (previous_stock &gt;= 0),&#10;    ADD CONSTRAINT CHK_movements_new_stock CHECK (new_stock &gt;= 0);&#10;&#10;ALTER TABLE stock_reservations&#10;    ADD CONSTRAINT CHK_reservations_quantity CHECK (reserved_quantity &gt; 0),&#10;    ADD CONSTRAINT CHK_reservations_expiry CHECK (expiry_time &gt; created_at);&#10;&#10;-- Add foreign key constraints&#10;ALTER TABLE inventory_movements&#10;    ADD CONSTRAINT FK_movements_inventory FOREIGN KEY (inventory_id) REFERENCES inventory (id) ON DELETE CASCADE;&#10;&#10;ALTER TABLE stock_reservations&#10;    ADD CONSTRAINT FK_reservations_inventory FOREIGN KEY (inventory_id) REFERENCES inventory (id) ON DELETE CASCADE;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/internal/services/order/db/schema.sql">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/internal/services/order/db/schema.sql" />
              <option name="originalContent" value="-- Order Service Database Schema&#10;&#10;CREATE TABLE orders (&#10;    id              BIGSERIAL      NOT NULL,&#10;    user_id         int8           NOT NULL,&#10;    status          varchar(50)    NOT NULL DEFAULT 'PENDING', -- PENDING, PROCESSING, SHIPPING, SHIPPED, DELIVERED, CANCELLED, REFUNDED&#10;    total_amount    DECIMAL(12, 2) NOT NULL DEFAULT 0.00,&#10;    shipping_fee    DECIMAL(10, 2) NOT NULL DEFAULT 0.00,&#10;    tax_amount      DECIMAL(10, 2) NOT NULL DEFAULT 0.00,&#10;    discount_amount DECIMAL(10, 2) NOT NULL DEFAULT 0.00,&#10;    final_amount    DECIMAL(12, 2) NOT NULL GENERATED ALWAYS AS (total_amount + shipping_fee + tax_amount - discount_amount) STORED,&#10;    payment_status  varchar(50)    NOT NULL DEFAULT 'PENDING', -- PENDING, PAID, FAILED, REFUNDED&#10;    shipping_status varchar(50)    NOT NULL DEFAULT 'PENDING', -- PENDING, PROCESSING, SHIPPED, DELIVERED&#10;    notes           text,&#10;    created_by      varchar(255)   NOT NULL,&#10;    updated_by      varchar(255)   NOT NULL,&#10;    created_at      timestamp      NOT NULL DEFAULT CURRENT_TIMESTAMP,&#10;    updated_at      timestamp      NOT NULL DEFAULT CURRENT_TIMESTAMP,&#10;    version         int            NOT NULL DEFAULT 1,&#10;    PRIMARY KEY (id)&#10;);&#10;&#10;CREATE TABLE order_items (&#10;    id             BIGSERIAL      NOT NULL,&#10;    order_id       int8           NOT NULL,&#10;    product_id     int8           NOT NULL,&#10;    product_sku_id int8           NOT NULL,&#10;    product_name   varchar(255)   NOT NULL, -- Snapshot at order time&#10;    sku            varchar(255)   NOT NULL, -- Snapshot at order time&#10;    quantity       int4           NOT NULL,&#10;    unit_price     DECIMAL(10, 2) NOT NULL, -- Price at order time&#10;    total_price    DECIMAL(10, 2) NOT NULL GENERATED ALWAYS AS (quantity * unit_price) STORED,&#10;    created_by     varchar(255)   NOT NULL,&#10;    updated_by     varchar(255)   NOT NULL,&#10;    created_at     timestamp      NOT NULL DEFAULT CURRENT_TIMESTAMP,&#10;    updated_at     timestamp      NOT NULL DEFAULT CURRENT_TIMESTAMP,&#10;    version        int            NOT NULL DEFAULT 1,&#10;    PRIMARY KEY (id)&#10;);&#10;&#10;CREATE TABLE order_addresses (&#10;    id           BIGSERIAL    NOT NULL,&#10;    order_id     int8         NOT NULL,&#10;    full_name    varchar(255) NOT NULL,&#10;    phone        varchar(20)  NOT NULL,&#10;    email        varchar(255),&#10;    address_line varchar(500) NOT NULL,&#10;    city         varchar(100) NOT NULL,&#10;    state        varchar(100) NOT NULL,&#10;    postal_code  varchar(20)  NOT NULL,&#10;    country      varchar(100) NOT NULL DEFAULT 'VietNam',&#10;    created_by   varchar(255) NOT NULL,&#10;    updated_by   varchar(255) NOT NULL,&#10;    created_at   timestamp    NOT NULL DEFAULT CURRENT_TIMESTAMP,&#10;    updated_at   timestamp    NOT NULL DEFAULT CURRENT_TIMESTAMP,&#10;    version      int          NOT NULL DEFAULT 1,&#10;    PRIMARY KEY (id)&#10;);&#10;&#10;-- Add constraints&#10;ALTER TABLE orders&#10;    ADD CONSTRAINT CHK_orders_total_amount CHECK (total_amount &gt;= 0),&#10;    ADD CONSTRAINT CHK_orders_shipping_fee CHECK (shipping_fee &gt;= 0),&#10;    ADD CONSTRAINT CHK_orders_tax_amount CHECK (tax_amount &gt;= 0),&#10;    ADD CONSTRAINT CHK_orders_discount_amount CHECK (discount_amount &gt;= 0),&#10;    ADD CONSTRAINT CHK_orders_final_amount CHECK (final_amount &gt;= 0);&#10;&#10;ALTER TABLE order_items&#10;    ADD CONSTRAINT CHK_order_items_quantity CHECK (quantity &gt; 0),&#10;    ADD CONSTRAINT CHK_order_items_unit_price CHECK (unit_price &gt;= 0),&#10;    ADD CONSTRAINT CHK_order_items_total_price CHECK (total_price &gt;= 0);&#10;&#10;-- Add foreign key constraints&#10;ALTER TABLE order_items&#10;    ADD CONSTRAINT FK_order_items_order FOREIGN KEY (order_id) REFERENCES orders (id) ON DELETE CASCADE;&#10;&#10;ALTER TABLE order_addresses&#10;    ADD CONSTRAINT FK_order_addresses_order FOREIGN KEY (order_id) REFERENCES orders (id) ON DELETE CASCADE;&#10;" />
              <option name="updatedContent" value="-- Order Service Database Schema&#10;&#10;CREATE TABLE orders (&#10;    id              BIGSERIAL      NOT NULL,&#10;    request_id      varchar(255)   NOT NULL UNIQUE, -- Idempotency key from gateway&#10;    user_id         int8           NOT NULL,&#10;    order_number    varchar(50)    NOT NULL UNIQUE,&#10;    status          varchar(50)    NOT NULL DEFAULT 'PENDING', -- PENDING, PROCESSING, SHIPPING, SHIPPED, DELIVERED, CANCELLED, REFUNDED&#10;    total_amount    DECIMAL(12, 2) NOT NULL DEFAULT 0.00,&#10;    shipping_fee    DECIMAL(10, 2) NOT NULL DEFAULT 0.00,&#10;    tax_amount      DECIMAL(10, 2) NOT NULL DEFAULT 0.00,&#10;    discount_amount DECIMAL(10, 2) NOT NULL DEFAULT 0.00,&#10;    final_amount    DECIMAL(12, 2) NOT NULL GENERATED ALWAYS AS (total_amount + shipping_fee + tax_amount - discount_amount) STORED,&#10;    payment_status  varchar(50)    NOT NULL DEFAULT 'PENDING', -- PENDING, PAID, FAILED, REFUNDED&#10;    shipping_status varchar(50)    NOT NULL DEFAULT 'PENDING', -- PENDING, PROCESSING, SHIPPED, DELIVERED&#10;    notes           text,&#10;    created_by      varchar(255)   NOT NULL,&#10;    updated_by      varchar(255)   NOT NULL,&#10;    created_at      timestamp      NOT NULL DEFAULT CURRENT_TIMESTAMP,&#10;    updated_at      timestamp      NOT NULL DEFAULT CURRENT_TIMESTAMP,&#10;    version         int            NOT NULL DEFAULT 1,&#10;    PRIMARY KEY (id)&#10;);&#10;&#10;CREATE TABLE order_items (&#10;    id             BIGSERIAL      NOT NULL,&#10;    order_id       int8           NOT NULL,&#10;    product_id     int8           NOT NULL,&#10;    product_sku_id int8           NOT NULL,&#10;    product_name   varchar(255)   NOT NULL, -- Snapshot at order time&#10;    sku            varchar(255)   NOT NULL, -- Snapshot at order time&#10;    quantity       int4           NOT NULL,&#10;    unit_price     DECIMAL(10, 2) NOT NULL, -- Price at order time&#10;    total_price    DECIMAL(10, 2) NOT NULL GENERATED ALWAYS AS (quantity * unit_price) STORED,&#10;    created_by     varchar(255)   NOT NULL,&#10;    updated_by     varchar(255)   NOT NULL,&#10;    created_at     timestamp      NOT NULL DEFAULT CURRENT_TIMESTAMP,&#10;    updated_at     timestamp      NOT NULL DEFAULT CURRENT_TIMESTAMP,&#10;    version        int            NOT NULL DEFAULT 1,&#10;    PRIMARY KEY (id)&#10;);&#10;&#10;CREATE TABLE order_addresses (&#10;    id           BIGSERIAL    NOT NULL,&#10;    order_id     int8         NOT NULL,&#10;    full_name    varchar(255) NOT NULL,&#10;    phone        varchar(20)  NOT NULL,&#10;    email        varchar(255),&#10;    address_line varchar(500) NOT NULL,&#10;    city         varchar(100) NOT NULL,&#10;    state        varchar(100) NOT NULL,&#10;    postal_code  varchar(20)  NOT NULL,&#10;    country      varchar(100) NOT NULL DEFAULT 'VietNam',&#10;    created_by   varchar(255) NOT NULL,&#10;    updated_by   varchar(255) NOT NULL,&#10;    created_at   timestamp    NOT NULL DEFAULT CURRENT_TIMESTAMP,&#10;    updated_at   timestamp    NOT NULL DEFAULT CURRENT_TIMESTAMP,&#10;    version      int          NOT NULL DEFAULT 1,&#10;    PRIMARY KEY (id)&#10;);&#10;&#10;-- Add constraints&#10;ALTER TABLE orders&#10;    ADD CONSTRAINT CHK_orders_total_amount CHECK (total_amount &gt;= 0),&#10;    ADD CONSTRAINT CHK_orders_shipping_fee CHECK (shipping_fee &gt;= 0),&#10;    ADD CONSTRAINT CHK_orders_tax_amount CHECK (tax_amount &gt;= 0),&#10;    ADD CONSTRAINT CHK_orders_discount_amount CHECK (discount_amount &gt;= 0),&#10;    ADD CONSTRAINT CHK_orders_final_amount CHECK (final_amount &gt;= 0);&#10;&#10;ALTER TABLE order_items&#10;    ADD CONSTRAINT CHK_order_items_quantity CHECK (quantity &gt; 0),&#10;    ADD CONSTRAINT CHK_order_items_unit_price CHECK (unit_price &gt;= 0),&#10;    ADD CONSTRAINT CHK_order_items_total_price CHECK (total_price &gt;= 0);&#10;&#10;-- Add foreign key constraints&#10;ALTER TABLE order_items&#10;    ADD CONSTRAINT FK_order_items_order FOREIGN KEY (order_id) REFERENCES orders (id) ON DELETE CASCADE;&#10;&#10;ALTER TABLE order_addresses&#10;    ADD CONSTRAINT FK_order_addresses_order FOREIGN KEY (order_id) REFERENCES orders (id) ON DELETE CASCADE;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/internal/services/payment/db/schema.sql">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/internal/services/payment/db/schema.sql" />
              <option name="originalContent" value="-- Payment Service Database Schema&#10;&#10;CREATE TABLE payments&#10;(&#10;    id               BIGSERIAL      NOT NULL,&#10;    order_id         int8           NOT NULL,&#10;    user_id          int8           NOT NULL,&#10;    payment_method   varchar(50)    NOT NULL,                   -- CREDIT_CARD, DEBIT_CARD, PAYPAL, BANK_TRANSFER, COD, WALLET&#10;    amount           DECIMAL(12, 2) NOT NULL,&#10;    currency         varchar(3)     NOT NULL DEFAULT 'VND',&#10;    status           varchar(50)    NOT NULL DEFAULT 'PENDING', -- PENDING, PROCESSING, SUCCESS, FAILED, CANCELLED, REFUNDED&#10;    transaction_id   varchar(255),                              -- External payment gateway transaction ID&#10;    gateway_provider varchar(50),                               -- STRIPE, PAYPAL, VNPAY, MOMO, etc.&#10;    gateway_response jsonb,                                     -- Store raw gateway response&#10;    failure_reason   varchar(500),&#10;    processed_at     timestamp,&#10;    created_by       varchar(255)   NOT NULL,&#10;    updated_by       varchar(255)   NOT NULL,&#10;    created_at       timestamp      NOT NULL DEFAULT CURRENT_TIMESTAMP,&#10;    updated_at       timestamp      NOT NULL DEFAULT CURRENT_TIMESTAMP,&#10;    version          int            NOT NULL DEFAULT 1,&#10;    PRIMARY KEY (id)&#10;);&#10;&#10;CREATE TABLE payment_methods&#10;(&#10;    id              BIGSERIAL    NOT NULL,&#10;    user_id         int8         NOT NULL,&#10;    method_type     varchar(50)  NOT NULL, -- CREDIT_CARD, DEBIT_CARD, PAYPAL, BANK_ACCOUNT, COD, WALLET&#10;    provider        varchar(50),           -- VISA, MASTERCARD, PAYPAL, etc. (NULL for COD)&#10;    masked_number   varchar(20),           -- Last 4 digits for cards (NULL for COD)&#10;    cardholder_name varchar(255),          -- NULL for COD&#10;    expiry_month    int2,                  -- NULL for COD&#10;    expiry_year     int4,                  -- NULL for COD&#10;    is_default      boolean      NOT NULL DEFAULT false,&#10;    is_active       boolean      NOT NULL DEFAULT true,&#10;    external_id     varchar(255),          -- ID from payment gateway (NULL for COD)&#10;    created_by      varchar(255) NOT NULL,&#10;    updated_by      varchar(255) NOT NULL,&#10;    created_at      timestamp    NOT NULL DEFAULT CURRENT_TIMESTAMP,&#10;    updated_at      timestamp    NOT NULL DEFAULT CURRENT_TIMESTAMP,&#10;    version         int          NOT NULL DEFAULT 1,&#10;    PRIMARY KEY (id)&#10;);&#10;&#10;CREATE TABLE refunds&#10;(&#10;    id               BIGSERIAL      NOT NULL,&#10;    payment_id       int8           NOT NULL,&#10;    order_id         int8           NOT NULL,&#10;    refund_amount    DECIMAL(12, 2) NOT NULL,&#10;    reason           varchar(500)   NOT NULL,&#10;    status           varchar(50)    NOT NULL DEFAULT 'PENDING', -- PENDING, PROCESSING, SUCCESS, FAILED&#10;    transaction_id   varchar(255),                              -- External refund transaction ID&#10;    gateway_response jsonb,&#10;    processed_at     timestamp,&#10;    created_by       varchar(255)   NOT NULL,&#10;    updated_by       varchar(255)   NOT NULL,&#10;    created_at       timestamp      NOT NULL DEFAULT CURRENT_TIMESTAMP,&#10;    updated_at       timestamp      NOT NULL DEFAULT CURRENT_TIMESTAMP,&#10;    version          int            NOT NULL DEFAULT 1,&#10;    PRIMARY KEY (id)&#10;);&#10;&#10;-- Add constraints&#10;ALTER TABLE payments&#10;    ADD CONSTRAINT CHK_payments_amount CHECK (amount &gt; 0),&#10;    ADD CONSTRAINT CHK_payments_currency CHECK (currency IN ('VND', 'USD', 'EUR'));&#10;&#10;ALTER TABLE payment_methods&#10;    ADD CONSTRAINT CHK_payment_methods_expiry_month CHECK (expiry_month IS NULL OR (expiry_month &gt;= 1 AND expiry_month &lt;= 12)),&#10;    ADD CONSTRAINT CHK_payment_methods_expiry_year CHECK (expiry_year IS NULL OR expiry_year &gt;= EXTRACT(YEAR FROM CURRENT_DATE));&#10;&#10;ALTER TABLE refunds&#10;    ADD CONSTRAINT CHK_refunds_amount CHECK (refund_amount &gt; 0);&#10;&#10;-- Add foreign key constraints&#10;ALTER TABLE refunds&#10;    ADD CONSTRAINT FK_refunds_payment FOREIGN KEY (payment_id) REFERENCES payments (id) ON DELETE CASCADE;&#10;" />
              <option name="updatedContent" value="-- Payment Service Database Schema&#13;&#10;&#13;&#10;CREATE TABLE payments&#13;&#10;(&#13;&#10;    id               BIGSERIAL      NOT NULL,&#13;&#10;    request_id        varchar(255)   NOT NULL UNIQUE, -- Idempotency key from gateway&#13;&#10;    order_id         int8           NOT NULL,&#13;&#10;    user_id          int8           NOT NULL,&#13;&#10;    payment_method   varchar(50)    NOT NULL,                   -- CREDIT_CARD, DEBIT_CARD, PAYPAL, BANK_TRANSFER, COD, WALLET&#13;&#10;    amount           DECIMAL(12, 2) NOT NULL,&#13;&#10;    currency         varchar(3)     NOT NULL DEFAULT 'VND',&#13;&#10;    status           varchar(50)    NOT NULL DEFAULT 'PENDING', -- PENDING, PROCESSING, SUCCESS, FAILED, CANCELLED, REFUNDED&#13;&#10;    transaction_id   varchar(255),                              -- External payment gateway transaction ID&#13;&#10;    gateway_provider varchar(50),                               -- STRIPE, PAYPAL, VNPAY, MOMO, etc.&#13;&#10;    gateway_response jsonb,                                     -- Store raw gateway response&#13;&#10;    failure_reason   varchar(500),&#13;&#10;    processed_at     timestamp,&#13;&#10;    created_by       varchar(255)   NOT NULL,&#13;&#10;    updated_by       varchar(255)   NOT NULL,&#13;&#10;    created_at       timestamp      NOT NULL DEFAULT CURRENT_TIMESTAMP,&#13;&#10;    updated_at       timestamp      NOT NULL DEFAULT CURRENT_TIMESTAMP,&#13;&#10;    version          int            NOT NULL DEFAULT 1,&#13;&#10;    PRIMARY KEY (id)&#13;&#10;);&#13;&#10;&#13;&#10;CREATE TABLE payment_methods&#13;&#10;(&#13;&#10;    id              BIGSERIAL    NOT NULL,&#13;&#10;    user_id         int8         NOT NULL,&#13;&#10;    method_type     varchar(50)  NOT NULL, -- CREDIT_CARD, DEBIT_CARD, PAYPAL, BANK_ACCOUNT, COD, WALLET&#13;&#10;    provider        varchar(50),           -- VISA, MASTERCARD, PAYPAL, etc. (NULL for COD)&#13;&#10;    masked_number   varchar(20),           -- Last 4 digits for cards (NULL for COD)&#13;&#10;    cardholder_name varchar(255),          -- NULL for COD&#13;&#10;    expiry_month    int2,                  -- NULL for COD&#13;&#10;    expiry_year     int4,                  -- NULL for COD&#13;&#10;    is_default      boolean      NOT NULL DEFAULT false,&#13;&#10;    is_active       boolean      NOT NULL DEFAULT true,&#13;&#10;    external_id     varchar(255),          -- ID from payment gateway (NULL for COD)&#13;&#10;    created_by      varchar(255) NOT NULL,&#13;&#10;    updated_by      varchar(255) NOT NULL,&#13;&#10;    created_at      timestamp    NOT NULL DEFAULT CURRENT_TIMESTAMP,&#13;&#10;    updated_at      timestamp    NOT NULL DEFAULT CURRENT_TIMESTAMP,&#13;&#10;    version         int          NOT NULL DEFAULT 1,&#13;&#10;    PRIMARY KEY (id)&#13;&#10;);&#13;&#10;&#13;&#10;CREATE TABLE refunds&#13;&#10;(&#13;&#10;    id               BIGSERIAL      NOT NULL,&#13;&#10;    payment_id       int8           NOT NULL,&#13;&#10;    order_id         int8           NOT NULL,&#13;&#10;    refund_amount    DECIMAL(12, 2) NOT NULL,&#13;&#10;    reason           varchar(500)   NOT NULL,&#13;&#10;    status           varchar(50)    NOT NULL DEFAULT 'PENDING', -- PENDING, PROCESSING, SUCCESS, FAILED&#13;&#10;    transaction_id   varchar(255),                              -- External refund transaction ID&#13;&#10;    gateway_response jsonb,&#13;&#10;    processed_at     timestamp,&#13;&#10;    created_by       varchar(255)   NOT NULL,&#13;&#10;    updated_by       varchar(255)   NOT NULL,&#13;&#10;    created_at       timestamp      NOT NULL DEFAULT CURRENT_TIMESTAMP,&#13;&#10;    updated_at       timestamp      NOT NULL DEFAULT CURRENT_TIMESTAMP,&#13;&#10;    version          int            NOT NULL DEFAULT 1,&#13;&#10;    PRIMARY KEY (id)&#13;&#10;);&#13;&#10;&#13;&#10;-- Add constraints&#13;&#10;ALTER TABLE payments&#13;&#10;    ADD CONSTRAINT CHK_payments_amount CHECK (amount &gt; 0),&#13;&#10;    ADD CONSTRAINT CHK_payments_currency CHECK (currency IN ('VND', 'USD', 'EUR'));&#13;&#10;&#13;&#10;ALTER TABLE payment_methods&#13;&#10;    ADD CONSTRAINT CHK_payment_methods_expiry_month CHECK (expiry_month IS NULL OR (expiry_month &gt;= 1 AND expiry_month &lt;= 12)),&#13;&#10;    ADD CONSTRAINT CHK_payment_methods_expiry_year CHECK (expiry_year IS NULL OR expiry_year &gt;= EXTRACT(YEAR FROM CURRENT_DATE));&#13;&#10;&#13;&#10;ALTER TABLE refunds&#13;&#10;    ADD CONSTRAINT CHK_refunds_amount CHECK (refund_amount &gt; 0);&#13;&#10;&#13;&#10;-- Add foreign key constraints&#13;&#10;ALTER TABLE refunds&#13;&#10;    ADD CONSTRAINT FK_refunds_payment FOREIGN KEY (payment_id) REFERENCES payments (id) ON DELETE CASCADE;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/internal/services/shipping/db/schema.sql">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/internal/services/shipping/db/schema.sql" />
              <option name="updatedContent" value="-- Shipping Service Database Schema&#10;&#10;CREATE TABLE shipping_providers (&#10;    id           BIGSERIAL    NOT NULL,&#10;    name         varchar(255) NOT NULL UNIQUE,&#10;    code         varchar(50)  NOT NULL UNIQUE, -- GHTK, GHN, VIETTEL_POST, etc.&#10;    api_endpoint varchar(500),&#10;    is_active    boolean      NOT NULL DEFAULT true,&#10;    created_by   varchar(255) NOT NULL,&#10;    updated_by   varchar(255) NOT NULL,&#10;    created_at   timestamp    NOT NULL DEFAULT CURRENT_TIMESTAMP,&#10;    updated_at   timestamp    NOT NULL DEFAULT CURRENT_TIMESTAMP,&#10;    version      int          NOT NULL DEFAULT 1,&#10;    PRIMARY KEY (id)&#10;);&#10;&#10;CREATE TABLE shipping_rates (&#10;    id                  BIGSERIAL      NOT NULL,&#10;    provider_id         int8           NOT NULL,&#10;    service_type        varchar(100)   NOT NULL, -- STANDARD, EXPRESS, SAME_DAY&#10;    from_city           varchar(100)   NOT NULL,&#10;    to_city             varchar(100)   NOT NULL,&#10;    min_weight          DECIMAL(8, 2)  NOT NULL DEFAULT 0.00, -- in kg&#10;    max_weight          DECIMAL(8, 2)  NOT NULL,&#10;    base_rate           DECIMAL(10, 2) NOT NULL,&#10;    rate_per_kg         DECIMAL(10, 2) NOT NULL DEFAULT 0.00,&#10;    estimated_days      int4           NOT NULL DEFAULT 1,&#10;    is_active           boolean        NOT NULL DEFAULT true,&#10;    created_by          varchar(255)   NOT NULL,&#10;    updated_by          varchar(255)   NOT NULL,&#10;    created_at          timestamp      NOT NULL DEFAULT CURRENT_TIMESTAMP,&#10;    updated_at          timestamp      NOT NULL DEFAULT CURRENT_TIMESTAMP,&#10;    version             int            NOT NULL DEFAULT 1,&#10;    PRIMARY KEY (id)&#10;);&#10;&#10;CREATE TABLE shipments (&#10;    id                    BIGSERIAL      NOT NULL,&#10;    order_id              int8           NOT NULL,&#10;    provider_id           int8           NOT NULL,&#10;    tracking_number       varchar(255)   UNIQUE,&#10;    service_type          varchar(100)   NOT NULL,&#10;    status                varchar(50)    NOT NULL DEFAULT 'PENDING', -- PENDING, PICKED_UP, IN_TRANSIT, OUT_FOR_DELIVERY, DELIVERED, RETURNED, CANCELLED&#10;    weight                DECIMAL(8, 2)  NOT NULL,&#10;    dimensions            varchar(100),  -- LxWxH in cm&#10;    shipping_cost         DECIMAL(10, 2) NOT NULL,&#10;    estimated_delivery    timestamp,&#10;    actual_delivery       timestamp,&#10;    pickup_address        text           NOT NULL,&#10;    delivery_address      text           NOT NULL,&#10;    recipient_name        varchar(255)   NOT NULL,&#10;    recipient_phone       varchar(20)    NOT NULL,&#10;    special_instructions  text,&#10;    created_by            varchar(255)   NOT NULL,&#10;    updated_by            varchar(255)   NOT NULL,&#10;    created_at            timestamp      NOT NULL DEFAULT CURRENT_TIMESTAMP,&#10;    updated_at            timestamp      NOT NULL DEFAULT CURRENT_TIMESTAMP,&#10;    version               int            NOT NULL DEFAULT 1,&#10;    PRIMARY KEY (id)&#10;);&#10;&#10;CREATE TABLE shipment_tracking (&#10;    id            BIGSERIAL    NOT NULL,&#10;    shipment_id   int8         NOT NULL,&#10;    status        varchar(50)  NOT NULL,&#10;    location      varchar(255),&#10;    description   varchar(500) NOT NULL,&#10;    timestamp     timestamp    NOT NULL,&#10;    created_by    varchar(255) NOT NULL,&#10;    updated_by    varchar(255) NOT NULL,&#10;    created_at    timestamp    NOT NULL DEFAULT CURRENT_TIMESTAMP,&#10;    updated_at    timestamp    NOT NULL DEFAULT CURRENT_TIMESTAMP,&#10;    version       int          NOT NULL DEFAULT 1,&#10;    PRIMARY KEY (id)&#10;);&#10;&#10;-- Add constraints&#10;ALTER TABLE shipping_rates&#10;    ADD CONSTRAINT CHK_shipping_rates_weight CHECK (min_weight &gt;= 0 AND max_weight &gt; min_weight),&#10;    ADD CONSTRAINT CHK_shipping_rates_base_rate CHECK (base_rate &gt;= 0),&#10;    ADD CONSTRAINT CHK_shipping_rates_rate_per_kg CHECK (rate_per_kg &gt;= 0),&#10;    ADD CONSTRAINT CHK_shipping_rates_estimated_days CHECK (estimated_days &gt; 0);&#10;&#10;ALTER TABLE shipments&#10;    ADD CONSTRAINT CHK_shipments_weight CHECK (weight &gt; 0),&#10;    ADD CONSTRAINT CHK_shipments_shipping_cost CHECK (shipping_cost &gt;= 0),&#10;    ADD CONSTRAINT CHK_shipments_delivery_dates CHECK (actual_delivery IS NULL OR estimated_delivery IS NULL OR actual_delivery &gt;= estimated_delivery - INTERVAL '7 days');&#10;&#10;-- Add foreign key constraints&#10;ALTER TABLE shipping_rates&#10;    ADD CONSTRAINT FK_shipping_rates_provider FOREIGN KEY (provider_id) REFERENCES shipping_providers (id) ON DELETE CASCADE;&#10;&#10;ALTER TABLE shipments&#10;    ADD CONSTRAINT FK_shipments_provider FOREIGN KEY (provider_id) REFERENCES shipping_providers (id) ON DELETE RESTRICT;&#10;&#10;ALTER TABLE shipment_tracking&#10;    ADD CONSTRAINT FK_shipment_tracking_shipment FOREIGN KEY (shipment_id) REFERENCES shipments (id) ON DELETE CASCADE;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>