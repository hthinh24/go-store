<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/.gitignore">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/.gitignore" />
              <option name="originalContent" value="# env files&#10;*.env&#10;&#10;docs/" />
              <option name="updatedContent" value="# env files&#13;&#10;*.env&#13;&#10;&#13;&#10;# Binaries for programs and plugins&#13;&#10;*.exe&#13;&#10;*.exe~&#13;&#10;*.dll&#13;&#10;*.so&#13;&#10;*.dylib&#13;&#10;&#13;&#10;# Test binary, built with `go test -c`&#13;&#10;*.test&#13;&#10;&#13;&#10;# Output of the go coverage tool, specifically when used with LiteIDE&#13;&#10;*.out&#13;&#10;&#13;&#10;# Go workspace file&#13;&#10;go.work&#13;&#10;&#13;&#10;# IDE files (IntelliJ IDEA)&#13;&#10;.idea/&#13;&#10;*.iws&#13;&#10;*.iml&#13;&#10;*.ipr&#13;&#10;&#13;&#10;# VS Code&#13;&#10;.vscode/&#13;&#10;&#13;&#10;# Temporary files&#13;&#10;*.tmp&#13;&#10;*.temp&#13;&#10;*.log&#13;&#10;&#13;&#10;docs/" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/internal/pkg/auth/auth_middleware.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/internal/pkg/auth/auth_middleware.go" />
              <option name="updatedContent" value="package auth&#10;&#10;import (&#10;&#9;&quot;net/http&quot;&#10;&#9;&quot;strings&quot;&#10;&#9;&quot;time&quot;&#10;&#10;&#9;&quot;github.com/gin-gonic/gin&quot;&#10;&#9;&quot;github.com/golang-jwt/jwt/v4&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/internal/pkg/logger&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/internal/pkg/rest&quot;&#10;)&#10;&#10;type SharedAuthMiddleware struct {&#10;&#9;logger    logger.Logger&#10;&#9;jwtSecret string&#10;}&#10;&#10;type JWTClaims struct {&#10;&#9;UserID           int64     `json:&quot;user_id&quot;`&#10;&#9;Email            string    `json:&quot;email&quot;`&#10;&#9;Roles            []string  `json:&quot;roles&quot;`&#10;&#9;Permissions      []string  `json:&quot;permissions&quot;`&#10;&#9;RefreshExpiresAt time.Time `json:&quot;refresh_expires_at&quot;`&#10;&#9;jwt.RegisteredClaims&#10;}&#10;&#10;func NewSharedAuthMiddleware(logger logger.Logger, jwtSecret string) *SharedAuthMiddleware {&#10;&#9;return &amp;SharedAuthMiddleware{&#10;&#9;&#9;logger:    logger,&#10;&#9;&#9;jwtSecret: jwtSecret,&#10;&#9;}&#10;}&#10;&#10;// AuthRequired validates JWT token and sets user info in context&#10;func (m *SharedAuthMiddleware) AuthRequired() gin.HandlerFunc {&#10;&#9;return func(c *gin.Context) {&#10;&#9;&#9;authHeader := c.GetHeader(&quot;Authorization&quot;)&#10;&#9;&#9;if authHeader == &quot;&quot; {&#10;&#9;&#9;&#9;c.JSON(http.StatusUnauthorized, rest.ErrorResponse{&#10;&#9;&#9;&#9;&#9;ApiError: rest.UnauthorizedError,&#10;&#9;&#9;&#9;&#9;Message:  &quot;Authorization header required&quot;,&#10;&#9;&#9;&#9;})&#10;&#9;&#9;&#9;c.Abort()&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#10;&#9;&#9;tokenString := strings.TrimPrefix(authHeader, &quot;Bearer &quot;)&#10;&#9;&#9;if tokenString == authHeader {&#10;&#9;&#9;&#9;c.JSON(http.StatusUnauthorized, rest.ErrorResponse{&#10;&#9;&#9;&#9;&#9;ApiError: rest.UnauthorizedError,&#10;&#9;&#9;&#9;&#9;Message:  &quot;Bearer token required&quot;,&#10;&#9;&#9;&#9;})&#10;&#9;&#9;&#9;c.Abort()&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#10;&#9;&#9;claims, err := m.validateToken(tokenString)&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;m.logger.Error(&quot;Failed to validate JWT token&quot;, &quot;error&quot;, err)&#10;&#9;&#9;&#9;c.JSON(http.StatusUnauthorized, rest.ErrorResponse{&#10;&#9;&#9;&#9;&#9;ApiError: rest.UnauthorizedError,&#10;&#9;&#9;&#9;&#9;Message:  &quot;Invalid token&quot;,&#10;&#9;&#9;&#9;})&#10;&#9;&#9;&#9;c.Abort()&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// Set user info in context for all services to use&#10;&#9;&#9;c.Set(&quot;user_id&quot;, claims.UserID)&#10;&#9;&#9;c.Set(&quot;email&quot;, claims.Email)&#10;&#9;&#9;c.Set(&quot;roles&quot;, claims.Roles)&#10;&#9;&#9;c.Set(&quot;permissions&quot;, claims.Permissions)&#10;&#10;&#9;&#9;c.Next()&#10;&#9;}&#10;}&#10;&#10;// RequirePermissions checks if user has ALL specified permissions&#10;func (m *SharedAuthMiddleware) RequirePermissions(requiredPermissions ...string) gin.HandlerFunc {&#10;&#9;return func(c *gin.Context) {&#10;&#9;&#9;permissions, exists := c.Get(&quot;permissions&quot;)&#10;&#9;&#9;if !exists {&#10;&#9;&#9;&#9;c.JSON(http.StatusUnauthorized, rest.ErrorResponse{&#10;&#9;&#9;&#9;&#9;ApiError: rest.UnauthorizedError,&#10;&#9;&#9;&#9;&#9;Message:  &quot;User not authenticated&quot;,&#10;&#9;&#9;&#9;})&#10;&#9;&#9;&#9;c.Abort()&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#10;&#9;&#9;userPermissions := permissions.([]string)&#10;&#9;&#9;userPermMap := make(map[string]bool)&#10;&#9;&#9;for _, perm := range userPermissions {&#10;&#9;&#9;&#9;userPermMap[perm] = true&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// Check if user has all required permissions&#10;&#9;&#9;for _, requiredPerm := range requiredPermissions {&#10;&#9;&#9;&#9;if !userPermMap[requiredPerm] {&#10;&#9;&#9;&#9;&#9;m.logger.Warn(&quot;Access denied - missing permission&quot;, &#10;&#9;&#9;&#9;&#9;&#9;&quot;user_id&quot;, c.Get(&quot;user_id&quot;), &#10;&#9;&#9;&#9;&#9;&#9;&quot;required_permission&quot;, requiredPerm)&#10;&#9;&#9;&#9;&#9;c.JSON(http.StatusForbidden, rest.ErrorResponse{&#10;&#9;&#9;&#9;&#9;&#9;ApiError: rest.ForbiddenError,&#10;&#9;&#9;&#9;&#9;&#9;Message:  &quot;Insufficient permissions&quot;,&#10;&#9;&#9;&#9;&#9;})&#10;&#9;&#9;&#9;&#9;c.Abort()&#10;&#9;&#9;&#9;&#9;return&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#10;&#9;&#9;c.Next()&#10;&#9;}&#10;}&#10;&#10;// RequireAnyPermission checks if user has ANY of the specified permissions&#10;func (m *SharedAuthMiddleware) RequireAnyPermission(permissions ...string) gin.HandlerFunc {&#10;&#9;return func(c *gin.Context) {&#10;&#9;&#9;userPermissions, exists := c.Get(&quot;permissions&quot;)&#10;&#9;&#9;if !exists {&#10;&#9;&#9;&#9;c.JSON(http.StatusUnauthorized, rest.ErrorResponse{&#10;&#9;&#9;&#9;&#9;ApiError: rest.UnauthorizedError,&#10;&#9;&#9;&#9;&#9;Message:  &quot;User not authenticated&quot;,&#10;&#9;&#9;&#9;})&#10;&#9;&#9;&#9;c.Abort()&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#10;&#9;&#9;userPerms := userPermissions.([]string)&#10;&#9;&#9;for _, userPerm := range userPerms {&#10;&#9;&#9;&#9;for _, requiredPerm := range permissions {&#10;&#9;&#9;&#9;&#9;if userPerm == requiredPerm {&#10;&#9;&#9;&#9;&#9;&#9;c.Next()&#10;&#9;&#9;&#9;&#9;&#9;return&#10;&#9;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#10;&#9;&#9;c.JSON(http.StatusForbidden, rest.ErrorResponse{&#10;&#9;&#9;&#9;ApiError: rest.ForbiddenError,&#10;&#9;&#9;&#9;Message:  &quot;Insufficient permissions&quot;,&#10;&#9;&#9;})&#10;&#9;&#9;c.Abort()&#10;&#9;}&#10;}&#10;&#10;// RequireRole checks if user has specific role&#10;func (m *SharedAuthMiddleware) RequireRole(role string) gin.HandlerFunc {&#10;&#9;return func(c *gin.Context) {&#10;&#9;&#9;roles, exists := c.Get(&quot;roles&quot;)&#10;&#9;&#9;if !exists {&#10;&#9;&#9;&#9;c.JSON(http.StatusUnauthorized, rest.ErrorResponse{&#10;&#9;&#9;&#9;&#9;ApiError: rest.UnauthorizedError,&#10;&#9;&#9;&#9;&#9;Message:  &quot;User not authenticated&quot;,&#10;&#9;&#9;&#9;})&#10;&#9;&#9;&#9;c.Abort()&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#10;&#9;&#9;userRoles := roles.([]string)&#10;&#9;&#9;for _, userRole := range userRoles {&#10;&#9;&#9;&#9;if userRole == role {&#10;&#9;&#9;&#9;&#9;c.Next()&#10;&#9;&#9;&#9;&#9;return&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#10;&#9;&#9;c.JSON(http.StatusForbidden, rest.ErrorResponse{&#10;&#9;&#9;&#9;ApiError: rest.ForbiddenError,&#10;&#9;&#9;&#9;Message:  &quot;Insufficient role permissions&quot;,&#10;&#9;&#9;})&#10;&#9;&#9;c.Abort()&#10;&#9;}&#10;}&#10;&#10;func (m *SharedAuthMiddleware) validateToken(tokenString string) (*JWTClaims, error) {&#10;&#9;token, err := jwt.ParseWithClaims(tokenString, &amp;JWTClaims{}, func(token *jwt.Token) (interface{}, error) {&#10;&#9;&#9;return []byte(m.jwtSecret), nil&#10;&#9;})&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;claims, ok := token.Claims.(*JWTClaims)&#10;&#9;if !ok {&#10;&#9;&#9;return nil, jwt.ErrTokenMalformed&#10;&#9;}&#10;&#10;&#9;now := time.Now()&#10;&#10;&#9;// Check if refresh token is expired (hard expiration)&#10;&#9;if !claims.RefreshExpiresAt.IsZero() &amp;&amp; now.After(claims.RefreshExpiresAt) {&#10;&#9;&#9;m.logger.Warn(&quot;Refresh token has expired&quot;, &quot;user_id&quot;, claims.UserID)&#10;&#9;&#9;return nil, jwt.NewValidationError(&quot;refresh token expired&quot;, jwt.ValidationErrorExpired)&#10;&#9;}&#10;&#10;&#9;// Check if access token is expired&#10;&#9;if claims.ExpiresAt != nil &amp;&amp; now.After(claims.ExpiresAt.Time) {&#10;&#9;&#9;m.logger.Info(&quot;Access token expired&quot;, &quot;user_id&quot;, claims.UserID)&#10;&#9;&#9;return nil, jwt.NewValidationError(&quot;access token expired&quot;, jwt.ValidationErrorExpired)&#10;&#9;}&#10;&#10;&#9;// Check not before&#10;&#9;if claims.NotBefore != nil &amp;&amp; now.Before(claims.NotBefore.Time) {&#10;&#9;&#9;return nil, jwt.NewValidationError(&quot;token used before valid&quot;, jwt.ValidationErrorNotValidYet)&#10;&#9;}&#10;&#10;&#9;// Check issued at&#10;&#9;if claims.IssuedAt != nil &amp;&amp; now.Before(claims.IssuedAt.Time) {&#10;&#9;&#9;return nil, jwt.NewValidationError(&quot;token issued in the future&quot;, jwt.ValidationErrorIssuedAt)&#10;&#9;}&#10;&#10;&#9;return claims, nil&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/internal/pkg/config/pg/pg.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/internal/pkg/config/pg/pg.go" />
              <option name="updatedContent" value="package pg&#10;&#10;import &quot;fmt&quot;&#10;&#10;// PG holds PostgreSQL database configuration&#10;type PG struct {&#10;&#9;Host            string `mapstructure:&quot;host&quot; env:&quot;PG_HOST&quot;`&#10;&#9;Port            string `mapstructure:&quot;port&quot; env:&quot;PG_PORT&quot;`&#10;&#9;User            string `mapstructure:&quot;user&quot; env:&quot;PG_USER&quot;`&#10;&#9;Password        string `mapstructure:&quot;password&quot; env:&quot;PG_PASSWORD&quot;`&#10;&#9;Database        string `mapstructure:&quot;database&quot; env:&quot;PG_DATABASE&quot;`&#10;&#9;SSLMode         string `mapstructure:&quot;ssl_mode&quot; env:&quot;PG_SSL_MODE&quot;`&#10;&#9;MaxOpenConns    int    `mapstructure:&quot;max_open_conns&quot; env:&quot;PG_MAX_OPEN_CONNS&quot;`&#10;&#9;MaxIdleConns    int    `mapstructure:&quot;max_idle_conns&quot; env:&quot;PG_MAX_IDLE_CONNS&quot;`&#10;&#9;ConnMaxLifetime int    `mapstructure:&quot;conn_max_lifetime&quot; env:&quot;PG_CONN_MAX_LIFETIME&quot;`&#10;&#9;ConnMaxIdleTime int    `mapstructure:&quot;conn_max_idle_time&quot; env:&quot;PG_CONN_MAX_IDLE_TIME&quot;`&#10;}&#10;&#10;// GetDSN returns the PostgreSQL connection string&#10;func (p *PG) GetDSN() string {&#10;&#9;return fmt.Sprintf(&quot;host=%s port=%s user=%s password=%s dbname=%s sslmode=%s&quot;,&#10;&#9;&#9;p.Host, p.Port, p.User, p.Password, p.Database, p.SSLMode)&#10;}&#10;&#10;// IsValid checks if all required PostgreSQL fields are set&#10;func (p *PG) IsValid() bool {&#10;&#9;return p.Host != &quot;&quot; &amp;&amp; p.Port != &quot;&quot; &amp;&amp; p.User != &quot;&quot; &amp;&amp; p.Database != &quot;&quot;&#10;}&#10;&#10;// SetDefaults sets default values for PostgreSQL configuration&#10;func (p *PG) SetDefaults() {&#10;&#9;if p.Host == &quot;&quot; {&#10;&#9;&#9;p.Host = &quot;localhost&quot;&#10;&#9;}&#10;&#9;if p.Port == &quot;&quot; {&#10;&#9;&#9;p.Port = &quot;5432&quot;&#10;&#9;}&#10;&#9;if p.SSLMode == &quot;&quot; {&#10;&#9;&#9;p.SSLMode = &quot;disable&quot;&#10;&#9;}&#10;&#9;if p.MaxOpenConns == 0 {&#10;&#9;&#9;p.MaxOpenConns = 25&#10;&#9;}&#10;&#9;if p.MaxIdleConns == 0 {&#10;&#9;&#9;p.MaxIdleConns = 10&#10;&#9;}&#10;&#9;if p.ConnMaxLifetime == 0 {&#10;&#9;&#9;p.ConnMaxLifetime = 300 // 5 minutes in seconds&#10;&#9;}&#10;&#9;if p.ConnMaxIdleTime == 0 {&#10;&#9;&#9;p.ConnMaxIdleTime = 60 // 1 minute in seconds&#10;&#9;}&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/internal/pkg/config/services.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/internal/pkg/config/services.go" />
              <option name="originalContent" value="package config&#10;&#10;// Services holds URLs for inter-service communication&#10;type Services struct {&#10;&#9;UserServiceURL         string `mapstructure:&quot;user_service_url&quot; env:&quot;USER_SERVICE_URL&quot;`&#10;&#9;ProductServiceURL      string `mapstructure:&quot;product_service_url&quot; env:&quot;PRODUCT_SERVICE_URL&quot;`&#10;&#9;CartServiceURL         string `mapstructure:&quot;cart_service_url&quot; env:&quot;CART_SERVICE_URL&quot;`&#10;&#9;OrderServiceURL        string `mapstructure:&quot;order_service_url&quot; env:&quot;ORDER_SERVICE_URL&quot;`&#10;&#9;GatewayServiceURL      string `mapstructure:&quot;gateway_service_url&quot; env:&quot;GATEWAY_SERVICE_URL&quot;`&#10;&#9;NotificationServiceURL string `mapstructure:&quot;notification_service_url&quot; env:&quot;NOTIFICATION_SERVICE_URL&quot;`&#10;&#9;PaymentServiceURL      string `mapstructure:&quot;payment_service_url&quot; env:&quot;PAYMENT_SERVICE_URL&quot;`&#10;}&#10;&#10;// GetServiceURL returns the URL for a specific service&#10;func (s *Services) GetServiceURL(serviceName string) string {&#10;&#9;switch serviceName {&#10;&#9;case &quot;user&quot;, &quot;identity&quot;:&#10;&#9;&#9;return s.UserServiceURL&#10;&#9;case &quot;product&quot;:&#10;&#9;&#9;return s.ProductServiceURL&#10;&#9;case &quot;cart&quot;:&#10;&#9;&#9;return s.CartServiceURL&#10;&#9;case &quot;order&quot;:&#10;&#9;&#9;return s.OrderServiceURL&#10;&#9;case &quot;gateway&quot;:&#10;&#9;&#9;return s.GatewayServiceURL&#10;&#9;case &quot;notification&quot;:&#10;&#9;&#9;return s.NotificationServiceURL&#10;&#9;case &quot;payment&quot;:&#10;&#9;&#9;return s.PaymentServiceURL&#10;&#9;default:&#10;&#9;&#9;return &quot;&quot;&#10;&#9;}&#10;}&#10;&#10;// SetDefaults sets default service URLs based on standard ports&#10;func (s *Services) SetDefaults() {&#10;&#9;if s.UserServiceURL == &quot;&quot; {&#10;&#9;&#9;s.UserServiceURL = &quot;http://localhost:8080&quot;&#10;&#9;}&#10;&#9;if s.ProductServiceURL == &quot;&quot; {&#10;&#9;&#9;s.ProductServiceURL = &quot;http://localhost:8081&quot;&#10;&#9;}&#10;&#9;if s.CartServiceURL == &quot;&quot; {&#10;&#9;&#9;s.CartServiceURL = &quot;http://localhost:8082&quot;&#10;&#9;}&#10;&#9;if s.OrderServiceURL == &quot;&quot; {&#10;&#9;&#9;s.OrderServiceURL = &quot;http://localhost:8083&quot;&#10;&#9;}&#10;&#9;if s.GatewayServiceURL == &quot;&quot; {&#10;&#9;&#9;s.GatewayServiceURL = &quot;http://localhost:8000&quot;&#10;&#9;}&#10;}&#10;" />
              <option name="updatedContent" value="package config&#10;&#10;// Services holds URLs for inter-service communication&#10;type Services struct {&#10;&#9;IdentityServiceURL     string `mapstructure:&quot;identity_service_url&quot; env:&quot;IDENTITY_SERVICE_URL&quot;`&#10;&#9;ProductServiceURL      string `mapstructure:&quot;product_service_url&quot; env:&quot;PRODUCT_SERVICE_URL&quot;`&#10;&#9;CartServiceURL         string `mapstructure:&quot;cart_service_url&quot; env:&quot;CART_SERVICE_URL&quot;`&#10;&#9;OrderServiceURL        string `mapstructure:&quot;order_service_url&quot; env:&quot;ORDER_SERVICE_URL&quot;`&#10;&#9;GatewayServiceURL      string `mapstructure:&quot;gateway_service_url&quot; env:&quot;GATEWAY_SERVICE_URL&quot;`&#10;&#9;NotificationServiceURL string `mapstructure:&quot;notification_service_url&quot; env:&quot;NOTIFICATION_SERVICE_URL&quot;`&#10;&#9;PaymentServiceURL      string `mapstructure:&quot;payment_service_url&quot; env:&quot;PAYMENT_SERVICE_URL&quot;`&#10;}&#10;&#10;// GetServiceURL returns the URL for a specific service&#10;func (s *Services) GetServiceURL(serviceName string) string {&#10;&#9;switch serviceName {&#10;&#9;case &quot;user&quot;, &quot;identity&quot;:&#10;&#9;&#9;return s.IdentityServiceURL&#10;&#9;case &quot;product&quot;:&#10;&#9;&#9;return s.ProductServiceURL&#10;&#9;case &quot;cart&quot;:&#10;&#9;&#9;return s.CartServiceURL&#10;&#9;case &quot;order&quot;:&#10;&#9;&#9;return s.OrderServiceURL&#10;&#9;case &quot;gateway&quot;:&#10;&#9;&#9;return s.GatewayServiceURL&#10;&#9;case &quot;notification&quot;:&#10;&#9;&#9;return s.NotificationServiceURL&#10;&#9;case &quot;payment&quot;:&#10;&#9;&#9;return s.PaymentServiceURL&#10;&#9;default:&#10;&#9;&#9;return &quot;&quot;&#10;&#9;}&#10;}&#10;&#10;// SetDefaults sets default service URLs based on standard ports&#10;func (s *Services) SetDefaults() {&#10;&#9;if s.IdentityServiceURL == &quot;&quot; {&#10;&#9;&#9;s.IdentityServiceURL = &quot;http://localhost:8080&quot;&#10;&#9;}&#10;&#9;if s.ProductServiceURL == &quot;&quot; {&#10;&#9;&#9;s.ProductServiceURL = &quot;http://localhost:8081&quot;&#10;&#9;}&#10;&#9;if s.CartServiceURL == &quot;&quot; {&#10;&#9;&#9;s.CartServiceURL = &quot;http://localhost:8082&quot;&#10;&#9;}&#10;&#9;if s.OrderServiceURL == &quot;&quot; {&#10;&#9;&#9;s.OrderServiceURL = &quot;http://localhost:8083&quot;&#10;&#9;}&#10;&#9;if s.GatewayServiceURL == &quot;&quot; {&#10;&#9;&#9;s.GatewayServiceURL = &quot;http://localhost:8000&quot;&#10;&#9;}&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/internal/pkg/gateway/api_gateway.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/internal/pkg/gateway/api_gateway.go" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/internal/services/cart/cmd/main.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/internal/services/cart/cmd/main.go" />
              <option name="originalContent" value="package main&#10;&#10;import (&#10;&#9;&quot;github.com/hthinh24/go-store/internal/pkg/middleware/auth&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/internal/services/cart/internal/controller/http&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/internal/services/cart/internal/controller/http/client&quot;&#10;&#9;&quot;log&quot;&#10;&#10;&#9;&quot;github.com/gin-gonic/gin&quot;&#10;&#9;customLog &quot;github.com/hthinh24/go-store/internal/pkg/logger&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/internal/services/cart/internal/config&quot;&#10;&#9;repository &quot;github.com/hthinh24/go-store/internal/services/cart/internal/infra/postgres&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/internal/services/cart/internal/service&quot;&#10;&#9;&quot;gorm.io/driver/postgres&quot;&#10;&#9;&quot;gorm.io/gorm&quot;&#10;)&#10;&#10;func main() {&#10;&#9;configPath := &quot;config.yaml&quot;&#10;&#10;&#9;// Load configuration using shared pkg config&#10;&#9;cfg, err := config.LoadConfig(configPath)&#10;&#9;if err != nil {&#10;&#9;&#9;log.Fatalf(&quot;Failed to load config: %v&quot;, err)&#10;&#9;}&#10;&#10;&#9;appLogger := customLog.NewAppLogger(cfg.GetLogLevel())&#10;&#9;appLogger.Info(&quot;Starting Cart Service...&quot;)&#10;&#9;appLogger.Info(&quot;Environment: %s&quot;, cfg.GetEnvironment())&#10;&#10;&#9;db, err := initDatabase(cfg)&#10;&#9;if err != nil {&#10;&#9;&#9;appLogger.Error(&quot;Failed to connect to database: %v&quot;, err)&#10;&#9;&#9;log.Fatal(err)&#10;&#9;}&#10;&#9;appLogger.Info(&quot;Database connected successfully&quot;)&#10;&#10;&#9;productClient := client.NewProductClient(cfg.ProductServiceURL)&#10;&#10;&#9;cartRepository := repository.NewCartRepository(customLog.WithComponent(cfg.LogLevel, &quot;CART-REPOSITORY&quot;), db)&#10;&#9;cartService := service.NewCartService(customLog.WithComponent(cfg.LogLevel, &quot;CART-SERVICE&quot;),&#10;&#9;&#9;cartRepository,&#10;&#9;&#9;productClient)&#10;&#9;cartController := http.NewCartController(customLog.WithComponent(cfg.LogLevel, &quot;CART-CONTROLLER&quot;), cartService)&#10;&#10;&#9;router := setupRouter(cartController, cfg)&#10;&#10;&#9;serverAddr := &quot;:&quot; + cfg.ServerPort&#10;&#9;appLogger.Info(&quot;Cart service starting on %s&quot;, serverAddr)&#10;&#9;if err := router.Run(serverAddr); err != nil {&#10;&#9;&#9;appLogger.Error(&quot;Failed to start server: %v&quot;, err)&#10;&#9;&#9;log.Fatal(err)&#10;&#9;}&#10;}&#10;&#10;func initDatabase(cfg *config.AppConfig) (*gorm.DB, error) {&#10;&#9;dsn := &quot;host=&quot; + cfg.DBHost + &quot; user=&quot; + cfg.DBUser + &quot; password=&quot; + cfg.DBPassword + &quot; dbname=&quot; + cfg.DBName + &quot; port=&quot; + cfg.DBPort + &quot; sslmode=&quot; + cfg.DBSSLMode&#10;&#9;db, err := gorm.Open(postgres.Open(dsn), &amp;gorm.Config{})&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#9;return db, nil&#10;}&#10;&#10;func setupRouter(cartController *http.CartController, cfg *config.AppConfig) *gin.Engine {&#10;&#9;router := gin.Default()&#10;&#10;&#9;authMiddleware := auth.NewSharedAuthMiddleware(customLog.WithComponent(cfg.LogLevel, &quot;AUTH-MIDDLEWARE&quot;))&#10;&#10;&#9;router.GET(&quot;/health&quot;, func(c *gin.Context) {&#10;&#9;&#9;c.JSON(200, gin.H{&quot;status&quot;: &quot;healthy&quot;})&#10;&#9;})&#10;&#10;&#9;api := router.Group(&quot;/api&quot;)&#10;&#9;{&#10;&#9;&#9;v1 := api.Group(&quot;/v1&quot;)&#10;&#9;&#9;cart := v1.Group(&quot;/cart&quot;)&#10;&#10;&#9;&#9;// Public endpoints&#10;&#9;&#9;cart.POST(&quot;/register&quot;, cartController.CreateCart())&#10;&#10;&#9;&#9;// Apply authentication middleware to cart routes&#10;&#9;&#9;cart.Use(authMiddleware.AuthRequired())&#10;&#9;&#9;{&#10;&#9;&#9;&#9;cart.GET(&quot;&quot;, cartController.GetCartItemsByUserID())&#10;&#10;&#9;&#9;&#9;cart.POST(&quot;/items&quot;, cartController.AddItemToCart())&#10;&#9;&#9;&#9;cart.PUT(&quot;/items&quot;, cartController.UpdateItemQuantity())&#10;&#9;&#9;&#9;cart.DELETE(&quot;/:item_id&quot;, cartController.RemoveItemFromCart())&#10;&#9;&#9;}&#10;&#9;}&#10;&#9;return router&#10;}&#10;" />
              <option name="updatedContent" value="package main&#10;&#10;import (&#10;&#9;&quot;github.com/hthinh24/go-store/internal/pkg/middleware/auth&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/internal/services/cart/internal/controller/http&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/internal/services/cart/internal/controller/http/client&quot;&#10;&#9;&quot;log&quot;&#10;&#10;&#9;&quot;github.com/gin-gonic/gin&quot;&#10;&#9;customLog &quot;github.com/hthinh24/go-store/internal/pkg/logger&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/internal/services/cart/internal/config&quot;&#10;&#9;repository &quot;github.com/hthinh24/go-store/internal/services/cart/internal/infra/postgres&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/internal/services/cart/internal/service&quot;&#10;&#9;&quot;gorm.io/driver/postgres&quot;&#10;&#9;&quot;gorm.io/gorm&quot;&#10;)&#10;&#10;func main() {&#10;&#9;configPath := &quot;config.yaml&quot;&#10;&#10;&#9;// Load configuration using shared pkg config&#10;&#9;cfg, err := config.LoadConfig(configPath)&#10;&#9;if err != nil {&#10;&#9;&#9;log.Fatalf(&quot;Failed to load config: %v&quot;, err)&#10;&#9;}&#10;&#10;&#9;appLogger := customLog.NewAppLogger(cfg.GetLogLevel())&#10;&#9;appLogger.Info(&quot;Starting Cart Service...&quot;)&#10;&#9;appLogger.Info(&quot;Environment: %s&quot;, cfg.GetEnvironment())&#10;&#10;&#9;db, err := initDatabase(cfg)&#10;&#9;if err != nil {&#10;&#9;&#9;appLogger.Error(&quot;Failed to connect to database: %v&quot;, err)&#10;&#9;&#9;log.Fatal(err)&#10;&#9;}&#10;&#9;appLogger.Info(&quot;Database connected successfully&quot;)&#10;&#10;&#9;productClient := client.NewProductClient(cfg.GetProductServiceURL())&#10;&#10;&#9;cartRepository := repository.NewCartRepository(customLog.WithComponent(cfg.GetLogLevel(), &quot;CART-REPOSITORY&quot;), db)&#10;&#9;cartService := service.NewCartService(customLog.WithComponent(cfg.GetLogLevel(), &quot;CART-SERVICE&quot;),&#10;&#9;&#9;cartRepository,&#10;&#9;&#9;productClient)&#10;&#9;cartController := http.NewCartController(customLog.WithComponent(cfg.GetLogLevel(), &quot;CART-CONTROLLER&quot;), cartService)&#10;&#10;&#9;router := setupRouter(cartController, cfg)&#10;&#10;&#9;serverAddr := cfg.GetServerAddress()&#10;&#9;appLogger.Info(&quot;Cart service starting on %s&quot;, serverAddr)&#10;&#9;if err := router.Run(serverAddr); err != nil {&#10;&#9;&#9;appLogger.Error(&quot;Failed to start server: %v&quot;, err)&#10;&#9;&#9;log.Fatal(err)&#10;&#9;}&#10;}&#10;&#10;func initDatabase(cfg *config.AppConfig) (*gorm.DB, error) {&#10;&#9;db, err := gorm.Open(postgres.Open(cfg.GetDatabaseURL()), &amp;gorm.Config{})&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#9;return db, nil&#10;}&#10;&#10;func setupRouter(cartController *http.CartController, cfg *config.AppConfig) *gin.Engine {&#10;&#9;router := gin.Default()&#10;&#10;&#9;authMiddleware := auth.NewSharedAuthMiddleware(customLog.WithComponent(cfg.GetLogLevel(), &quot;AUTH-MIDDLEWARE&quot;))&#10;&#10;&#9;router.GET(&quot;/health&quot;, func(c *gin.Context) {&#10;&#9;&#9;c.JSON(200, gin.H{&quot;status&quot;: &quot;healthy&quot;})&#10;&#9;})&#10;&#10;&#9;api := router.Group(&quot;/api&quot;)&#10;&#9;{&#10;&#9;&#9;v1 := api.Group(&quot;/v1&quot;)&#10;&#9;&#9;cart := v1.Group(&quot;/cart&quot;)&#10;&#10;&#9;&#9;// Public endpoints&#10;&#9;&#9;cart.POST(&quot;/register&quot;, cartController.CreateCart())&#10;&#10;&#9;&#9;// Apply authentication middleware to cart routes&#10;&#9;&#9;cart.Use(authMiddleware.AuthRequired())&#10;&#9;&#9;{&#10;&#9;&#9;&#9;cart.GET(&quot;&quot;, cartController.GetCartItemsByUserID())&#10;&#10;&#9;&#9;&#9;cart.POST(&quot;/items&quot;, cartController.AddItemToCart())&#10;&#9;&#9;&#9;cart.PUT(&quot;/items&quot;, cartController.UpdateItemQuantity())&#10;&#9;&#9;&#9;cart.DELETE(&quot;/:item_id&quot;, cartController.RemoveItemFromCart())&#10;&#9;&#9;}&#10;&#9;}&#10;&#9;return router&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/internal/services/cart/config.yaml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/internal/services/cart/config.yaml" />
              <option name="originalContent" value="environment: &quot;development&quot;&#10;service_name: &quot;cart&quot;&#10;&#10;# Application Configuration (host and port)&#10;app:&#10;  host: &quot;localhost&quot;&#10;  port: &quot;8082&quot;&#10;&#10;# HTTP Server Configuration&#10;http:&#10;  read_timeout: 10&#10;  write_timeout: 10&#10;  max_header_bytes: 1048576&#10;  allowed_origins: &quot;*&quot;&#10;  allowed_methods: &quot;GET,POST,PUT,DELETE,OPTIONS&quot;&#10;  allowed_headers: &quot;Content-Type,Authorization&quot;&#10;  exposed_headers: &quot;&quot;&#10;  allow_credentials: true&#10;&#10;# Database Configuration&#10;pg:&#10;  host: &quot;localhost&quot;&#10;  port: &quot;5432&quot;&#10;  user: &quot;postgres&quot;&#10;  password: &quot;password&quot;&#10;  database: &quot;gostore_cart&quot;&#10;  ssl_mode: &quot;disable&quot;&#10;  max_open_conns: 25&#10;  max_idle_conns: 10&#10;  conn_max_lifetime: 3600&#10;  conn_max_idle_time: 1800&#10;&#10;# JWT Configuration&#10;jwt:&#10;  secret: &quot;your-secret-key&quot;&#10;  expiration: &quot;24h&quot;&#10;  issuer: &quot;gostore-cart&quot;&#10;  audience: &quot;gostore-users&quot;&#10;&#10;# Redis Configuration&#10;redis:&#10;  host: &quot;localhost&quot;&#10;  port: &quot;6379&quot;&#10;  password: &quot;&quot;&#10;  db: 0&#10;  pool_size: 10&#10;  min_idle_conns: 3&#10;  dial_timeout: 5&#10;  read_timeout: 3&#10;  write_timeout: 3&#10;  idle_timeout: 300&#10;&#10;# Logging Configuration&#10;log:&#10;  level: &quot;info&quot;&#10;  format: &quot;json&quot;&#10;  output: &quot;stdout&quot;&#10;  file_path: &quot;&quot;&#10;  max_size: 10&#10;  max_backups: 3&#10;  max_age: 28&#10;  compress: true&#10;&#10;# Services Configuration for inter-service communication&#10;services:&#10;  identity_service_url: &quot;http://localhost:8080&quot;&#10;  product_service_url: &quot;http://localhost:8081&quot;&#10;  cart_service_url: &quot;http://localhost:8082&quot;&#10;  order_service_url: &quot;http://localhost:8083&quot;&#10;  gateway_service_url: &quot;http://localhost:8000&quot;&#10;  notification_service_url: &quot;http://localhost:8084&quot;&#10;  payment_service_url: &quot;http://localhost:8085&quot;&#10;" />
              <option name="updatedContent" value="environment: &quot;development&quot;&#10;service_name: &quot;cart&quot;&#10;&#10;# Application Configuration (host and port from .env: SERVER_HOST=localhost, SERVER_PORT=8082)&#10;app:&#10;  host: &quot;localhost&quot;&#10;  port: &quot;8082&quot;&#10;&#10;# HTTP Server Configuration&#10;http:&#10;  read_timeout: 10&#10;  write_timeout: 10&#10;  max_header_bytes: 1048576&#10;  allowed_origins: &quot;*&quot;&#10;  allowed_methods: &quot;GET,POST,PUT,DELETE,OPTIONS&quot;&#10;  allowed_headers: &quot;Content-Type,Authorization&quot;&#10;  exposed_headers: &quot;&quot;&#10;  allow_credentials: true&#10;&#10;# Database Configuration (from .env: DB_HOST=localhost, DB_PORT=5003, etc.)&#10;pg:&#10;  host: &quot;localhost&quot;&#10;  port: &quot;5003&quot;&#10;  user: &quot;postgres&quot;&#10;  password: &quot;root&quot;&#10;  database: &quot;postgres&quot;&#10;  ssl_mode: &quot;disable&quot;&#10;  max_open_conns: 25&#10;  max_idle_conns: 10&#10;  conn_max_lifetime: 3600&#10;  conn_max_idle_time: 1800&#10;&#10;# JWT Configuration (cart service doesn't have JWT in .env, using defaults)&#10;jwt:&#10;  secret: &quot;your-secret-key&quot;&#10;  expiration: &quot;24h&quot;&#10;  issuer: &quot;gostore-cart&quot;&#10;  audience: &quot;gostore-users&quot;&#10;&#10;# Redis Configuration (from .env: REDIS_HOST=localhost, REDIS_PORT=6002)&#10;redis:&#10;  host: &quot;localhost&quot;&#10;  port: &quot;6002&quot;&#10;  password: &quot;&quot;&#10;  db: 0&#10;  pool_size: 10&#10;  min_idle_conns: 3&#10;  dial_timeout: 5&#10;  read_timeout: 3&#10;  write_timeout: 3&#10;  idle_timeout: 300&#10;&#10;# Logging Configuration (from .env: LOG_LEVEL=info)&#10;log:&#10;  level: &quot;info&quot;&#10;  format: &quot;json&quot;&#10;  output: &quot;stdout&quot;&#10;  file_path: &quot;&quot;&#10;  max_size: 10&#10;  max_backups: 3&#10;  max_age: 28&#10;  compress: true&#10;&#10;# Services Configuration for inter-service communication (updated PRODUCT_SERVICE_URL)&#10;services:&#10;  identity_service_url: &quot;http://localhost:8080&quot;&#10;  product_service_url: &quot;http://localhost:8081&quot;&#10;  cart_service_url: &quot;http://localhost:8082&quot;&#10;  order_service_url: &quot;http://localhost:8083&quot;&#10;  gateway_service_url: &quot;http://localhost:8000&quot;&#10;  notification_service_url: &quot;http://localhost:8084&quot;&#10;  payment_service_url: &quot;http://localhost:8085&quot;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/internal/services/cart/internal/config/config.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/internal/services/cart/internal/config/config.go" />
              <option name="originalContent" value="package config&#10;&#10;import (&#10;&#9;&quot;fmt&quot;&#10;&#9;&quot;github.com/joho/godotenv&quot;&#10;&#9;&quot;os&quot;&#10;)&#10;&#10;type AppConfig struct {&#10;&#9;// Database Configuration&#10;&#9;DBHost     string&#10;&#9;DBPort     string&#10;&#9;DBUser     string&#10;&#9;DBPassword string&#10;&#9;DBName     string&#10;&#9;DBSSLMode  string&#10;&#10;&#9;// Server Configuration&#10;&#9;ServerPort string&#10;&#9;ServerHost string&#10;&#10;&#9;ProductServiceURL string&#10;&#10;&#9;// Log Configuration&#10;&#9;LogLevel string&#10;&#10;&#9;// Redis Configuration&#10;&#9;RedisHost     string&#10;&#9;RedisPort     string&#10;&#9;RedisPassword string&#10;&#10;&#9;// Environment&#10;&#9;Environment string&#10;}&#10;&#10;func LoadConfig(filename string) (*AppConfig, error) {&#10;&#9;// Load .env file in development&#10;&#9;if os.Getenv(&quot;ENV&quot;) != &quot;production&quot; {&#10;&#9;&#9;err := godotenv.Load(filename)&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;// Don't fail if .env file doesn't exist&#10;&#9;&#9;&#9;fmt.Println(&quot;Warning: .env file not found, using system environment variables&quot;)&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;config := &amp;AppConfig{&#10;&#9;&#9;DBHost:     getEnv(&quot;DB_HOST&quot;, &quot;localhost&quot;),&#10;&#9;&#9;DBPort:     getEnv(&quot;DB_PORT&quot;, &quot;5432&quot;),&#10;&#9;&#9;DBUser:     getEnv(&quot;DB_USER&quot;, &quot;postgres&quot;),&#10;&#9;&#9;DBPassword: getEnv(&quot;DB_PASSWORD&quot;, &quot;&quot;),&#10;&#9;&#9;DBName:     getEnv(&quot;DB_NAME&quot;, &quot;go_store_identity&quot;),&#10;&#9;&#9;DBSSLMode:  getEnv(&quot;DB_SSL_MODE&quot;, &quot;disable&quot;),&#10;&#10;&#9;&#9;ServerPort: getEnv(&quot;SERVER_PORT&quot;, &quot;8080&quot;),&#10;&#9;&#9;ServerHost: getEnv(&quot;SERVER_HOST&quot;, &quot;localhost&quot;),&#10;&#10;&#9;&#9;ProductServiceURL: getEnv(&quot;PRODUCT_SERVICE_URL&quot;, &quot;http://localhost:8081&quot;),&#10;&#10;&#9;&#9;LogLevel: getEnv(&quot;LOG_LEVEL&quot;, &quot;info&quot;),&#10;&#10;&#9;&#9;RedisHost:     getEnv(&quot;REDIS_HOST&quot;, &quot;localhost&quot;),&#10;&#9;&#9;RedisPort:     getEnv(&quot;REDIS_PORT&quot;, &quot;6379&quot;),&#10;&#9;&#9;RedisPassword: getEnv(&quot;REDIS_PASSWORD&quot;, &quot;&quot;),&#10;&#10;&#9;&#9;Environment: getEnv(&quot;ENV&quot;, &quot;development&quot;),&#10;&#9;}&#10;&#10;&#9;return config, nil&#10;}&#10;&#10;func (c *AppConfig) GetServerAddress() string {&#10;&#9;return fmt.Sprintf(&quot;%s:%s&quot;, c.ServerHost, c.ServerPort)&#10;}&#10;&#10;func (c *AppConfig) IsProduction() bool {&#10;&#9;return c.Environment == &quot;production&quot;&#10;}&#10;&#10;// getEnv gets environment variable with fallback&#10;func getEnv(key, fallback string) string {&#10;&#9;if value := os.Getenv(key); value != &quot;&quot; {&#10;&#9;&#9;return value&#10;&#9;}&#10;&#9;return fallback&#10;}&#10;" />
              <option name="updatedContent" value="package config&#13;&#10;&#13;&#10;import (&#13;&#10;&#9;&quot;fmt&quot;&#13;&#10;&#9;&quot;github.com/hthinh24/go-store/internal/pkg/config&quot;&#13;&#10;)&#13;&#10;&#13;&#10;type AppConfig struct {&#13;&#10;&#9;*config.Config&#13;&#10;}&#13;&#10;&#13;&#10;func LoadConfig(configPath string) (*AppConfig, error) {&#13;&#10;&#9;// Load shared configuration from pkg&#13;&#10;&#9;sharedConfig, err := config.LoadConfig(configPath)&#13;&#10;&#9;if err != nil {&#13;&#10;&#9;&#9;return nil, fmt.Errorf(&quot;error loading shared config: %w&quot;, err)&#13;&#10;&#9;}&#13;&#10;&#13;&#10;&#9;appConfig := &amp;AppConfig{&#13;&#10;&#9;&#9;Config: sharedConfig,&#13;&#10;&#9;}&#13;&#10;&#13;&#10;&#9;return appConfig, nil&#13;&#10;}&#13;&#10;&#13;&#10;// Legacy getter methods for backward compatibility&#13;&#10;func (c *AppConfig) GetDBHost() string {&#13;&#10;&#9;return c.PG.Host&#13;&#10;}&#13;&#10;&#13;&#10;func (c *AppConfig) GetDBPort() string {&#13;&#10;&#9;return c.PG.Port&#13;&#10;}&#13;&#10;&#13;&#10;func (c *AppConfig) GetDBUser() string {&#13;&#10;&#9;return c.PG.User&#13;&#10;}&#13;&#10;&#13;&#10;func (c *AppConfig) GetDBPassword() string {&#13;&#10;&#9;return c.PG.Password&#13;&#10;}&#13;&#10;&#13;&#10;func (c *AppConfig) GetDBName() string {&#13;&#10;&#9;return c.PG.Database&#13;&#10;}&#13;&#10;&#13;&#10;func (c *AppConfig) GetDBSSLMode() string {&#13;&#10;&#9;return c.PG.SSLMode&#13;&#10;}&#13;&#10;&#13;&#10;func (c *AppConfig) GetServerPort() string {&#13;&#10;&#9;return c.App.Port&#13;&#10;}&#13;&#10;&#13;&#10;func (c *AppConfig) GetServerHost() string {&#13;&#10;&#9;return c.App.Host&#13;&#10;}&#13;&#10;&#13;&#10;func (c *AppConfig) GetProductServiceURL() string {&#13;&#10;&#9;return c.Services.GetServiceURL(&quot;product&quot;)&#13;&#10;}&#13;&#10;&#13;&#10;func (c *AppConfig) GetLogLevel() string {&#13;&#10;&#9;return c.Log.Level&#13;&#10;}&#13;&#10;&#13;&#10;func (c *AppConfig) GetRedisHost() string {&#13;&#10;&#9;return c.Redis.Host&#13;&#10;}&#13;&#10;&#13;&#10;func (c *AppConfig) GetRedisPort() string {&#13;&#10;&#9;return c.Redis.Port&#13;&#10;}&#13;&#10;&#13;&#10;func (c *AppConfig) GetRedisPassword() string {&#13;&#10;&#9;return c.Redis.Password&#13;&#10;}&#13;&#10;&#13;&#10;func (c *AppConfig) GetEnvironment() string {&#13;&#10;&#9;return c.Environment&#13;&#10;}&#13;&#10;&#13;&#10;func (c *AppConfig) GetDatabaseURL() string {&#13;&#10;&#9;return fmt.Sprintf(&quot;host=%s user=%s password=%s dbname=%s port=%s sslmode=%s TimeZone=Asia/Shanghai&quot;,&#13;&#10;&#9;&#9;c.PG.Host, c.PG.User, c.PG.Password, c.PG.Database, c.PG.Port, c.PG.SSLMode)&#13;&#10;}&#13;&#10;&#13;&#10;func (c *AppConfig) GetServerAddress() string {&#13;&#10;&#9;return fmt.Sprintf(&quot;%s:%s&quot;, c.App.Host, c.App.Port)&#13;&#10;}&#13;&#10;&#13;&#10;func (c *AppConfig) IsProduction() bool {&#13;&#10;&#9;return c.Environment == &quot;production&quot;&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/internal/services/cart/internal/controller/cart_controller.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/internal/services/cart/internal/controller/cart_controller.go" />
              <option name="originalContent" value="package controller&#10;&#10;import (&#10;&#9;&quot;errors&quot;&#10;&#9;&quot;github.com/gin-gonic/gin&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/internal/pkg/logger&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/internal/pkg/rest&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/services/cart/internal&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/services/cart/internal/dto/request&quot;&#10;&#9;customErr &quot;github.com/hthinh24/go-store/services/cart/internal/errors&quot;&#10;&#9;&quot;net/http&quot;&#10;&#9;&quot;strconv&quot;&#10;)&#10;&#10;type CartController struct {&#10;&#9;logger      logger.Logger&#10;&#9;cartService internal.CartService&#10;}&#10;&#10;func NewCartController(logger logger.Logger, cartService internal.CartService) *CartController {&#10;&#9;return &amp;CartController{&#10;&#9;&#9;logger:      logger,&#10;&#9;&#9;cartService: cartService,&#10;&#9;}&#10;}&#10;&#10;func (c *CartController) GetCartItemsByUserID() func(c *gin.Context) {&#10;&#9;return func(ctx *gin.Context) {&#10;&#9;&#9;userID, err := c.getUserIDFromContext(ctx)&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;ctx.JSON(http.StatusUnauthorized, rest.NewErrorResponse(rest.UnauthorizedError, &quot;User not authenticated&quot;))&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#10;&#9;&#9;cartItems, err := c.cartService.FindCartItemsByCartID(userID)&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;c.handleCartError(ctx, err)&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#10;&#9;&#9;ctx.JSON(http.StatusOK, rest.NewAPIResponse(http.StatusOK, &quot;Get cart items by user id successfully&quot;, cartItems))&#10;&#9;}&#10;}&#10;&#10;func (c *CartController) AddItemToCart() func(c *gin.Context) {&#10;&#9;return func(ctx *gin.Context) {&#10;&#9;&#9;var item request.AddItemRequest&#10;&#9;&#9;if err := ctx.ShouldBindJSON(&amp;item); err != nil {&#10;&#9;&#9;&#9;ctx.JSON(http.StatusBadRequest, rest.NewErrorResponse(rest.BadRequestError, &quot;Invalid input&quot;))&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#10;&#9;&#9;userID, err := c.getUserIDFromContext(ctx)&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;ctx.JSON(http.StatusUnauthorized, rest.NewErrorResponse(rest.UnauthorizedError, err.Error()))&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#10;&#9;&#9;if err := c.cartService.AddItemToCart(userID, &amp;item); err != nil {&#10;&#9;&#9;&#9;c.handleCartError(ctx, err)&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#10;&#9;&#9;ctx.JSON(http.StatusCreated, rest.NewAPIResponse(http.StatusCreated, &quot;Item added to cart successfully&quot;, nil))&#10;&#9;}&#10;}&#10;&#10;func (c *CartController) UpdateItemQuantity() func(c *gin.Context) {&#10;&#9;return func(ctx *gin.Context) {&#10;&#9;&#9;var item request.UpdateItemQuantityRequest&#10;&#9;&#9;if err := ctx.ShouldBindJSON(&amp;item); err != nil {&#10;&#9;&#9;&#9;ctx.JSON(http.StatusBadRequest, rest.NewErrorResponse(rest.BadRequestError, &quot;Invalid input&quot;))&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#10;&#9;&#9;userID, err := c.getUserIDFromContext(ctx)&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;ctx.JSON(http.StatusUnauthorized, rest.NewErrorResponse(rest.UnauthorizedError, err.Error()))&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#10;&#9;&#9;if err := c.cartService.UpdateItemQuantity(userID, item.ItemID, item.Quantity); err != nil {&#10;&#9;&#9;&#9;c.handleCartError(ctx, err)&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#10;&#9;&#9;ctx.JSON(http.StatusOK, rest.NewAPIResponse(http.StatusOK, &quot;Item quantity updated successfully&quot;, nil))&#10;&#9;}&#10;}&#10;&#10;func (c *CartController) RemoveItemFromCart() func(c *gin.Context) {&#10;&#9;return func(ctx *gin.Context) {&#10;&#9;&#9;itemID := ctx.Param(&quot;item_id&quot;)&#10;&#9;&#9;itemIDInt, err := strconv.Atoi(itemID)&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;ctx.JSON(http.StatusBadRequest, rest.NewErrorResponse(rest.BadRequestError, &quot;Invalid item ID format&quot;))&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#10;&#9;&#9;userID, err := c.getUserIDFromContext(ctx)&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;ctx.JSON(http.StatusUnauthorized, rest.NewErrorResponse(rest.UnauthorizedError, err.Error()))&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#10;&#9;&#9;if err := c.cartService.RemoveItemFromCart(userID, int64(itemIDInt)); err != nil {&#10;&#9;&#9;&#9;c.handleCartError(ctx, err)&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#10;&#9;&#9;ctx.JSON(http.StatusOK, rest.NewAPIResponse(http.StatusOK, &quot;Item removed from cart successfully&quot;, nil))&#10;&#9;}&#10;}&#10;&#10;func (c *CartController) getUserIDFromContext(ctx *gin.Context) (int64, error) {&#10;&#9;userID, exists := ctx.Get(&quot;user_id&quot;)&#10;&#9;if !exists {&#10;&#9;&#9;return 0, errors.New(&quot;user ID not found in context&quot;)&#10;&#9;}&#10;&#10;&#9;userIDInt64, ok := userID.(int64)&#10;&#9;if !ok {&#10;&#9;&#9;return 0, errors.New(&quot;invalid user ID type&quot;)&#10;&#9;}&#10;&#10;&#9;return userIDInt64, nil&#10;}&#10;&#10;func (c *CartController) handleCartError(ctx *gin.Context, err error) {&#10;&#9;switch {&#10;&#9;case errors.Is(err, customErr.ErrCartNotFound):&#10;&#9;&#9;ctx.JSON(http.StatusNotFound, rest.NewErrorResponse(rest.NotFoundError, err.Error()))&#10;&#9;case errors.Is(err, customErr.ErrCartItemNotFound):&#10;&#9;&#9;ctx.JSON(http.StatusNotFound, rest.NewErrorResponse(rest.NotFoundError, err.Error()))&#10;&#9;case errors.Is(err, customErr.ErrCartItemAlreadyExists):&#10;&#9;&#9;ctx.JSON(http.StatusConflict, rest.NewErrorResponse(rest.ConflictError, err.Error()))&#10;&#9;default:&#10;&#9;&#9;ctx.JSON(http.StatusInternalServerError, rest.NewErrorResponse(rest.InternalServerErrorError, &quot;An unexpected error occurred&quot;))&#10;&#9;}&#10;}&#10;" />
              <option name="updatedContent" value="package controller&#13;&#10;&#13;&#10;import (&#13;&#10;&#9;&quot;errors&quot;&#13;&#10;&#9;&quot;github.com/gin-gonic/gin&quot;&#13;&#10;&#9;&quot;github.com/hthinh24/go-store/internal/pkg/logger&quot;&#13;&#10;&#9;&quot;github.com/hthinh24/go-store/internal/pkg/rest&quot;&#13;&#10;&#9;&quot;github.com/hthinh24/go-store/services/cart/internal&quot;&#13;&#10;&#9;&quot;github.com/hthinh24/go-store/services/cart/internal/dto/request&quot;&#13;&#10;&#9;customErr &quot;github.com/hthinh24/go-store/services/cart/internal/errors&quot;&#13;&#10;&#9;&quot;net/http&quot;&#13;&#10;&#9;&quot;strconv&quot;&#13;&#10;)&#13;&#10;&#13;&#10;type CartController struct {&#13;&#10;&#9;logger      logger.Logger&#13;&#10;&#9;cartService internal.CartService&#13;&#10;}&#13;&#10;&#13;&#10;func NewCartController(logger logger.Logger, cartService internal.CartService) *CartController {&#13;&#10;&#9;return &amp;CartController{&#13;&#10;&#9;&#9;logger:      logger,&#13;&#10;&#9;&#9;cartService: cartService,&#13;&#10;&#9;}&#13;&#10;}&#13;&#10;&#13;&#10;func (c *CartController) CreateCart() func(c *gin.Context) {&#13;&#10;&#9;return func(ctx *gin.Context) {&#13;&#10;&#9;&#9;var createCartRequest request.CreateCartRequest&#13;&#10;&#9;&#9;if err := ctx.ShouldBindJSON(&amp;createCartRequest); err != nil {&#13;&#10;&#9;&#9;&#9;c.logger.Error(&quot;Invalid create cart request&quot;, &quot;error&quot;, err)&#13;&#10;&#9;&#9;&#9;ctx.JSON(http.StatusBadRequest, rest.NewErrorResponse(rest.BadRequestError, &quot;Invalid input&quot;))&#13;&#10;&#9;&#9;&#9;return&#13;&#10;&#9;&#9;}&#13;&#10;&#13;&#10;&#9;&#9;cart, err := c.cartService.CreateCart(&amp;createCartRequest)&#13;&#10;&#9;&#9;if err != nil {&#13;&#10;&#9;&#9;&#9;c.handleCartError(ctx, err)&#13;&#10;&#9;&#9;&#9;return&#13;&#10;&#9;&#9;}&#13;&#10;&#13;&#10;&#9;&#9;ctx.JSON(http.StatusCreated, rest.NewAPIResponse(http.StatusCreated, &quot;Cart created successfully&quot;, cart))&#13;&#10;&#9;}&#13;&#10;}&#13;&#10;&#13;&#10;func (c *CartController) GetCartItemsByUserID() func(c *gin.Context) {&#13;&#10;&#9;return func(ctx *gin.Context) {&#13;&#10;&#9;&#9;userID, err := c.getUserIDFromContext(ctx)&#13;&#10;&#9;&#9;if err != nil {&#13;&#10;&#9;&#9;&#9;ctx.JSON(http.StatusUnauthorized, rest.NewErrorResponse(rest.UnauthorizedError, &quot;User not authenticated&quot;))&#13;&#10;&#9;&#9;&#9;return&#13;&#10;&#9;&#9;}&#13;&#10;&#13;&#10;&#9;&#9;cartItems, err := c.cartService.FindCartItemsByCartID(userID)&#13;&#10;&#9;&#9;if err != nil {&#13;&#10;&#9;&#9;&#9;c.handleCartError(ctx, err)&#13;&#10;&#9;&#9;&#9;return&#13;&#10;&#9;&#9;}&#13;&#10;&#13;&#10;&#9;&#9;ctx.JSON(http.StatusOK, rest.NewAPIResponse(http.StatusOK, &quot;Get cart items by user id successfully&quot;, cartItems))&#13;&#10;&#9;}&#13;&#10;}&#13;&#10;&#13;&#10;func (c *CartController) AddItemToCart() func(c *gin.Context) {&#13;&#10;&#9;return func(ctx *gin.Context) {&#13;&#10;&#9;&#9;var item request.AddItemRequest&#13;&#10;&#9;&#9;if err := ctx.ShouldBindJSON(&amp;item); err != nil {&#13;&#10;&#9;&#9;&#9;ctx.JSON(http.StatusBadRequest, rest.NewErrorResponse(rest.BadRequestError, &quot;Invalid input&quot;))&#13;&#10;&#9;&#9;&#9;return&#13;&#10;&#9;&#9;}&#13;&#10;&#13;&#10;&#9;&#9;userID, err := c.getUserIDFromContext(ctx)&#13;&#10;&#9;&#9;if err != nil {&#13;&#10;&#9;&#9;&#9;ctx.JSON(http.StatusUnauthorized, rest.NewErrorResponse(rest.UnauthorizedError, err.Error()))&#13;&#10;&#9;&#9;&#9;return&#13;&#10;&#9;&#9;}&#13;&#10;&#13;&#10;&#9;&#9;if err := c.cartService.AddItemToCart(userID, &amp;item); err != nil {&#13;&#10;&#9;&#9;&#9;c.handleCartError(ctx, err)&#13;&#10;&#9;&#9;&#9;return&#13;&#10;&#9;&#9;}&#13;&#10;&#13;&#10;&#9;&#9;ctx.JSON(http.StatusCreated, rest.NewAPIResponse(http.StatusCreated, &quot;Item added to cart successfully&quot;, nil))&#13;&#10;&#9;}&#13;&#10;}&#13;&#10;&#13;&#10;func (c *CartController) UpdateItemQuantity() func(c *gin.Context) {&#13;&#10;&#9;return func(ctx *gin.Context) {&#13;&#10;&#9;&#9;var item request.UpdateItemQuantityRequest&#13;&#10;&#9;&#9;if err := ctx.ShouldBindJSON(&amp;item); err != nil {&#13;&#10;&#9;&#9;&#9;ctx.JSON(http.StatusBadRequest, rest.NewErrorResponse(rest.BadRequestError, &quot;Invalid input&quot;))&#13;&#10;&#9;&#9;&#9;return&#13;&#10;&#9;&#9;}&#13;&#10;&#13;&#10;&#9;&#9;userID, err := c.getUserIDFromContext(ctx)&#13;&#10;&#9;&#9;if err != nil {&#13;&#10;&#9;&#9;&#9;ctx.JSON(http.StatusUnauthorized, rest.NewErrorResponse(rest.UnauthorizedError, err.Error()))&#13;&#10;&#9;&#9;&#9;return&#13;&#10;&#9;&#9;}&#13;&#10;&#13;&#10;&#9;&#9;if err := c.cartService.UpdateItemQuantity(userID, item.ItemID, item.Quantity); err != nil {&#13;&#10;&#9;&#9;&#9;c.handleCartError(ctx, err)&#13;&#10;&#9;&#9;&#9;return&#13;&#10;&#9;&#9;}&#13;&#10;&#13;&#10;&#9;&#9;ctx.JSON(http.StatusOK, rest.NewAPIResponse(http.StatusOK, &quot;Item quantity updated successfully&quot;, nil))&#13;&#10;&#9;}&#13;&#10;}&#13;&#10;&#13;&#10;func (c *CartController) RemoveItemFromCart() func(c *gin.Context) {&#13;&#10;&#9;return func(ctx *gin.Context) {&#13;&#10;&#9;&#9;itemID := ctx.Param(&quot;item_id&quot;)&#13;&#10;&#9;&#9;itemIDInt, err := strconv.Atoi(itemID)&#13;&#10;&#9;&#9;if err != nil {&#13;&#10;&#9;&#9;&#9;ctx.JSON(http.StatusBadRequest, rest.NewErrorResponse(rest.BadRequestError, &quot;Invalid item ID format&quot;))&#13;&#10;&#9;&#9;&#9;return&#13;&#10;&#9;&#9;}&#13;&#10;&#13;&#10;&#9;&#9;userID, err := c.getUserIDFromContext(ctx)&#13;&#10;&#9;&#9;if err != nil {&#13;&#10;&#9;&#9;&#9;ctx.JSON(http.StatusUnauthorized, rest.NewErrorResponse(rest.UnauthorizedError, err.Error()))&#13;&#10;&#9;&#9;&#9;return&#13;&#10;&#9;&#9;}&#13;&#10;&#13;&#10;&#9;&#9;if err := c.cartService.RemoveItemFromCart(userID, int64(itemIDInt)); err != nil {&#13;&#10;&#9;&#9;&#9;c.handleCartError(ctx, err)&#13;&#10;&#9;&#9;&#9;return&#13;&#10;&#9;&#9;}&#13;&#10;&#13;&#10;&#9;&#9;ctx.JSON(http.StatusOK, rest.NewAPIResponse(http.StatusOK, &quot;Item removed from cart successfully&quot;, nil))&#13;&#10;&#9;}&#13;&#10;}&#13;&#10;&#13;&#10;func (c *CartController) getUserIDFromContext(ctx *gin.Context) (int64, error) {&#13;&#10;&#9;userID, exists := ctx.Get(&quot;user_id&quot;)&#13;&#10;&#9;if !exists {&#13;&#10;&#9;&#9;return 0, errors.New(&quot;user ID not found in context&quot;)&#13;&#10;&#9;}&#13;&#10;&#13;&#10;&#9;userIDInt64, ok := userID.(int64)&#13;&#10;&#9;if !ok {&#13;&#10;&#9;&#9;return 0, errors.New(&quot;invalid user ID type&quot;)&#13;&#10;&#9;}&#13;&#10;&#13;&#10;&#9;return userIDInt64, nil&#13;&#10;}&#13;&#10;&#13;&#10;func (c *CartController) handleCartError(ctx *gin.Context, err error) {&#13;&#10;&#9;switch {&#13;&#10;&#9;case errors.Is(err, customErr.ErrCartNotFound):&#13;&#10;&#9;&#9;ctx.JSON(http.StatusNotFound, rest.NewErrorResponse(rest.NotFoundError, err.Error()))&#13;&#10;&#9;case errors.Is(err, customErr.ErrCartItemNotFound):&#13;&#10;&#9;&#9;ctx.JSON(http.StatusNotFound, rest.NewErrorResponse(rest.NotFoundError, err.Error()))&#13;&#10;&#9;case errors.Is(err, customErr.ErrCartItemAlreadyExists):&#13;&#10;&#9;&#9;ctx.JSON(http.StatusConflict, rest.NewErrorResponse(rest.ConflictError, err.Error()))&#13;&#10;&#9;default:&#13;&#10;&#9;&#9;ctx.JSON(http.StatusInternalServerError, rest.NewErrorResponse(rest.InternalServerErrorError, &quot;An unexpected error occurred&quot;))&#13;&#10;&#9;}&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/internal/services/cart/internal/entity/cart_item.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/internal/services/cart/internal/entity/cart_item.go" />
              <option name="originalContent" value="package entity&#10;&#10;import (&#10;&#9;&quot;github.com/hthinh24/go-store/internal/pkg/entity&quot;&#10;)&#10;&#10;type CartItem struct {&#10;&#9;entity.BaseEntity&#10;&#9;CartID       int64   `json:&quot;cart_id&quot; gorm:&quot;column:cart_id;not null&quot;`&#10;&#9;ProductID    int64   `json:&quot;product_id&quot; gorm:&quot;column:product_id;not null&quot;`&#10;&#9;ProductSKUID int64   `json:&quot;product_sku_id&quot; gorm:&quot;column:product_sku_id;not null&quot;`&#10;&#9;Quantity     int     `json:&quot;quantity&quot; gorm:&quot;column:quantity;not null;default:1&quot;`&#10;&#9;UnitPrice    float64 `json:&quot;unit_price&quot; gorm:&quot;column:unit_price;not null;type:decimal(10,2)&quot;`&#10;&#9;TotalPrice   float64 `json:&quot;total_price&quot; gorm:&quot;column:total_price;not null;type:decimal(10,2) &lt;-:false&quot;`&#10;&#9;Status       string  `json:&quot;status&quot; gorm:&quot;column:status;not null;default:ACTIVE&quot;`&#10;}&#10;&#10;func (ci CartItem) TableName() string {&#10;&#9;return &quot;cart_item&quot;&#10;}&#10;" />
              <option name="updatedContent" value="package entity&#10;&#10;import (&#10;&#9;&quot;github.com/hthinh24/go-store/internal/pkg/entity&quot;&#10;)&#10;&#10;type CartItem struct {&#10;&#9;entity.BaseEntity&#10;&#9;CartID       int64   `json:&quot;cart_id&quot; gorm:&quot;column:cart_id;not null&quot;`&#10;&#9;ProductID    int64   `json:&quot;product_id&quot; gorm:&quot;column:product_id;not null&quot;`&#10;&#9;ProductSKUID int64   `json:&quot;product_sku_id&quot; gorm:&quot;column:product_sku_id;not null&quot;`&#10;&#9;Quantity     int     `json:&quot;quantity&quot; gorm:&quot;column:quantity;not null;default:1&quot;`&#10;&#9;UnitPrice    float64 `json:&quot;unit_price&quot; gorm:&quot;column:unit_price;not null;type:decimal(10,2)&quot;`&#10;&#9;TotalPrice   float64 `json:&quot;total_price&quot; gorm:&quot;column:total_price;type:decimal(10,2);-&gt;:false;&lt;-:false&quot;`&#10;&#9;Status       string  `json:&quot;status&quot; gorm:&quot;column:status;not null;default:ACTIVE&quot;`&#10;}&#10;&#10;func (ci CartItem) TableName() string {&#10;&#9;return &quot;cart_item&quot;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/internal/services/gateway/cmd/main.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/internal/services/gateway/cmd/main.go" />
              <option name="originalContent" value="package main&#10;&#10;import (&#10;&#9;&quot;log&quot;&#10;&#10;&#9;&quot;github.com/gin-gonic/gin&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/internal/pkg/logger&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/services/gateway/internal/config&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/services/gateway/internal/router&quot;&#10;)&#10;&#10;func main() {&#10;&#9;fileName := &quot;.env&quot;&#10;&#10;&#9;// Load configuration&#10;&#9;cfg, _ := config.LoadConfig(fileName)&#10;&#10;&#9;// Initialize logger&#10;&#9;appLogger := logger.WithComponent(&quot;info&quot;, &quot;GATEWAY&quot;)&#10;&#10;&#9;// Create gateway&#10;&#9;gateway := router.NewGateway(cfg, appLogger)&#10;&#10;&#9;// Setup gin router&#10;&#9;r := gin.Default()&#10;&#10;&#9;// Setup routes&#10;&#9;gateway.SetupRoutes(r)&#10;&#10;&#9;// Start server&#10;&#9;appLogger.Info(&quot;Starting Gateway on port&quot;, cfg.Port)&#10;&#9;if err := r.Run(&quot;:&quot; + cfg.Port); err != nil {&#10;&#9;&#9;log.Fatal(&quot;Failed to start server:&quot;, err)&#10;&#9;}&#10;}&#10;" />
              <option name="updatedContent" value="package main&#13;&#10;&#13;&#10;import (&#13;&#10;&#9;&quot;log&quot;&#13;&#10;&#13;&#10;&#9;&quot;github.com/gin-gonic/gin&quot;&#13;&#10;&#9;&quot;github.com/hthinh24/go-store/internal/pkg/logger&quot;&#13;&#10;&#9;&quot;github.com/hthinh24/go-store/internal/services/gateway/internal/config&quot;&#13;&#10;&#9;&quot;github.com/hthinh24/go-store/internal/services/gateway/internal/router&quot;&#13;&#10;)&#13;&#10;&#13;&#10;func main() {&#13;&#10;&#9;configPath := &quot;config.yaml&quot;&#13;&#10;&#13;&#10;&#9;// Load configuration using shared pkg config&#13;&#10;&#9;cfg, err := config.LoadConfig(configPath)&#13;&#10;&#9;if err != nil {&#13;&#10;&#9;&#9;log.Fatal(&quot;Failed to load config:&quot;, err)&#13;&#10;&#9;}&#13;&#10;&#13;&#10;&#9;// Initialize logger&#13;&#10;&#9;appLogger := logger.WithComponent(cfg.Log.Level, &quot;GATEWAY&quot;)&#13;&#10;&#13;&#10;&#9;// Create gateway&#13;&#10;&#9;gateway := router.NewGateway(cfg, appLogger)&#13;&#10;&#13;&#10;&#9;// Setup gin router&#13;&#10;&#9;r := gin.Default()&#13;&#10;&#13;&#10;&#9;// Setup routes&#13;&#10;&#9;gateway.SetupRoutes(r)&#13;&#10;&#13;&#10;&#9;// Start server&#13;&#10;&#9;appLogger.Info(&quot;Starting Gateway on port&quot;, cfg.GetPort())&#13;&#10;&#9;if err := r.Run(cfg.GetServerAddress()); err != nil {&#13;&#10;&#9;&#9;log.Fatal(&quot;Failed to start server:&quot;, err)&#13;&#10;&#9;}&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/internal/services/gateway/config.yaml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/internal/services/gateway/config.yaml" />
              <option name="originalContent" value="environment: &quot;development&quot;&#10;service_name: &quot;gateway&quot;&#10;&#10;# Application Configuration (host and port are here, not in http)&#10;app:&#10;  host: &quot;localhost&quot;&#10;  port: &quot;8000&quot;&#10;&#10;# HTTP Server Configuration (no host/port here - different fields)&#10;http:&#10;  read_timeout: 10&#10;  write_timeout: 10&#10;  max_header_bytes: 1048576&#10;  allowed_origins: &quot;*&quot;&#10;  allowed_methods: &quot;GET,POST,PUT,DELETE,OPTIONS&quot;&#10;  allowed_headers: &quot;Content-Type,Authorization&quot;&#10;  exposed_headers: &quot;&quot;&#10;  allow_credentials: true&#10;&#10;# Logging Configuration&#10;log:&#10;  level: &quot;info&quot;&#10;  format: &quot;json&quot;&#10;  output: &quot;stdout&quot;&#10;  file_path: &quot;&quot;&#10;  max_size: 10&#10;  max_backups: 3&#10;  max_age: 28&#10;  compress: true&#10;&#10;# Services Configuration for inter-service communication&#10;services:&#10;  identity_service_url: &quot;http://localhost:8080&quot;&#10;  product_service_url: &quot;http://localhost:8081&quot;&#10;  cart_service_url: &quot;http://localhost:8082&quot;&#10;  order_service_url: &quot;http://localhost:8083&quot;&#10;  gateway_service_url: &quot;http://localhost:8000&quot;&#10;  notification_service_url: &quot;http://localhost:8084&quot;&#10;  payment_service_url: &quot;http://localhost:8085&quot;&#10;&#10;# JWT Configuration for token validation (different field names)&#10;jwt:&#10;  secret: &quot;${JWT_SECRET:your-secret-key}&quot;&#10;  expiration: &quot;24h&quot;&#10;  issuer: &quot;gostore-gateway&quot;&#10;  audience: &quot;gostore-users&quot;&#10;" />
              <option name="updatedContent" value="environment: &quot;development&quot;&#13;&#10;service_name: &quot;gateway&quot;&#13;&#10;&#13;&#10;# Application Configuration (host and port are here, not in http)&#13;&#10;app:&#13;&#10;  host: &quot;localhost&quot;&#13;&#10;  port: &quot;8000&quot;&#13;&#10;&#13;&#10;# HTTP Server Configuration (no host/port here - different fields)&#13;&#10;http:&#13;&#10;  read_timeout: 10&#13;&#10;  write_timeout: 10&#13;&#10;  max_header_bytes: 1048576&#13;&#10;  allowed_origins: &quot;*&quot;&#13;&#10;  allowed_methods: &quot;GET,POST,PUT,DELETE,OPTIONS&quot;&#13;&#10;  allowed_headers: &quot;Content-Type,Authorization&quot;&#13;&#10;  exposed_headers: &quot;&quot;&#13;&#10;  allow_credentials: true&#13;&#10;&#13;&#10;# Logging Configuration&#13;&#10;log:&#13;&#10;  level: &quot;info&quot;&#13;&#10;  format: &quot;json&quot;&#13;&#10;  output: &quot;stdout&quot;&#13;&#10;  file_path: &quot;&quot;&#13;&#10;  max_size: 10&#13;&#10;  max_backups: 3&#13;&#10;  max_age: 28&#13;&#10;  compress: true&#13;&#10;&#13;&#10;# Services Configuration for inter-service communication&#13;&#10;services:&#13;&#10;  identity_service_url: &quot;http://localhost:8080&quot;&#13;&#10;  product_service_url: &quot;http://localhost:8081&quot;&#13;&#10;  cart_service_url: &quot;http://localhost:8082&quot;&#13;&#10;  order_service_url: &quot;http://localhost:8083&quot;&#13;&#10;  gateway_service_url: &quot;http://localhost:8000&quot;&#13;&#10;  notification_service_url: &quot;http://localhost:8084&quot;&#13;&#10;  payment_service_url: &quot;http://localhost:8085&quot;&#13;&#10;&#13;&#10;# JWT Configuration for token validation (using proper defaults)&#13;&#10;jwt:&#13;&#10;  secret: &quot;your-secret-key&quot;&#13;&#10;  expiration: &quot;24h&quot;&#13;&#10;  issuer: &quot;gostore-gateway&quot;&#13;&#10;  audience: &quot;gostore-users&quot;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/internal/services/gateway/internal/config/config.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/internal/services/gateway/internal/config/config.go" />
              <option name="originalContent" value="package config&#10;&#10;import (&#10;&#9;&quot;fmt&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/internal/pkg/config&quot;&#10;)&#10;&#10;const (&#10;&#9;ApiVersionV1 = &quot;api/v1&quot;&#10;&#9;ApiVersionV2 = &quot;api/v2&quot;&#10;)&#10;&#10;type GatewayConfig struct {&#10;&#9;*config.Config&#10;}&#10;&#10;func LoadConfig(configPath string) (*GatewayConfig, error) {&#10;&#9;// Load shared configuration from pkg&#10;&#9;sharedConfig, err := config.LoadConfig(configPath)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, fmt.Errorf(&quot;error loading shared config: %w&quot;, err)&#10;&#9;}&#10;&#10;&#9;gatewayConfig := &amp;GatewayConfig{&#10;&#9;&#9;Config: sharedConfig,&#10;&#9;}&#10;&#10;&#9;return gatewayConfig, nil&#10;}&#10;&#10;func (c *GatewayConfig) GetServerAddress() string {&#10;&#9;return fmt.Sprintf(&quot;%s:%s&quot;, c.App.Host, c.App.Port)&#10;}&#10;&#10;// Legacy methods for backward compatibility&#10;func (c *GatewayConfig) GetPort() string {&#10;&#9;return c.App.Port&#10;}&#10;&#10;func (c *GatewayConfig) GetIdentityServiceURL() string {&#10;&#9;return c.Services.GetServiceURL(&quot;identity&quot;)&#10;}&#10;&#10;func (c *GatewayConfig) GetProductServiceURL() string {&#10;&#9;return c.Services.GetServiceURL(&quot;product&quot;)&#10;}&#10;&#10;func (c *GatewayConfig) GetCartServiceURL() string {&#10;&#9;return c.Services.GetServiceURL(&quot;cart&quot;)&#10;}&#10;" />
              <option name="updatedContent" value="package config&#10;&#10;import (&#10;&#9;&quot;fmt&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/internal/pkg/config&quot;&#10;)&#10;&#10;const (&#10;&#9;ApiVersionV1 = &quot;api/v1&quot;&#10;&#9;ApiVersionV2 = &quot;api/v2&quot;&#10;)&#10;&#10;type GatewayConfig struct {&#10;&#9;*config.Config&#10;}&#10;&#10;func LoadConfig(configPath string) (*GatewayConfig, error) {&#10;&#9;// Load shared configuration from pkg&#10;&#9;sharedConfig, err := config.LoadConfig(configPath)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, fmt.Errorf(&quot;error loading shared config: %w&quot;, err)&#10;&#9;}&#10;&#10;&#9;gatewayConfig := &amp;GatewayConfig{&#10;&#9;&#9;Config: sharedConfig,&#10;&#9;}&#10;&#10;&#9;return gatewayConfig, nil&#10;}&#10;&#10;func (c *GatewayConfig) GetServerAddress() string {&#10;&#9;return &quot;:&quot; + c.App.Port // Updated to use App.Port instead of HTTP.Port&#10;}&#10;&#10;// Legacy methods for backward compatibility&#10;func (c *GatewayConfig) GetPort() string {&#10;&#9;return c.App.Port // Updated to use App.Port&#10;}&#10;&#10;func (c *GatewayConfig) GetIdentityServiceURL() string {&#10;&#9;return c.Services.GetServiceURL(&quot;identity&quot;)&#10;}&#10;&#10;func (c *GatewayConfig) GetProductServiceURL() string {&#10;&#9;return c.Services.GetServiceURL(&quot;product&quot;)&#10;}&#10;&#10;func (c *GatewayConfig) GetCartServiceURL() string {&#10;&#9;return c.Services.GetServiceURL(&quot;cart&quot;)&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/internal/services/identity/cmd/main.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/internal/services/identity/cmd/main.go" />
              <option name="originalContent" value="package main&#10;&#10;import (&#10;&#9;&quot;errors&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/services/identity&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/services/identity/internal/config&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/services/identity/internal/constants&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/services/identity/internal/controller/http/client&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/services/identity/internal/controller/http/v1&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/services/identity/internal/entity&quot;&#10;&#9;customErr &quot;github.com/hthinh24/go-store/services/identity/internal/errors&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/services/identity/internal/middleware&quot;&#10;&#9;repository &quot;github.com/hthinh24/go-store/services/identity/internal/repository/postgres&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/services/identity/internal/service&quot;&#10;&#9;&quot;golang.org/x/crypto/bcrypt&quot;&#10;&#9;&quot;gorm.io/driver/postgres&quot;&#10;&#9;&quot;log&quot;&#10;&#9;&quot;time&quot;&#10;&#10;&#9;&quot;github.com/gin-gonic/gin&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/internal/pkg/logger&quot;&#10;&#9;&quot;gorm.io/gorm&quot;&#10;)&#10;&#10;func main() {&#10;&#9;// Load configuration from environment variables&#10;&#9;cfg, err := config.LoadConfig(&quot;.env&quot;)&#10;&#9;if err != nil {&#10;&#9;&#9;log.Fatalf(&quot;Failed to load config: %v&quot;, err)&#10;&#9;}&#10;&#10;&#9;// Initialize logger&#10;&#9;appLogger := logger.NewAppLogger(cfg.LogLevel)&#10;&#9;appLogger.Info(&quot;Starting Identity Service...&quot;)&#10;&#9;appLogger.Info(&quot;Environment: %s&quot;, cfg.Environment)&#10;&#10;&#9;// Initialize database connection&#10;&#9;db, err := initDatabase(cfg)&#10;&#9;if err != nil {&#10;&#9;&#9;appLogger.Error(&quot;Failed to connect to database: %v&quot;, err)&#10;&#9;&#9;log.Fatal(err)&#10;&#9;}&#10;&#9;appLogger.Info(&quot;Database connected successfully&quot;)&#10;&#10;&#9;// Initialize repositories&#10;&#9;userRepo := repository.NewUserRepository(logger.WithComponent(cfg.LogLevel, &quot;USER-REPOSITORY&quot;), db)&#10;&#9;authRepo := repository.NewAuthRepository(logger.WithComponent(cfg.LogLevel, &quot;AUTH-REPOSITORY&quot;), db)&#10;&#10;&#9;// Initialize external service clients&#10;&#9;var cartClient client.CartClient&#10;&#9;if cfg.CartServiceURL != &quot;&quot; {&#10;&#9;&#9;cartClient = client.NewCartClient(cfg.CartServiceURL)&#10;&#9;&#9;appLogger.Info(&quot;Cart service client initialized with URL: %s&quot;, cfg.CartServiceURL)&#10;&#9;} else {&#10;&#9;&#9;appLogger.Warn(&quot;Cart service URL not configured, cart creation will be skipped&quot;)&#10;&#9;&#9;cartClient = client.NewCartClient(&quot;&quot;) // This will effectively disable cart creation&#10;&#9;}&#10;&#10;&#9;// Initialize services&#10;&#9;authService := service.NewAuthService(logger.WithComponent(cfg.LogLevel, &quot;AUTH-SERVICE&quot;), userRepo, authRepo, cfg)&#10;&#9;userService := service.NewUserService(logger.WithComponent(cfg.LogLevel, &quot;USER-SERVICE&quot;), userRepo, authRepo, cartClient)&#10;&#10;&#9;// Initialize middleware&#10;&#9;authMiddleware := middleware.NewAuthMiddleware(logger.WithComponent(cfg.LogLevel, &quot;AUTH-MIDDLEWARE&quot;), cfg.JWTSecret)&#10;&#10;&#9;// Initialize controllers&#10;&#9;authController := v1.NewAuthController(logger.WithComponent(cfg.LogLevel, &quot;AUTH-CONTROLLER&quot;), authService)&#10;&#9;userController := v1.NewUserController(logger.WithComponent(cfg.LogLevel, &quot;USER-CONTROLLER&quot;), userService)&#10;&#10;&#9;// Setup router&#10;&#9;router := setupRouter(authController, userController, authMiddleware)&#10;&#10;&#9;// Initialize user data&#10;&#9;if err := initUserData(userRepo, authRepo); err != nil {&#10;&#9;&#9;appLogger.Error(&quot;Failed to initialize user data: %v&quot;, err)&#10;&#9;&#9;log.Fatal(err)&#10;&#9;} else {&#10;&#9;&#9;appLogger.Info(&quot;User data initialized successfully&quot;)&#10;&#9;}&#10;&#10;&#9;// Start server&#10;&#9;serverAddr := cfg.GetServerAddress()&#10;&#9;appLogger.Info(&quot;Server starting on %s&quot;, serverAddr)&#10;&#9;if err := router.Run(serverAddr); err != nil {&#10;&#9;&#9;appLogger.Error(&quot;Failed to start server: %v&quot;, err)&#10;&#9;&#9;log.Fatal(err)&#10;&#9;}&#10;}&#10;&#10;func initDatabase(cfg *config.AppConfig) (*gorm.DB, error) {&#10;&#9;db, err := gorm.Open(postgres.Open(cfg.GetDatabaseURL()), &amp;gorm.Config{})&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;return db, nil&#10;}&#10;&#10;func setupRouter(authController *v1.AuthController, userController *v1.UserController, authMiddleware *middleware.AuthMiddleware) *gin.Engine {&#10;&#9;router := gin.Default()&#10;&#10;&#9;// Health check endpoint&#10;&#9;router.GET(&quot;/health&quot;, func(c *gin.Context) {&#10;&#9;&#9;c.JSON(200, gin.H{&quot;status&quot;: &quot;healthy&quot;})&#10;&#9;})&#10;&#10;&#9;// API routes&#10;&#9;api := router.Group(&quot;/api/v1&quot;)&#10;&#9;{&#10;&#9;&#9;auth := api.Group(&quot;/auth&quot;)&#10;&#9;&#9;users := api.Group(&quot;/users&quot;)&#10;&#10;&#9;&#9;// Public routes&#10;&#9;&#9;{&#10;&#9;&#9;&#9;users.POST(&quot;&quot;, userController.CreateUser())&#10;&#10;&#9;&#9;&#9;auth.POST(&quot;/login&quot;, authController.Login())&#10;&#9;&#9;&#9;auth.GET(&quot;/verify&quot;, authController.Verify())&#10;&#9;&#9;}&#10;&#10;&#9;&#9;auth.Use(authMiddleware.AuthRequired())&#10;&#9;&#9;{&#10;&#9;&#9;&#9;// TODO - Create login, register, logout endpoints&#10;&#9;&#9;&#9;//auth.POST(&quot;/register&quot;, authController.Register())&#10;&#9;&#9;&#9;//auth.POST(&quot;/logout&quot;, authMiddleware.AuthRequired(), authController.Logout())&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// User routes (protected)&#10;&#9;&#9;users.Use(authMiddleware.AuthRequired())&#10;&#9;&#9;{&#10;&#9;&#9;&#9;users.GET(&quot;:id&quot;, userController.GetUserByID())&#10;&#10;&#9;&#9;&#9;users.PUT(&quot;/:id/profile&quot;, userController.UpdateUserProfile())&#10;&#9;&#9;&#9;users.PATCH(&quot;/:id/register-merchant&quot;,&#10;&#9;&#9;&#9;&#9;userController.UpdateToMerchantAccount())&#10;&#9;&#9;&#9;users.PATCH(&quot;/:id/password&quot;, userController.UpdateUserPassword())&#10;&#9;&#9;&#9;users.DELETE(&quot;/:id&quot;, userController.DeleteUser())&#10;&#10;&#9;&#9;&#9;// Admin only routes&#10;&#9;&#9;&#9;users.GET(&quot;&quot;, authMiddleware.RequireRole(&quot;admin&quot;), userController.GetUsers())&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;return router&#10;}&#10;&#10;func initUserData(userRepository identity.UserRepository, authRepository identity.AuthRepository) error {&#10;&#9;user, err := userRepository.FindUserByID(1)&#10;&#9;if user != nil {&#10;&#9;&#9;return nil&#10;&#9;}&#10;&#10;&#9;// Create admin user if it does not exist&#10;&#9;if errors.Is(err, customErr.ErrUserNotFound{}) {&#10;&#9;&#9;user = createAdminUser()&#10;&#9;&#9;if err := userRepository.CreateUser(user); err != nil {&#10;&#9;&#9;&#9;return err&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;// Assign admin role to the user&#10;&#9;role, err := authRepository.FindRoleByName(string(constants.RoleAdmin))&#10;&#9;if err != nil {&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;adminRole := entity.UserRoles{&#10;&#9;&#9;UserID: user.ID,&#10;&#9;&#9;RoleID: role.ID,&#10;&#9;}&#10;&#10;&#9;if err := authRepository.AddRoleToUser(&amp;adminRole); err != nil {&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;log.Printf(&quot;Admin user initialized: %s&quot;, user.Email)&#10;&#9;return nil&#10;}&#10;&#10;func createAdminUser() *entity.User {&#10;&#9;password := &quot;admin&quot;&#10;&#9;hashedPassword, _ := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)&#10;&#10;&#9;return &amp;entity.User{&#10;&#9;&#9;Email:        &quot;test@gmail.com&quot;,&#10;&#9;&#9;Password:     string(hashedPassword),&#10;&#9;&#9;ProviderID:   &quot;1&quot;,&#10;&#9;&#9;ProviderName: &quot;app&quot;,&#10;&#9;&#9;LastName:     &quot;Admin&quot;,&#10;&#9;&#9;FirstName:    &quot;Admin&quot;,&#10;&#9;&#9;Avatar:       &quot;https://example.com/avatar.png&quot;,&#10;&#9;&#9;Gender:       string(constants.GenderOther),&#10;&#9;&#9;PhoneNumber:  &quot;1234567890&quot;,&#10;&#9;&#9;DateOfBirth:  time.Now(),&#10;&#9;&#9;Status:       string(constants.UserStatusActive),&#10;&#9;}&#10;}&#10;" />
              <option name="updatedContent" value="package main&#13;&#10;&#13;&#10;import (&#13;&#10;&#9;&quot;errors&quot;&#13;&#10;&#9;&quot;github.com/hthinh24/go-store/services/identity&quot;&#13;&#10;&#9;&quot;github.com/hthinh24/go-store/internal/services/identity/internal/config&quot;&#13;&#10;&#9;&quot;github.com/hthinh24/go-store/internal/services/identity/internal/constants&quot;&#13;&#10;&#9;&quot;github.com/hthinh24/go-store/internal/services/identity/internal/controller/http/client&quot;&#13;&#10;&#9;&quot;github.com/hthinh24/go-store/internal/services/identity/internal/controller/http/v1&quot;&#13;&#10;&#9;&quot;github.com/hthinh24/go-store/internal/services/identity/internal/entity&quot;&#13;&#10;&#9;customErr &quot;github.com/hthinh24/go-store/internal/services/identity/internal/errors&quot;&#13;&#10;&#9;&quot;github.com/hthinh24/go-store/internal/services/identity/internal/middleware&quot;&#13;&#10;&#9;repository &quot;github.com/hthinh24/go-store/internal/services/identity/internal/repository/postgres&quot;&#13;&#10;&#9;&quot;github.com/hthinh24/go-store/internal/services/identity/internal/service&quot;&#13;&#10;&#9;&quot;golang.org/x/crypto/bcrypt&quot;&#13;&#10;&#9;&quot;gorm.io/driver/postgres&quot;&#13;&#10;&#9;&quot;log&quot;&#13;&#10;&#9;&quot;time&quot;&#13;&#10;&#13;&#10;&#9;&quot;github.com/gin-gonic/gin&quot;&#13;&#10;&#9;&quot;github.com/hthinh24/go-store/internal/pkg/logger&quot;&#13;&#10;&#9;&quot;gorm.io/gorm&quot;&#13;&#10;)&#13;&#10;&#13;&#10;func main() {&#13;&#10;&#9;configPath := &quot;config.yaml&quot;&#13;&#10;&#13;&#10;&#9;// Load configuration using shared pkg config&#13;&#10;&#9;cfg, err := config.LoadConfig(configPath)&#13;&#10;&#9;if err != nil {&#13;&#10;&#9;&#9;log.Fatalf(&quot;Failed to load config: %v&quot;, err)&#13;&#10;&#9;}&#13;&#10;&#13;&#10;&#9;// Initialize logger&#13;&#10;&#9;appLogger := logger.NewAppLogger(cfg.GetLogLevel())&#13;&#10;&#9;appLogger.Info(&quot;Starting Identity Service...&quot;)&#13;&#10;&#9;appLogger.Info(&quot;Environment: %s&quot;, cfg.GetEnvironment())&#13;&#10;&#13;&#10;&#9;// Initialize database connection&#13;&#10;&#9;db, err := initDatabase(cfg)&#13;&#10;&#9;if err != nil {&#13;&#10;&#9;&#9;appLogger.Error(&quot;Failed to connect to database: %v&quot;, err)&#13;&#10;&#9;&#9;log.Fatal(err)&#13;&#10;&#9;}&#13;&#10;&#9;appLogger.Info(&quot;Database connected successfully&quot;)&#13;&#10;&#13;&#10;&#9;// Initialize repositories&#13;&#10;&#9;userRepo := repository.NewUserRepository(logger.WithComponent(cfg.GetLogLevel(), &quot;USER-REPOSITORY&quot;), db)&#13;&#10;&#9;authRepo := repository.NewAuthRepository(logger.WithComponent(cfg.GetLogLevel(), &quot;AUTH-REPOSITORY&quot;), db)&#13;&#10;&#13;&#10;&#9;// Initialize external service clients&#13;&#10;&#9;var cartClient client.CartClient&#13;&#10;&#9;if cfg.GetCartServiceURL() != &quot;&quot; {&#13;&#10;&#9;&#9;cartClient = client.NewCartClient(cfg.GetCartServiceURL())&#13;&#10;&#9;&#9;appLogger.Info(&quot;Cart service client initialized with URL: %s&quot;, cfg.GetCartServiceURL())&#13;&#10;&#9;} else {&#13;&#10;&#9;&#9;appLogger.Warn(&quot;Cart service URL not configured, cart creation will be skipped&quot;)&#13;&#10;&#9;&#9;cartClient = client.NewCartClient(&quot;&quot;) // This will effectively disable cart creation&#13;&#10;&#9;}&#13;&#10;&#13;&#10;&#9;// Initialize services&#13;&#10;&#9;authService := service.NewAuthService(logger.WithComponent(cfg.GetLogLevel(), &quot;AUTH-SERVICE&quot;), userRepo, authRepo, cfg)&#13;&#10;&#9;userService := service.NewUserService(logger.WithComponent(cfg.GetLogLevel(), &quot;USER-SERVICE&quot;), userRepo, authRepo, cartClient)&#13;&#10;&#13;&#10;&#9;// Initialize middleware&#13;&#10;&#9;authMiddleware := middleware.NewAuthMiddleware(logger.WithComponent(cfg.GetLogLevel(), &quot;AUTH-MIDDLEWARE&quot;), cfg.GetJWTSecret())&#13;&#10;&#13;&#10;&#9;// Initialize controllers&#13;&#10;&#9;authController := v1.NewAuthController(logger.WithComponent(cfg.GetLogLevel(), &quot;AUTH-CONTROLLER&quot;), authService)&#13;&#10;&#9;userController := v1.NewUserController(logger.WithComponent(cfg.GetLogLevel(), &quot;USER-CONTROLLER&quot;), userService)&#13;&#10;&#13;&#10;&#9;// Setup router&#13;&#10;&#9;router := setupRouter(authController, userController, authMiddleware)&#13;&#10;&#13;&#10;&#9;// Initialize user data&#13;&#10;&#9;if err := initUserData(userRepo, authRepo); err != nil {&#13;&#10;&#9;&#9;appLogger.Error(&quot;Failed to initialize user data: %v&quot;, err)&#13;&#10;&#9;&#9;log.Fatal(err)&#13;&#10;&#9;} else {&#13;&#10;&#9;&#9;appLogger.Info(&quot;User data initialized successfully&quot;)&#13;&#10;&#9;}&#13;&#10;&#13;&#10;&#9;// Start server&#13;&#10;&#9;serverAddr := cfg.GetServerAddress()&#13;&#10;&#9;appLogger.Info(&quot;Server starting on %s&quot;, serverAddr)&#13;&#10;&#9;if err := router.Run(serverAddr); err != nil {&#13;&#10;&#9;&#9;appLogger.Error(&quot;Failed to start server: %v&quot;, err)&#13;&#10;&#9;&#9;log.Fatal(err)&#13;&#10;&#9;}&#13;&#10;}&#13;&#10;&#13;&#10;func initDatabase(cfg *config.AppConfig) (*gorm.DB, error) {&#13;&#10;&#9;db, err := gorm.Open(postgres.Open(cfg.GetDatabaseURL()), &amp;gorm.Config{})&#13;&#10;&#9;if err != nil {&#13;&#10;&#9;&#9;return nil, err&#13;&#10;&#9;}&#13;&#10;&#13;&#10;&#9;return db, nil&#13;&#10;}&#13;&#10;&#13;&#10;func setupRouter(authController *v1.AuthController, userController *v1.UserController, authMiddleware *middleware.AuthMiddleware) *gin.Engine {&#13;&#10;&#9;router := gin.Default()&#13;&#10;&#13;&#10;&#9;// Health check endpoint&#13;&#10;&#9;router.GET(&quot;/health&quot;, func(c *gin.Context) {&#13;&#10;&#9;&#9;c.JSON(200, gin.H{&quot;status&quot;: &quot;healthy&quot;})&#13;&#10;&#9;})&#13;&#10;&#13;&#10;&#9;// API routes&#13;&#10;&#9;api := router.Group(&quot;/api/v1&quot;)&#13;&#10;&#9;{&#13;&#10;&#9;&#9;auth := api.Group(&quot;/auth&quot;)&#13;&#10;&#9;&#9;users := api.Group(&quot;/users&quot;)&#13;&#10;&#13;&#10;&#9;&#9;// Public routes&#13;&#10;&#9;&#9;{&#13;&#10;&#9;&#9;&#9;users.POST(&quot;&quot;, userController.CreateUser())&#13;&#10;&#13;&#10;&#9;&#9;&#9;auth.POST(&quot;/login&quot;, authController.Login())&#13;&#10;&#9;&#9;&#9;auth.GET(&quot;/verify&quot;, authController.Verify())&#13;&#10;&#9;&#9;}&#13;&#10;&#13;&#10;&#9;&#9;auth.Use(authMiddleware.AuthRequired())&#13;&#10;&#9;&#9;{&#13;&#10;&#9;&#9;&#9;// TODO - Create login, register, logout endpoints&#13;&#10;&#9;&#9;&#9;//auth.POST(&quot;/register&quot;, authController.Register())&#13;&#10;&#9;&#9;&#9;//auth.POST(&quot;/logout&quot;, authMiddleware.AuthRequired(), authController.Logout())&#13;&#10;&#9;&#9;}&#13;&#10;&#13;&#10;&#9;&#9;// User routes (protected)&#13;&#10;&#9;&#9;users.Use(authMiddleware.AuthRequired())&#13;&#10;&#9;&#9;{&#13;&#10;&#9;&#9;&#9;users.GET(&quot;:id&quot;, userController.GetUserByID())&#13;&#10;&#13;&#10;&#9;&#9;&#9;users.PUT(&quot;/:id/profile&quot;, userController.UpdateUserProfile())&#13;&#10;&#9;&#9;&#9;users.PATCH(&quot;/:id/register-merchant&quot;,&#13;&#10;&#9;&#9;&#9;&#9;userController.UpdateToMerchantAccount())&#13;&#10;&#9;&#9;&#9;users.PATCH(&quot;/:id/password&quot;, userController.UpdateUserPassword())&#13;&#10;&#9;&#9;&#9;users.DELETE(&quot;/:id&quot;, userController.DeleteUser())&#13;&#10;&#13;&#10;&#9;&#9;&#9;// Admin only routes&#13;&#10;&#9;&#9;&#9;users.GET(&quot;&quot;, authMiddleware.RequireRole(&quot;admin&quot;), userController.GetUsers())&#13;&#10;&#9;&#9;}&#13;&#10;&#9;}&#13;&#10;&#13;&#10;&#9;return router&#13;&#10;}&#13;&#10;&#13;&#10;func initUserData(userRepository identity.UserRepository, authRepository identity.AuthRepository) error {&#13;&#10;&#9;user, err := userRepository.FindUserByID(1)&#13;&#10;&#9;if user != nil {&#13;&#10;&#9;&#9;return nil&#13;&#10;&#9;}&#13;&#10;&#13;&#10;&#9;// Create admin user if it does not exist&#13;&#10;&#9;if errors.Is(err, customErr.ErrUserNotFound{}) {&#13;&#10;&#9;&#9;user = createAdminUser()&#13;&#10;&#9;&#9;if err := userRepository.CreateUser(user); err != nil {&#13;&#10;&#9;&#9;&#9;return err&#13;&#10;&#9;&#9;}&#13;&#10;&#9;}&#13;&#10;&#13;&#10;&#9;// Assign admin role to the user&#13;&#10;&#9;role, err := authRepository.FindRoleByName(string(constants.RoleAdmin))&#13;&#10;&#9;if err != nil {&#13;&#10;&#9;&#9;return err&#13;&#10;&#9;}&#13;&#10;&#13;&#10;&#9;adminRole := entity.UserRoles{&#13;&#10;&#9;&#9;UserID: user.ID,&#13;&#10;&#9;&#9;RoleID: role.ID,&#13;&#10;&#9;}&#13;&#10;&#13;&#10;&#9;if err := authRepository.AddRoleToUser(&amp;adminRole); err != nil {&#13;&#10;&#9;&#9;return err&#13;&#10;&#9;}&#13;&#10;&#13;&#10;&#9;log.Printf(&quot;Admin user initialized: %s&quot;, user.Email)&#13;&#10;&#9;return nil&#13;&#10;}&#13;&#10;&#13;&#10;func createAdminUser() *entity.User {&#13;&#10;&#9;password := &quot;admin&quot;&#13;&#10;&#9;hashedPassword, _ := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)&#13;&#10;&#13;&#10;&#9;return &amp;entity.User{&#13;&#10;&#9;&#9;Email:        &quot;test@gmail.com&quot;,&#13;&#10;&#9;&#9;Password:     string(hashedPassword),&#13;&#10;&#9;&#9;ProviderID:   &quot;1&quot;,&#13;&#10;&#9;&#9;ProviderName: &quot;app&quot;,&#13;&#10;&#9;&#9;LastName:     &quot;Admin&quot;,&#13;&#10;&#9;&#9;FirstName:    &quot;Admin&quot;,&#13;&#10;&#9;&#9;Avatar:       &quot;https://example.com/avatar.png&quot;,&#13;&#10;&#9;&#9;Gender:       string(constants.GenderOther),&#13;&#10;&#9;&#9;PhoneNumber:  &quot;1234567890&quot;,&#13;&#10;&#9;&#9;DateOfBirth:  time.Now(),&#13;&#10;&#9;&#9;Status:       string(constants.UserStatusActive),&#13;&#10;&#9;}&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/internal/services/identity/config.yaml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/internal/services/identity/config.yaml" />
              <option name="originalContent" value="environment: &quot;development&quot;&#10;service_name: &quot;identity&quot;&#10;&#10;# Application Configuration (host and port are here, not in http)&#10;app:&#10;  host: &quot;localhost&quot;&#10;  port: &quot;8080&quot;&#10;&#10;# HTTP Server Configuration (no host/port here - different fields)&#10;http:&#10;  read_timeout: 10&#10;  write_timeout: 10&#10;  max_header_bytes: 1048576&#10;  allowed_origins: &quot;*&quot;&#10;  allowed_methods: &quot;GET,POST,PUT,DELETE,OPTIONS&quot;&#10;  allowed_headers: &quot;Content-Type,Authorization&quot;&#10;  exposed_headers: &quot;&quot;&#10;  allow_credentials: true&#10;&#10;# Database Configuration (using proper defaults that Viper can handle)&#10;pg:&#10;  host: &quot;localhost&quot;&#10;  port: &quot;5432&quot;&#10;  user: &quot;postgres&quot;&#10;  password: &quot;password&quot;&#10;  database: &quot;gostore_identity&quot;&#10;  ssl_mode: &quot;disable&quot;&#10;  max_open_conns: 25&#10;  max_idle_conns: 10&#10;  conn_max_lifetime: 3600&#10;  conn_max_idle_time: 1800&#10;&#10;# JWT Configuration (different field names)&#10;jwt:&#10;  secret: &quot;${JWT_SECRET:your-secret-key}&quot;&#10;  expiration: &quot;15m&quot; # in minutes&#10;  issuer: &quot;gostore-identity&quot;&#10;  audience: &quot;gostore-users&quot;&#10;&#10;# Redis Configuration&#10;redis:&#10;  host: &quot;${REDIS_HOST:localhost}&quot;&#10;  port: &quot;${REDIS_PORT:6001}&quot;&#10;  password: &quot;${REDIS_PASSWORD:}&quot;&#10;  db: 0&#10;  pool_size: 10&#10;  min_idle_conns: 3&#10;  dial_timeout: 5&#10;  read_timeout: 3&#10;  write_timeout: 3&#10;  idle_timeout: 300&#10;&#10;# Logging Configuration&#10;log:&#10;  level: &quot;info&quot;&#10;  format: &quot;json&quot;&#10;  output: &quot;stdout&quot;&#10;  file_path: &quot;&quot;&#10;  max_size: 10&#10;  max_backups: 3&#10;  max_age: 28&#10;  compress: true&#10;&#10;# Services Configuration for inter-service communication&#10;services:&#10;  identity_service_url: &quot;http://localhost:8080&quot;&#10;  product_service_url: &quot;http://localhost:8081&quot;&#10;  cart_service_url: &quot;http://localhost:8082&quot;&#10;  order_service_url: &quot;http://localhost:8083&quot;&#10;  gateway_service_url: &quot;http://localhost:8000&quot;&#10;  notification_service_url: &quot;http://localhost:8084&quot;&#10;  payment_service_url: &quot;http://localhost:8085&quot;&#10;" />
              <option name="updatedContent" value="environment: &quot;development&quot;&#10;service_name: &quot;identity&quot;&#10;&#10;# Application Configuration (host and port are here, not in http)&#10;app:&#10;  host: &quot;localhost&quot;&#10;  port: &quot;8080&quot;&#10;&#10;# HTTP Server Configuration (no host/port here - different fields)&#10;http:&#10;  read_timeout: 10&#10;  write_timeout: 10&#10;  max_header_bytes: 1048576&#10;  allowed_origins: &quot;*&quot;&#10;  allowed_methods: &quot;GET,POST,PUT,DELETE,OPTIONS&quot;&#10;  allowed_headers: &quot;Content-Type,Authorization&quot;&#10;  exposed_headers: &quot;&quot;&#10;  allow_credentials: true&#10;&#10;# Database Configuration (using proper defaults that Viper can handle)&#10;pg:&#10;  host: &quot;localhost&quot;&#10;  port: &quot;5432&quot;&#10;  user: &quot;postgres&quot;&#10;  password: &quot;password&quot;&#10;  database: &quot;gostore_identity&quot;&#10;  ssl_mode: &quot;disable&quot;&#10;  max_open_conns: 25&#10;  max_idle_conns: 10&#10;  conn_max_lifetime: 3600&#10;  conn_max_idle_time: 1800&#10;&#10;# JWT Configuration (using proper defaults)&#10;jwt:&#10;  secret: &quot;your-secret-key&quot;&#10;  expiration: &quot;15m&quot;&#10;  issuer: &quot;gostore-identity&quot;&#10;  audience: &quot;gostore-users&quot;&#10;&#10;# Redis Configuration (using proper defaults)&#10;redis:&#10;  host: &quot;localhost&quot;&#10;  port: &quot;6379&quot;&#10;  password: &quot;&quot;&#10;  db: 0&#10;  pool_size: 10&#10;  min_idle_conns: 3&#10;  dial_timeout: 5&#10;  read_timeout: 3&#10;  write_timeout: 3&#10;  idle_timeout: 300&#10;&#10;# Logging Configuration&#10;log:&#10;  level: &quot;info&quot;&#10;  format: &quot;json&quot;&#10;  output: &quot;stdout&quot;&#10;  file_path: &quot;&quot;&#10;  max_size: 10&#10;  max_backups: 3&#10;  max_age: 28&#10;  compress: true&#10;&#10;# Services Configuration for inter-service communication&#10;services:&#10;  identity_service_url: &quot;http://localhost:8080&quot;&#10;  product_service_url: &quot;http://localhost:8081&quot;&#10;  cart_service_url: &quot;http://localhost:8082&quot;&#10;  order_service_url: &quot;http://localhost:8083&quot;&#10;  gateway_service_url: &quot;http://localhost:8000&quot;&#10;  notification_service_url: &quot;http://localhost:8084&quot;&#10;  payment_service_url: &quot;http://localhost:8085&quot;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/internal/services/identity/internal/client/cart_client.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/internal/services/identity/internal/client/cart_client.go" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/internal/services/identity/internal/config/config.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/internal/services/identity/internal/config/config.go" />
              <option name="originalContent" value="package config&#10;&#10;import (&#10;&#9;&quot;fmt&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/internal/pkg/config&quot;&#10;&#9;&quot;time&quot;&#10;)&#10;&#10;type AppConfig struct {&#10;&#9;*config.Config&#10;}&#10;&#10;func LoadConfig(configPath string) (*AppConfig, error) {&#10;&#9;// Load shared configuration from pkg&#10;&#9;sharedConfig, err := config.LoadConfig(configPath)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, fmt.Errorf(&quot;error loading shared config: %w&quot;, err)&#10;&#9;}&#10;&#10;&#9;appConfig := &amp;AppConfig{&#10;&#9;&#9;Config: sharedConfig,&#10;&#9;}&#10;&#10;&#9;return appConfig, nil&#10;}&#10;&#10;// Legacy getter methods for backward compatibility&#10;func (c *AppConfig) GetDBHost() string {&#10;&#9;return c.PG.Host&#10;}&#10;&#10;func (c *AppConfig) GetDBPort() string {&#10;&#9;return c.PG.Port&#10;}&#10;&#10;func (c *AppConfig) GetDBUser() string {&#10;&#9;return c.PG.User&#10;}&#10;&#10;func (c *AppConfig) GetDBPassword() string {&#10;&#9;return c.PG.Password&#10;}&#10;&#10;func (c *AppConfig) GetDBName() string {&#10;&#9;return c.PG.DBName&#10;}&#10;&#10;func (c *AppConfig) GetDBSSLMode() string {&#10;&#9;return c.PG.SSLMode&#10;}&#10;&#10;func (c *AppConfig) GetJWTSecret() string {&#10;&#9;return c.JWT.Secret&#10;}&#10;&#10;func (c *AppConfig) GetJWTExpiresIn() time.Duration {&#10;&#9;duration, _ := time.ParseDuration(c.JWT.ExpiresIn)&#10;&#9;return duration&#10;}&#10;&#10;func (c *AppConfig) GetJWTRefreshExpiresIn() time.Duration {&#10;&#9;duration, _ := time.ParseDuration(c.JWT.RefreshExpiresIn)&#10;&#9;return duration&#10;}&#10;&#10;func (c *AppConfig) GetServerPort() string {&#10;&#9;return c.HTTP.Port&#10;}&#10;&#10;func (c *AppConfig) GetServerHost() string {&#10;&#9;return c.HTTP.Host&#10;}&#10;&#10;func (c *AppConfig) GetLogLevel() string {&#10;&#9;return c.Log.Level&#10;}&#10;&#10;func (c *AppConfig) GetRedisHost() string {&#10;&#9;return c.Redis.Host&#10;}&#10;&#10;func (c *AppConfig) GetRedisPort() string {&#10;&#9;return c.Redis.Port&#10;}&#10;&#10;func (c *AppConfig) GetRedisPassword() string {&#10;&#9;return c.Redis.Password&#10;}&#10;&#10;func (c *AppConfig) GetCartServiceURL() string {&#10;&#9;return c.Services.GetServiceURL(&quot;cart&quot;)&#10;}&#10;&#10;func (c *AppConfig) GetEnvironment() string {&#10;&#9;return c.Environment&#10;}&#10;&#10;func (c *AppConfig) GetDatabaseURL() string {&#10;&#9;return fmt.Sprintf(&quot;host=%s port=%s user=%s password=%s dbname=%s sslmode=%s&quot;,&#10;&#9;&#9;c.PG.Host, c.PG.Port, c.PG.User, c.PG.Password, c.PG.DBName, c.PG.SSLMode)&#10;}&#10;&#10;func (c *AppConfig) GetServerAddress() string {&#10;&#9;return &quot;:&quot; + c.HTTP.Port&#10;}&#10;" />
              <option name="updatedContent" value="package config&#10;&#10;import (&#10;&#9;&quot;fmt&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/internal/pkg/config&quot;&#10;&#9;&quot;time&quot;&#10;)&#10;&#10;type AppConfig struct {&#10;&#9;*config.Config&#10;}&#10;&#10;func LoadConfig(configPath string) (*AppConfig, error) {&#10;&#9;// Load shared configuration from pkg&#10;&#9;sharedConfig, err := config.LoadConfig(configPath)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, fmt.Errorf(&quot;error loading shared config: %w&quot;, err)&#10;&#9;}&#10;&#10;&#9;appConfig := &amp;AppConfig{&#10;&#9;&#9;Config: sharedConfig,&#10;&#9;}&#10;&#10;&#9;return appConfig, nil&#10;}&#10;&#10;// Legacy getter methods for backward compatibility&#10;func (c *AppConfig) GetDBHost() string {&#10;&#9;return c.PG.Host&#10;}&#10;&#10;func (c *AppConfig) GetDBPort() string {&#10;&#9;return c.PG.Port&#10;}&#10;&#10;func (c *AppConfig) GetDBUser() string {&#10;&#9;return c.PG.User&#10;}&#10;&#10;func (c *AppConfig) GetDBPassword() string {&#10;&#9;return c.PG.Password&#10;}&#10;&#10;func (c *AppConfig) GetDBName() string {&#10;&#9;return c.PG.Database // Updated field name&#10;}&#10;&#10;func (c *AppConfig) GetDBSSLMode() string {&#10;&#9;return c.PG.SSLMode // Updated field name&#10;}&#10;&#10;func (c *AppConfig) GetJWTSecret() string {&#10;&#9;return c.JWT.Secret&#10;}&#10;&#10;func (c *AppConfig) GetJWTExpiresIn() time.Duration {&#10;&#9;duration, _ := time.ParseDuration(c.JWT.Expiration) // Updated field name&#10;&#9;return duration&#10;}&#10;&#10;func (c *AppConfig) GetJWTRefreshExpiresIn() time.Duration {&#10;&#9;// Since refresh_expires_in is not in pkg struct, use a default or derive from expiration&#10;&#9;duration, _ := time.ParseDuration(&quot;168h&quot;) // 7 days default&#10;&#9;return duration&#10;}&#10;&#10;func (c *AppConfig) GetServerPort() string {&#10;&#9;return c.App.Port // Updated to use App.Port&#10;}&#10;&#10;func (c *AppConfig) GetServerHost() string {&#10;&#9;return c.App.Host // Updated to use App.Host&#10;}&#10;&#10;func (c *AppConfig) GetLogLevel() string {&#10;&#9;return c.Log.Level&#10;}&#10;&#10;func (c *AppConfig) GetRedisHost() string {&#10;&#9;return c.Redis.Host&#10;}&#10;&#10;func (c *AppConfig) GetRedisPort() string {&#10;&#9;return c.Redis.Port&#10;}&#10;&#10;func (c *AppConfig) GetRedisPassword() string {&#10;&#9;return c.Redis.Password&#10;}&#10;&#10;func (c *AppConfig) GetCartServiceURL() string {&#10;&#9;return c.Services.GetServiceURL(&quot;cart&quot;)&#10;}&#10;&#10;func (c *AppConfig) GetEnvironment() string {&#10;&#9;return c.Environment&#10;}&#10;&#10;func (c *AppConfig) GetDatabaseURL() string {&#10;&#9;return fmt.Sprintf(&quot;host=%s port=%s user=%s password=%s dbname=%s sslmode=%s&quot;,&#10;&#9;&#9;c.PG.Host, c.PG.Port, c.PG.User, c.PG.Password, c.PG.Database, c.PG.SSLMode) // Updated field names&#10;}&#10;&#10;func (c *AppConfig) GetServerAddress() string {&#10;&#9;return &quot;:&quot; + c.App.Port // Updated to use App.Port&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/internal/services/identity/internal/dto/request/refresh_token_request.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/internal/services/identity/internal/dto/request/refresh_token_request.go" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/internal/services/product/cmd/main.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/internal/services/product/cmd/main.go" />
              <option name="originalContent" value="package main&#10;&#10;import (&#10;&#9;&quot;github.com/hthinh24/go-store/internal/pkg/middleware/auth&quot;&#10;&#9;&quot;log&quot;&#10;&#10;&#9;&quot;github.com/gin-gonic/gin&quot;&#10;&#9;customLog &quot;github.com/hthinh24/go-store/internal/pkg/logger&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/services/product/internal/config&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/services/product/internal/controller&quot;&#10;&#9;repository &quot;github.com/hthinh24/go-store/services/product/internal/infra/repository/postgres&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/services/product/internal/service&quot;&#10;&#9;&quot;gorm.io/driver/postgres&quot;&#10;&#9;&quot;gorm.io/gorm&quot;&#10;)&#10;&#10;func main() {&#10;&#9;fileName := &quot;.env&quot;&#10;&#9;// Load configuration from environment variables&#10;&#9;cfg, err := config.LoadConfig(fileName)&#10;&#9;if err != nil {&#10;&#9;&#9;log.Fatalf(&quot;Failed to load config: %v&quot;, err)&#10;&#9;}&#10;&#10;&#9;// Initialize appLogger&#10;&#9;appLogger := customLog.NewAppLogger(cfg.LogLevel)&#10;&#9;appLogger.Info(&quot;Starting Product Service...&quot;)&#10;&#9;appLogger.Info(&quot;Environment: %s&quot;, cfg.Environment)&#10;&#10;&#9;// Initialize database connection&#10;&#9;db, err := initDatabase(cfg)&#10;&#9;if err != nil {&#10;&#9;&#9;appLogger.Error(&quot;Failed to connect to database: %v&quot;, err)&#10;&#9;&#9;log.Fatal(err)&#10;&#9;}&#10;&#9;appLogger.Info(&quot;Database connected successfully&quot;)&#10;&#10;&#9;// Initialize repositories&#10;&#9;productRepository := repository.NewProductRepository(&#10;&#9;&#9;customLog.WithComponent(cfg.LogLevel, &quot;PRODUCT-REPOSITORY&quot;),&#10;&#9;&#9;db)&#10;&#10;&#9;// Initialize services&#10;&#9;productService := service.NewProductService(&#10;&#9;&#9;customLog.WithComponent(cfg.LogLevel, &quot;PRODUCT-SERVICE&quot;),&#10;&#9;&#9;productRepository)&#10;&#10;&#9;// Initialize controllers&#10;&#9;productController := controller.NewProductController(&#10;&#9;&#9;customLog.WithComponent(cfg.LogLevel, &quot;PRODUCT-CONTROLLER&quot;),&#10;&#9;&#9;productService)&#10;&#10;&#9;// Setup router&#10;&#9;router := setupRouter(productController, cfg)&#10;&#10;&#9;// Start server&#10;&#9;serverAddr := cfg.GetServerAddress()&#10;&#9;appLogger.Info(&quot;Server starting on %s&quot;, serverAddr)&#10;&#9;if err := router.Run(serverAddr); err != nil {&#10;&#9;&#9;appLogger.Error(&quot;Failed to start server: %v&quot;, err)&#10;&#9;&#9;log.Fatal(err)&#10;&#9;}&#10;}&#10;&#10;func initDatabase(cfg *config.AppConfig) (*gorm.DB, error) {&#10;&#9;db, err := gorm.Open(postgres.Open(cfg.GetDatabaseURL()), &amp;gorm.Config{})&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;return db, nil&#10;}&#10;&#10;func setupRouter(productController *controller.ProductController, cfg *config.AppConfig) *gin.Engine {&#10;&#9;router := gin.Default()&#10;&#10;&#9;authMiddleware := auth.NewSharedAuthMiddleware(customLog.WithComponent(cfg.LogLevel, &quot;AUTH-MIDDLEWARE&quot;))&#10;&#10;&#9;router.GET(&quot;/health&quot;, func(c *gin.Context) {&#10;&#9;&#9;c.JSON(200, gin.H{&quot;status&quot;: &quot;healthy&quot;})&#10;&#9;})&#10;&#10;&#9;api := router.Group(&quot;/api&quot;)&#10;&#9;{&#10;&#9;&#9;v1 := api.Group(&quot;/v1&quot;)&#10;&#9;&#9;products := v1.Group(&quot;/products&quot;)&#10;&#9;&#9;{&#10;&#9;&#9;&#9;// Public routes&#10;&#9;&#9;&#9;products.GET(&quot;/:id&quot;, productController.GetProductByID())&#10;&#9;&#9;&#9;products.GET(&quot;/:id/detail&quot;, productController.GetProductDetailByID())&#10;&#9;&#9;&#9;products.GET(&quot;/skus/:id&quot;, productController.GetProductSKUByID())&#10;&#10;&#9;&#9;&#9;// Protected routes&#10;&#9;&#9;&#9;// TODO - Implement this later&#10;&#9;&#9;&#9;//products.GET(&quot;:userID/products&quot;,&#10;&#9;&#9;&#9;//&#9;authMiddleware.AuthRequired(),&#10;&#9;&#9;&#9;//&#9;productController.GetProductByUserID())&#10;&#10;&#9;&#9;&#9;products.POST(&quot;&quot;,&#10;&#9;&#9;&#9;&#9;authMiddleware.AuthRequired(),&#10;&#9;&#9;&#9;&#9;authMiddleware.RequireAnyPermission(&quot;product.create&quot;),&#10;&#9;&#9;&#9;&#9;productController.CreateProduct())&#10;&#10;&#9;&#9;&#9;products.POST(&quot;/no-sku&quot;,&#10;&#9;&#9;&#9;&#9;authMiddleware.AuthRequired(),&#10;&#9;&#9;&#9;&#9;authMiddleware.RequireAnyPermission(&quot;product.create&quot;),&#10;&#9;&#9;&#9;&#9;productController.CreateProductWithoutSKU())&#10;&#10;&#9;&#9;&#9;products.DELETE(&quot;/:id&quot;,&#10;&#9;&#9;&#9;&#9;authMiddleware.AuthRequired(),&#10;&#9;&#9;&#9;&#9;authMiddleware.RequireAnyPermission(&quot;product.delete&quot;),&#10;&#9;&#9;&#9;&#9;productController.DeleteProductByID())&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;return router&#10;}&#10;" />
              <option name="updatedContent" value="package main&#13;&#10;&#13;&#10;import (&#13;&#10;&#9;&quot;github.com/hthinh24/go-store/internal/pkg/middleware/auth&quot;&#13;&#10;&#9;&quot;log&quot;&#13;&#10;&#13;&#10;&#9;&quot;github.com/gin-gonic/gin&quot;&#13;&#10;&#9;customLog &quot;github.com/hthinh24/go-store/internal/pkg/logger&quot;&#13;&#10;&#9;&quot;github.com/hthinh24/go-store/internal/services/product/internal/config&quot;&#13;&#10;&#9;&quot;github.com/hthinh24/go-store/internal/services/product/internal/controller&quot;&#13;&#10;&#9;repository &quot;github.com/hthinh24/go-store/internal/services/product/internal/infra/repository/postgres&quot;&#13;&#10;&#9;&quot;github.com/hthinh24/go-store/internal/services/product/internal/service&quot;&#13;&#10;&#9;&quot;gorm.io/driver/postgres&quot;&#13;&#10;&#9;&quot;gorm.io/gorm&quot;&#13;&#10;)&#13;&#10;&#13;&#10;func main() {&#13;&#10;&#9;configPath := &quot;config.yaml&quot;&#13;&#10;&#13;&#10;&#9;// Load configuration using shared pkg config&#13;&#10;&#9;cfg, err := config.LoadConfig(configPath)&#13;&#10;&#9;if err != nil {&#13;&#10;&#9;&#9;log.Fatalf(&quot;Failed to load config: %v&quot;, err)&#13;&#10;&#9;}&#13;&#10;&#13;&#10;&#9;// Initialize appLogger&#13;&#10;&#9;appLogger := customLog.NewAppLogger(cfg.GetLogLevel())&#13;&#10;&#9;appLogger.Info(&quot;Starting Product Service...&quot;)&#13;&#10;&#9;appLogger.Info(&quot;Environment: %s&quot;, cfg.GetEnvironment())&#13;&#10;&#13;&#10;&#9;// Initialize database connection&#13;&#10;&#9;db, err := initDatabase(cfg)&#13;&#10;&#9;if err != nil {&#13;&#10;&#9;&#9;appLogger.Error(&quot;Failed to connect to database: %v&quot;, err)&#13;&#10;&#9;&#9;log.Fatal(err)&#13;&#10;&#9;}&#13;&#10;&#9;appLogger.Info(&quot;Database connected successfully&quot;)&#13;&#10;&#13;&#10;&#9;// Initialize repositories&#13;&#10;&#9;productRepository := repository.NewProductRepository(&#13;&#10;&#9;&#9;customLog.WithComponent(cfg.LogLevel, &quot;PRODUCT-REPOSITORY&quot;),&#13;&#10;&#9;&#9;db)&#13;&#10;&#13;&#10;&#9;// Initialize services&#13;&#10;&#9;productService := service.NewProductService(&#13;&#10;&#9;&#9;customLog.WithComponent(cfg.LogLevel, &quot;PRODUCT-SERVICE&quot;),&#13;&#10;&#9;&#9;productRepository)&#13;&#10;&#13;&#10;&#9;// Initialize controllers&#13;&#10;&#9;productController := controller.NewProductController(&#13;&#10;&#9;&#9;customLog.WithComponent(cfg.LogLevel, &quot;PRODUCT-CONTROLLER&quot;),&#13;&#10;&#9;&#9;productService)&#13;&#10;&#13;&#10;&#9;// Setup router&#13;&#10;&#9;router := setupRouter(productController, cfg)&#13;&#10;&#13;&#10;&#9;// Start server&#13;&#10;&#9;serverAddr := cfg.GetServerAddress()&#13;&#10;&#9;appLogger.Info(&quot;Server starting on %s&quot;, serverAddr)&#13;&#10;&#9;if err := router.Run(serverAddr); err != nil {&#13;&#10;&#9;&#9;appLogger.Error(&quot;Failed to start server: %v&quot;, err)&#13;&#10;&#9;&#9;log.Fatal(err)&#13;&#10;&#9;}&#13;&#10;}&#13;&#10;&#13;&#10;func initDatabase(cfg *config.AppConfig) (*gorm.DB, error) {&#13;&#10;&#9;db, err := gorm.Open(postgres.Open(cfg.GetDatabaseURL()), &amp;gorm.Config{})&#13;&#10;&#9;if err != nil {&#13;&#10;&#9;&#9;return nil, err&#13;&#10;&#9;}&#13;&#10;&#13;&#10;&#9;return db, nil&#13;&#10;}&#13;&#10;&#13;&#10;func setupRouter(productController *controller.ProductController, cfg *config.AppConfig) *gin.Engine {&#13;&#10;&#9;router := gin.Default()&#13;&#10;&#13;&#10;&#9;authMiddleware := auth.NewSharedAuthMiddleware(customLog.WithComponent(cfg.LogLevel, &quot;AUTH-MIDDLEWARE&quot;))&#13;&#10;&#13;&#10;&#9;router.GET(&quot;/health&quot;, func(c *gin.Context) {&#13;&#10;&#9;&#9;c.JSON(200, gin.H{&quot;status&quot;: &quot;healthy&quot;})&#13;&#10;&#9;})&#13;&#10;&#13;&#10;&#9;api := router.Group(&quot;/api&quot;)&#13;&#10;&#9;{&#13;&#10;&#9;&#9;v1 := api.Group(&quot;/v1&quot;)&#13;&#10;&#9;&#9;products := v1.Group(&quot;/products&quot;)&#13;&#10;&#9;&#9;{&#13;&#10;&#9;&#9;&#9;// Public routes&#13;&#10;&#9;&#9;&#9;products.GET(&quot;/:id&quot;, productController.GetProductByID())&#13;&#10;&#9;&#9;&#9;products.GET(&quot;/:id/detail&quot;, productController.GetProductDetailByID())&#13;&#10;&#9;&#9;&#9;products.GET(&quot;/skus/:id&quot;, productController.GetProductSKUByID())&#13;&#10;&#13;&#10;&#9;&#9;&#9;// Protected routes&#13;&#10;&#9;&#9;&#9;// TODO - Implement this later&#13;&#10;&#9;&#9;&#9;//products.GET(&quot;:userID/products&quot;,&#13;&#10;&#9;&#9;&#9;//&#9;authMiddleware.AuthRequired(),&#13;&#10;&#9;&#9;&#9;//&#9;productController.GetProductByUserID())&#13;&#10;&#13;&#10;&#9;&#9;&#9;products.POST(&quot;&quot;,&#13;&#10;&#9;&#9;&#9;&#9;authMiddleware.AuthRequired(),&#13;&#10;&#9;&#9;&#9;&#9;authMiddleware.RequireAnyPermission(&quot;product.create&quot;),&#13;&#10;&#9;&#9;&#9;&#9;productController.CreateProduct())&#13;&#10;&#13;&#10;&#9;&#9;&#9;products.POST(&quot;/no-sku&quot;,&#13;&#10;&#9;&#9;&#9;&#9;authMiddleware.AuthRequired(),&#13;&#10;&#9;&#9;&#9;&#9;authMiddleware.RequireAnyPermission(&quot;product.create&quot;),&#13;&#10;&#9;&#9;&#9;&#9;productController.CreateProductWithoutSKU())&#13;&#10;&#13;&#10;&#9;&#9;&#9;products.DELETE(&quot;/:id&quot;,&#13;&#10;&#9;&#9;&#9;&#9;authMiddleware.AuthRequired(),&#13;&#10;&#9;&#9;&#9;&#9;authMiddleware.RequireAnyPermission(&quot;product.delete&quot;),&#13;&#10;&#9;&#9;&#9;&#9;productController.DeleteProductByID())&#13;&#10;&#9;&#9;}&#13;&#10;&#9;}&#13;&#10;&#13;&#10;&#9;return router&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/internal/services/product/config.yaml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/internal/services/product/config.yaml" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="environment: &quot;development&quot;&#10;service_name: &quot;product&quot;&#10;&#10;# Application Configuration (host and port from .env: SERVER_HOST=localhost, SERVER_PORT=8081)&#10;app:&#10;  host: &quot;localhost&quot;&#10;  port: &quot;8081&quot;&#10;&#10;# HTTP Server Configuration&#10;http:&#10;  read_timeout: 10&#10;  write_timeout: 10&#10;  max_header_bytes: 1048576&#10;  allowed_origins: &quot;*&quot;&#10;  allowed_methods: &quot;GET,POST,PUT,DELETE,OPTIONS&quot;&#10;  allowed_headers: &quot;Content-Type,Authorization&quot;&#10;  exposed_headers: &quot;&quot;&#10;  allow_credentials: true&#10;&#10;# Database Configuration (from .env: DB_HOST=localhost, DB_PORT=5002, etc.)&#10;pg:&#10;  host: &quot;localhost&quot;&#10;  port: &quot;5002&quot;&#10;  user: &quot;postgres&quot;&#10;  password: &quot;root&quot;&#10;  database: &quot;postgres&quot;&#10;  ssl_mode: &quot;disable&quot;&#10;  max_open_conns: 25&#10;  max_idle_conns: 10&#10;  conn_max_lifetime: 3600&#10;  conn_max_idle_time: 1800&#10;&#10;# JWT Configuration (from .env: JWT_SECRET=..., JWT_EXPIRATION=15m)&#10;jwt:&#10;  secret: &quot;5z4JF/JFOVgC20QTMNyMPeW9kri5mSZ+XHnN9B8a6CmV04jFiCkzyLnbm3IEk5XrCQJm1thcCncK5WOII1GGdF46fwbtakSklUVtUIbfbY4zEcSjBSkbz8vbtRDuEIvm0BYoRHqEHMQoO3O4uwI6WMfIGtphOLiQ6zgl6bDFrF8LKjg6rT/5vJTJiDOjf5dpfWL3Kj5qRwp/MdzR9IGp75tDf9IxaxpJ/dUj/xdlUaBv4Qvlk4829JHBESfvI0PhgvYUWPKC0ZJxZN1/7G1C8VwvMzrzVjViuUccTT3tbrT6z9QWIfzjopRVdWXItpb0wwWO0Wx4oDNR8Mqg32tlkDT1tQNiWbwQQ2Q4hKRkjpk=&quot;&#10;  expiration: &quot;15m&quot;&#10;  issuer: &quot;gostore-product&quot;&#10;  audience: &quot;gostore-users&quot;&#10;&#10;# Redis Configuration (from .env: REDIS_HOST=localhost, REDIS_PORT=6002)&#10;redis:&#10;  host: &quot;localhost&quot;&#10;  port: &quot;6002&quot;&#10;  password: &quot;&quot;&#10;  db: 0&#10;  pool_size: 10&#10;  min_idle_conns: 3&#10;  dial_timeout: 5&#10;  read_timeout: 3&#10;  write_timeout: 3&#10;  idle_timeout: 300&#10;&#10;# Logging Configuration (from .env: LOG_LEVEL=info)&#10;log:&#10;  level: &quot;info&quot;&#10;  format: &quot;json&quot;&#10;  output: &quot;stdout&quot;&#10;  file_path: &quot;&quot;&#10;  max_size: 10&#10;  max_backups: 3&#10;  max_age: 28&#10;  compress: true&#10;&#10;# Services Configuration for inter-service communication (updated USER_SERVICE_URL to identity_service_url)&#10;services:&#10;  identity_service_url: &quot;http://localhost:8080&quot;&#10;  product_service_url: &quot;http://localhost:8081&quot;&#10;  cart_service_url: &quot;http://localhost:8082&quot;&#10;  order_service_url: &quot;http://localhost:8083&quot;&#10;  gateway_service_url: &quot;http://localhost:8000&quot;&#10;  notification_service_url: &quot;http://localhost:8084&quot;&#10;  payment_service_url: &quot;http://localhost:8085&quot;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/internal/services/product/internal/config/config.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/internal/services/product/internal/config/config.go" />
              <option name="originalContent" value="package config&#10;&#10;import (&#10;&#9;&quot;fmt&quot;&#10;&#9;&quot;os&quot;&#10;&#10;&#9;&quot;github.com/joho/godotenv&quot;&#10;)&#10;&#10;type AppConfig struct {&#10;&#9;// Database Configuration&#10;&#9;DBHost     string&#10;&#9;DBPort     string&#10;&#9;DBUser     string&#10;&#9;DBPassword string&#10;&#9;DBName     string&#10;&#9;DBSSLMode  string&#10;&#10;&#9;// Server Configuration&#10;&#9;ServerPort string&#10;&#9;ServerHost string&#10;&#10;&#9;// JWT Configuration&#10;&#9;JWTSecret string&#10;&#9;JWTExpire string&#10;&#10;&#9;UserServiceURL string&#10;&#10;&#9;// Log Configuration&#10;&#9;LogLevel string&#10;&#10;&#9;// Redis Configuration&#10;&#9;RedisHost     string&#10;&#9;RedisPort     string&#10;&#9;RedisPassword string&#10;&#10;&#9;// Environment&#10;&#9;Environment string&#10;}&#10;&#10;func LoadConfig(filename string) (*AppConfig, error) {&#10;&#9;// Load .env file in development&#10;&#9;if os.Getenv(&quot;ENV&quot;) != &quot;production&quot; {&#10;&#9;&#9;err := godotenv.Load(filename)&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;// Don't fail if .env file doesn't exist&#10;&#9;&#9;&#9;fmt.Println(&quot;Warning: .env file not found, using system environment variables&quot;)&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;config := &amp;AppConfig{&#10;&#9;&#9;DBHost:     getEnv(&quot;DB_HOST&quot;, &quot;localhost&quot;),&#10;&#9;&#9;DBPort:     getEnv(&quot;DB_PORT&quot;, &quot;5432&quot;),&#10;&#9;&#9;DBUser:     getEnv(&quot;DB_USER&quot;, &quot;postgres&quot;),&#10;&#9;&#9;DBPassword: getEnv(&quot;DB_PASSWORD&quot;, &quot;&quot;),&#10;&#9;&#9;DBName:     getEnv(&quot;DB_NAME&quot;, &quot;go_store_identity&quot;),&#10;&#9;&#9;DBSSLMode:  getEnv(&quot;DB_SSL_MODE&quot;, &quot;disable&quot;),&#10;&#10;&#9;&#9;JWTSecret: getEnv(&quot;JWT_SECRET&quot;, &quot;&quot;),&#10;&#9;&#9;JWTExpire: getEnv(&quot;JWT_EXPIRATION&quot;, &quot;24h&quot;),&#10;&#10;&#9;&#9;ServerPort: getEnv(&quot;SERVER_PORT&quot;, &quot;8081&quot;),&#10;&#9;&#9;ServerHost: getEnv(&quot;SERVER_HOST&quot;, &quot;localhost&quot;),&#10;&#10;&#9;&#9;UserServiceURL: getEnv(&quot;USER_SERVICE_URL&quot;, &quot;http://localhost:8080&quot;),&#10;&#10;&#9;&#9;LogLevel: getEnv(&quot;LOG_LEVEL&quot;, &quot;info&quot;),&#10;&#10;&#9;&#9;RedisHost:     getEnv(&quot;REDIS_HOST&quot;, &quot;localhost&quot;),&#10;&#9;&#9;RedisPort:     getEnv(&quot;REDIS_PORT&quot;, &quot;6379&quot;),&#10;&#9;&#9;RedisPassword: getEnv(&quot;REDIS_PASSWORD&quot;, &quot;&quot;),&#10;&#10;&#9;&#9;Environment: getEnv(&quot;ENV&quot;, &quot;development&quot;),&#10;&#9;}&#10;&#10;&#9;return config, nil&#10;}&#10;&#10;func (c *AppConfig) GetDatabaseURL() string {&#10;&#9;return fmt.Sprintf(&quot;host=%s user=%s password=%s dbname=%s port=%s sslmode=%s TimeZone=Asia/Shanghai&quot;,&#10;&#9;&#9;c.DBHost, c.DBUser, c.DBPassword, c.DBName, c.DBPort, c.DBSSLMode)&#10;}&#10;&#10;func (c *AppConfig) GetServerAddress() string {&#10;&#9;return fmt.Sprintf(&quot;%s:%s&quot;, c.ServerHost, c.ServerPort)&#10;}&#10;&#10;func (c *AppConfig) IsProduction() bool {&#10;&#9;return c.Environment == &quot;production&quot;&#10;}&#10;&#10;// getEnv gets environment variable with fallback&#10;func getEnv(key, fallback string) string {&#10;&#9;if value := os.Getenv(key); value != &quot;&quot; {&#10;&#9;&#9;return value&#10;&#9;}&#10;&#9;return fallback&#10;}&#10;" />
              <option name="updatedContent" value="package config&#13;&#10;&#13;&#10;import (&#13;&#10;&#9;&quot;fmt&quot;&#13;&#10;&#9;&quot;github.com/hthinh24/go-store/internal/pkg/config&quot;&#13;&#10;&#9;&quot;time&quot;&#13;&#10;)&#13;&#10;&#13;&#10;type AppConfig struct {&#13;&#10;&#9;*config.Config&#13;&#10;}&#13;&#10;&#13;&#10;func LoadConfig(configPath string) (*AppConfig, error) {&#13;&#10;&#9;// Load shared configuration from pkg&#13;&#10;&#9;sharedConfig, err := config.LoadConfig(configPath)&#13;&#10;&#9;if err != nil {&#13;&#10;&#9;&#9;return nil, fmt.Errorf(&quot;error loading shared config: %w&quot;, err)&#13;&#10;&#9;}&#13;&#10;&#13;&#10;&#9;appConfig := &amp;AppConfig{&#13;&#10;&#9;&#9;Config: sharedConfig,&#13;&#10;&#9;}&#13;&#10;&#13;&#10;&#9;return appConfig, nil&#13;&#10;}&#13;&#10;&#13;&#10;// Legacy getter methods for backward compatibility&#13;&#10;func (c *AppConfig) GetDBHost() string {&#13;&#10;&#9;return c.PG.Host&#13;&#10;}&#13;&#10;&#13;&#10;func (c *AppConfig) GetDBPort() string {&#13;&#10;&#9;return c.PG.Port&#13;&#10;}&#13;&#10;&#13;&#10;func (c *AppConfig) GetDBUser() string {&#13;&#10;&#9;return c.PG.User&#13;&#10;}&#13;&#10;&#13;&#10;func (c *AppConfig) GetDBPassword() string {&#13;&#10;&#9;return c.PG.Password&#13;&#10;}&#13;&#10;&#13;&#10;func (c *AppConfig) GetDBName() string {&#13;&#10;&#9;return c.PG.Database&#13;&#10;}&#13;&#10;&#13;&#10;func (c *AppConfig) GetDBSSLMode() string {&#13;&#10;&#9;return c.PG.SSLMode&#13;&#10;}&#13;&#10;&#13;&#10;func (c *AppConfig) GetJWTSecret() string {&#13;&#10;&#9;return c.JWT.Secret&#13;&#10;}&#13;&#10;&#13;&#10;func (c *AppConfig) GetJWTExpire() string {&#13;&#10;&#9;return c.JWT.Expiration&#13;&#10;}&#13;&#10;&#13;&#10;func (c *AppConfig) GetJWTExpiresIn() time.Duration {&#13;&#10;&#9;duration, _ := time.ParseDuration(c.JWT.Expiration)&#13;&#10;&#9;return duration&#13;&#10;}&#13;&#10;&#13;&#10;func (c *AppConfig) GetServerPort() string {&#13;&#10;&#9;return c.App.Port&#13;&#10;}&#13;&#10;&#13;&#10;func (c *AppConfig) GetServerHost() string {&#13;&#10;&#9;return c.App.Host&#13;&#10;}&#13;&#10;&#13;&#10;func (c *AppConfig) GetUserServiceURL() string {&#13;&#10;&#9;return c.Services.GetServiceURL(&quot;identity&quot;)&#13;&#10;}&#13;&#10;&#13;&#10;func (c *AppConfig) GetLogLevel() string {&#13;&#10;&#9;return c.Log.Level&#13;&#10;}&#13;&#10;&#13;&#10;func (c *AppConfig) GetRedisHost() string {&#13;&#10;&#9;return c.Redis.Host&#13;&#10;}&#13;&#10;&#13;&#10;func (c *AppConfig) GetRedisPort() string {&#13;&#10;&#9;return c.Redis.Port&#13;&#10;}&#13;&#10;&#13;&#10;func (c *AppConfig) GetRedisPassword() string {&#13;&#10;&#9;return c.Redis.Password&#13;&#10;}&#13;&#10;&#13;&#10;func (c *AppConfig) GetEnvironment() string {&#13;&#10;&#9;return c.Environment&#13;&#10;}&#13;&#10;&#13;&#10;func (c *AppConfig) GetDatabaseURL() string {&#13;&#10;&#9;return fmt.Sprintf(&quot;host=%s user=%s password=%s dbname=%s port=%s sslmode=%s TimeZone=Asia/Shanghai&quot;,&#13;&#10;&#9;&#9;c.PG.Host, c.PG.User, c.PG.Password, c.PG.Database, c.PG.Port, c.PG.SSLMode)&#13;&#10;}&#13;&#10;&#13;&#10;func (c *AppConfig) GetServerAddress() string {&#13;&#10;&#9;return fmt.Sprintf(&quot;%s:%s&quot;, c.App.Host, c.App.Port)&#13;&#10;}&#13;&#10;&#13;&#10;func (c *AppConfig) IsProduction() bool {&#13;&#10;&#9;return c.Environment == &quot;production&quot;&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>