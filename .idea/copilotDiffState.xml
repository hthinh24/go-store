<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/internal/pkg/auth/auth_middleware.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/internal/pkg/auth/auth_middleware.go" />
              <option name="updatedContent" value="package auth&#10;&#10;import (&#10;&#9;&quot;net/http&quot;&#10;&#9;&quot;strings&quot;&#10;&#9;&quot;time&quot;&#10;&#10;&#9;&quot;github.com/gin-gonic/gin&quot;&#10;&#9;&quot;github.com/golang-jwt/jwt/v4&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/internal/pkg/logger&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/internal/pkg/rest&quot;&#10;)&#10;&#10;type SharedAuthMiddleware struct {&#10;&#9;logger    logger.Logger&#10;&#9;jwtSecret string&#10;}&#10;&#10;type JWTClaims struct {&#10;&#9;UserID           int64     `json:&quot;user_id&quot;`&#10;&#9;Email            string    `json:&quot;email&quot;`&#10;&#9;Roles            []string  `json:&quot;roles&quot;`&#10;&#9;Permissions      []string  `json:&quot;permissions&quot;`&#10;&#9;RefreshExpiresAt time.Time `json:&quot;refresh_expires_at&quot;`&#10;&#9;jwt.RegisteredClaims&#10;}&#10;&#10;func NewSharedAuthMiddleware(logger logger.Logger, jwtSecret string) *SharedAuthMiddleware {&#10;&#9;return &amp;SharedAuthMiddleware{&#10;&#9;&#9;logger:    logger,&#10;&#9;&#9;jwtSecret: jwtSecret,&#10;&#9;}&#10;}&#10;&#10;// AuthRequired validates JWT token and sets user info in context&#10;func (m *SharedAuthMiddleware) AuthRequired() gin.HandlerFunc {&#10;&#9;return func(c *gin.Context) {&#10;&#9;&#9;authHeader := c.GetHeader(&quot;Authorization&quot;)&#10;&#9;&#9;if authHeader == &quot;&quot; {&#10;&#9;&#9;&#9;c.JSON(http.StatusUnauthorized, rest.ErrorResponse{&#10;&#9;&#9;&#9;&#9;ApiError: rest.UnauthorizedError,&#10;&#9;&#9;&#9;&#9;Message:  &quot;Authorization header required&quot;,&#10;&#9;&#9;&#9;})&#10;&#9;&#9;&#9;c.Abort()&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#10;&#9;&#9;tokenString := strings.TrimPrefix(authHeader, &quot;Bearer &quot;)&#10;&#9;&#9;if tokenString == authHeader {&#10;&#9;&#9;&#9;c.JSON(http.StatusUnauthorized, rest.ErrorResponse{&#10;&#9;&#9;&#9;&#9;ApiError: rest.UnauthorizedError,&#10;&#9;&#9;&#9;&#9;Message:  &quot;Bearer token required&quot;,&#10;&#9;&#9;&#9;})&#10;&#9;&#9;&#9;c.Abort()&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#10;&#9;&#9;claims, err := m.validateToken(tokenString)&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;m.logger.Error(&quot;Failed to validate JWT token&quot;, &quot;error&quot;, err)&#10;&#9;&#9;&#9;c.JSON(http.StatusUnauthorized, rest.ErrorResponse{&#10;&#9;&#9;&#9;&#9;ApiError: rest.UnauthorizedError,&#10;&#9;&#9;&#9;&#9;Message:  &quot;Invalid token&quot;,&#10;&#9;&#9;&#9;})&#10;&#9;&#9;&#9;c.Abort()&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// Set user info in context for all services to use&#10;&#9;&#9;c.Set(&quot;user_id&quot;, claims.UserID)&#10;&#9;&#9;c.Set(&quot;email&quot;, claims.Email)&#10;&#9;&#9;c.Set(&quot;roles&quot;, claims.Roles)&#10;&#9;&#9;c.Set(&quot;permissions&quot;, claims.Permissions)&#10;&#10;&#9;&#9;c.Next()&#10;&#9;}&#10;}&#10;&#10;// RequirePermissions checks if user has ALL specified permissions&#10;func (m *SharedAuthMiddleware) RequirePermissions(requiredPermissions ...string) gin.HandlerFunc {&#10;&#9;return func(c *gin.Context) {&#10;&#9;&#9;permissions, exists := c.Get(&quot;permissions&quot;)&#10;&#9;&#9;if !exists {&#10;&#9;&#9;&#9;c.JSON(http.StatusUnauthorized, rest.ErrorResponse{&#10;&#9;&#9;&#9;&#9;ApiError: rest.UnauthorizedError,&#10;&#9;&#9;&#9;&#9;Message:  &quot;User not authenticated&quot;,&#10;&#9;&#9;&#9;})&#10;&#9;&#9;&#9;c.Abort()&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#10;&#9;&#9;userPermissions := permissions.([]string)&#10;&#9;&#9;userPermMap := make(map[string]bool)&#10;&#9;&#9;for _, perm := range userPermissions {&#10;&#9;&#9;&#9;userPermMap[perm] = true&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// Check if user has all required permissions&#10;&#9;&#9;for _, requiredPerm := range requiredPermissions {&#10;&#9;&#9;&#9;if !userPermMap[requiredPerm] {&#10;&#9;&#9;&#9;&#9;m.logger.Warn(&quot;Access denied - missing permission&quot;, &#10;&#9;&#9;&#9;&#9;&#9;&quot;user_id&quot;, c.Get(&quot;user_id&quot;), &#10;&#9;&#9;&#9;&#9;&#9;&quot;required_permission&quot;, requiredPerm)&#10;&#9;&#9;&#9;&#9;c.JSON(http.StatusForbidden, rest.ErrorResponse{&#10;&#9;&#9;&#9;&#9;&#9;ApiError: rest.ForbiddenError,&#10;&#9;&#9;&#9;&#9;&#9;Message:  &quot;Insufficient permissions&quot;,&#10;&#9;&#9;&#9;&#9;})&#10;&#9;&#9;&#9;&#9;c.Abort()&#10;&#9;&#9;&#9;&#9;return&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#10;&#9;&#9;c.Next()&#10;&#9;}&#10;}&#10;&#10;// RequireAnyPermission checks if user has ANY of the specified permissions&#10;func (m *SharedAuthMiddleware) RequireAnyPermission(permissions ...string) gin.HandlerFunc {&#10;&#9;return func(c *gin.Context) {&#10;&#9;&#9;userPermissions, exists := c.Get(&quot;permissions&quot;)&#10;&#9;&#9;if !exists {&#10;&#9;&#9;&#9;c.JSON(http.StatusUnauthorized, rest.ErrorResponse{&#10;&#9;&#9;&#9;&#9;ApiError: rest.UnauthorizedError,&#10;&#9;&#9;&#9;&#9;Message:  &quot;User not authenticated&quot;,&#10;&#9;&#9;&#9;})&#10;&#9;&#9;&#9;c.Abort()&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#10;&#9;&#9;userPerms := userPermissions.([]string)&#10;&#9;&#9;for _, userPerm := range userPerms {&#10;&#9;&#9;&#9;for _, requiredPerm := range permissions {&#10;&#9;&#9;&#9;&#9;if userPerm == requiredPerm {&#10;&#9;&#9;&#9;&#9;&#9;c.Next()&#10;&#9;&#9;&#9;&#9;&#9;return&#10;&#9;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#10;&#9;&#9;c.JSON(http.StatusForbidden, rest.ErrorResponse{&#10;&#9;&#9;&#9;ApiError: rest.ForbiddenError,&#10;&#9;&#9;&#9;Message:  &quot;Insufficient permissions&quot;,&#10;&#9;&#9;})&#10;&#9;&#9;c.Abort()&#10;&#9;}&#10;}&#10;&#10;// RequireRole checks if user has specific role&#10;func (m *SharedAuthMiddleware) RequireRole(role string) gin.HandlerFunc {&#10;&#9;return func(c *gin.Context) {&#10;&#9;&#9;roles, exists := c.Get(&quot;roles&quot;)&#10;&#9;&#9;if !exists {&#10;&#9;&#9;&#9;c.JSON(http.StatusUnauthorized, rest.ErrorResponse{&#10;&#9;&#9;&#9;&#9;ApiError: rest.UnauthorizedError,&#10;&#9;&#9;&#9;&#9;Message:  &quot;User not authenticated&quot;,&#10;&#9;&#9;&#9;})&#10;&#9;&#9;&#9;c.Abort()&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#10;&#9;&#9;userRoles := roles.([]string)&#10;&#9;&#9;for _, userRole := range userRoles {&#10;&#9;&#9;&#9;if userRole == role {&#10;&#9;&#9;&#9;&#9;c.Next()&#10;&#9;&#9;&#9;&#9;return&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#10;&#9;&#9;c.JSON(http.StatusForbidden, rest.ErrorResponse{&#10;&#9;&#9;&#9;ApiError: rest.ForbiddenError,&#10;&#9;&#9;&#9;Message:  &quot;Insufficient role permissions&quot;,&#10;&#9;&#9;})&#10;&#9;&#9;c.Abort()&#10;&#9;}&#10;}&#10;&#10;func (m *SharedAuthMiddleware) validateToken(tokenString string) (*JWTClaims, error) {&#10;&#9;token, err := jwt.ParseWithClaims(tokenString, &amp;JWTClaims{}, func(token *jwt.Token) (interface{}, error) {&#10;&#9;&#9;return []byte(m.jwtSecret), nil&#10;&#9;})&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;claims, ok := token.Claims.(*JWTClaims)&#10;&#9;if !ok {&#10;&#9;&#9;return nil, jwt.ErrTokenMalformed&#10;&#9;}&#10;&#10;&#9;now := time.Now()&#10;&#10;&#9;// Check if refresh token is expired (hard expiration)&#10;&#9;if !claims.RefreshExpiresAt.IsZero() &amp;&amp; now.After(claims.RefreshExpiresAt) {&#10;&#9;&#9;m.logger.Warn(&quot;Refresh token has expired&quot;, &quot;user_id&quot;, claims.UserID)&#10;&#9;&#9;return nil, jwt.NewValidationError(&quot;refresh token expired&quot;, jwt.ValidationErrorExpired)&#10;&#9;}&#10;&#10;&#9;// Check if access token is expired&#10;&#9;if claims.ExpiresAt != nil &amp;&amp; now.After(claims.ExpiresAt.Time) {&#10;&#9;&#9;m.logger.Info(&quot;Access token expired&quot;, &quot;user_id&quot;, claims.UserID)&#10;&#9;&#9;return nil, jwt.NewValidationError(&quot;access token expired&quot;, jwt.ValidationErrorExpired)&#10;&#9;}&#10;&#10;&#9;// Check not before&#10;&#9;if claims.NotBefore != nil &amp;&amp; now.Before(claims.NotBefore.Time) {&#10;&#9;&#9;return nil, jwt.NewValidationError(&quot;token used before valid&quot;, jwt.ValidationErrorNotValidYet)&#10;&#9;}&#10;&#10;&#9;// Check issued at&#10;&#9;if claims.IssuedAt != nil &amp;&amp; now.Before(claims.IssuedAt.Time) {&#10;&#9;&#9;return nil, jwt.NewValidationError(&quot;token issued in the future&quot;, jwt.ValidationErrorIssuedAt)&#10;&#9;}&#10;&#10;&#9;return claims, nil&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/internal/pkg/gateway/api_gateway.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/internal/pkg/gateway/api_gateway.go" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/internal/services/identity/internal/dto/request/refresh_token_request.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/internal/services/identity/internal/dto/request/refresh_token_request.go" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/internal/services/product/internal/infra/repository/postgres/product_repository.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/internal/services/product/internal/infra/repository/postgres/product_repository.go" />
              <option name="originalContent" value="package postgres&#10;&#10;import (&#10;&#9;&quot;strings&quot;&#10;&#10;&#9;&quot;github.com/hthinh24/go-store/internal/pkg/logger&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/services/product/internal/dto/repository&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/services/product/internal/entity&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/services/product/internal/errors&quot;&#10;&#9;&quot;gorm.io/gorm&quot;&#10;)&#10;&#10;type productRepository struct {&#10;&#9;logger logger.Logger&#10;&#9;db     *gorm.DB&#10;}&#10;&#10;func NewProductRepository(logger logger.Logger, db *gorm.DB) *productRepository {&#10;&#9;return &amp;productRepository{&#10;&#9;&#9;logger: logger,&#10;&#9;&#9;db:     db,&#10;&#9;}&#10;}&#10;&#10;func (p *productRepository) BeginTx() error {&#10;&#9;p.logger.Info(&quot;Beginning transaction&quot;)&#10;&#9;tx := p.db.Begin()&#10;&#9;if tx.Error != nil {&#10;&#9;&#9;p.logger.Error(&quot;Failed to begin transaction:&quot;, tx.Error)&#10;&#9;&#9;return tx.Error&#10;&#9;}&#10;&#9;p.db = tx&#10;&#9;return nil&#10;}&#10;&#10;func (p *productRepository) CommitTx() error {&#10;&#9;p.logger.Info(&quot;Committing transaction&quot;)&#10;&#9;if err := p.db.Commit().Error; err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Failed to commit transaction:&quot;, err)&#10;&#10;&#9;&#9;// Rollback the transaction if commit fails&#10;&#9;&#9;if rbErr := p.db.Rollback().Error; rbErr != nil {&#10;&#9;&#9;&#9;p.logger.Error(&quot;Failed to rollback transaction after commit failure:&quot;, rbErr)&#10;&#9;&#9;&#9;return rbErr&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;return nil&#10;}&#10;&#10;func (p *productRepository) FindProductByID(id int64) (*entity.Product, error) {&#10;&#9;p.logger.Info(&quot;Finding product by ID:&quot;, id)&#10;&#10;&#9;var product entity.Product&#10;&#9;if err := p.db.Where(&quot;id = ?&quot;, id).First(&amp;product).Error; err != nil {&#10;&#9;&#9;return nil, errors.ErrProductNotFound{}&#10;&#9;}&#10;&#10;&#9;return &amp;product, nil&#10;}&#10;&#10;func (p *productRepository) FindProductAttributesInfoByProductID(productID int64) (*[]entity.ProductAttributeInfo, error) {&#10;&#9;p.logger.Info(&quot;Finding product attributes info by product ID:&quot;, productID)&#10;&#10;&#9;var productAttributesInfo []entity.ProductAttributeInfo&#10;&#9;if err := p.db.Where(&quot;product_id = ?&quot;, productID).Find(&amp;productAttributesInfo).Error; err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Failed to find product attributes info by product ID:&quot;, productID, &quot;Error:&quot;, err)&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;p.logger.Info(&quot;Found product attributes info:&quot;, productAttributesInfo)&#10;&#9;return &amp;productAttributesInfo, nil&#10;}&#10;&#10;func (p *productRepository) FindProductOptionsInfoByProductID(productID int64) (*[]entity.ProductOptionInfo, error) {&#10;&#9;p.logger.Info(&quot;Finding product options info by product ID:&quot;, productID)&#10;&#10;&#9;var productOptionsInfo []entity.ProductOptionInfo&#10;&#9;if err := p.db.Where(&quot;product_id = ?&quot;, productID).Find(&amp;productOptionsInfo).Error; err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Failed to find product options info by product ID:&quot;, productID, &quot;Error:&quot;, err)&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;p.logger.Info(&quot;Found product options info:&quot;, productOptionsInfo)&#10;&#9;return &amp;productOptionsInfo, nil&#10;}&#10;&#10;func (p *productRepository) FindProductSKUsByProductID(id int64) (*[]repository.ProductSKUDetail, error) {&#10;&#9;p.logger.Info(&quot;Finding product SKUs by product ID:&quot;, id)&#10;&#10;&#9;var productSKUsWithInventory []repository.ProductSKUDetail&#10;&#9;if err := p.db.&#10;&#9;&#9;Table(entity.ProductSKU{}.TableName()+&quot; AS ps&quot;).&#10;&#9;&#9;Select(&quot;ps.id, ps.sku, ps.sku_signature, ps.extra_price,&quot;+&#10;&#9;&#9;&#9;&quot;ps.sale_type&quot;, &quot;ps.sale_value&quot;, &quot;ps.sale_start_date&quot;, &quot;ps.sale_end_date&quot;).&#10;&#9;&#9;Joins(&quot;JOIN product_inventory AS pi ON ps.id = pi.product_sku_id&quot;).&#10;&#9;&#9;Where(&quot;ps.product_id = ?&quot;, id).&#10;&#9;&#9;Find(&amp;productSKUsWithInventory).Error; err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Failed to find product SKUs by product ID:&quot;, id, &quot;Error:&quot;, err)&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;return &amp;productSKUsWithInventory, nil&#10;}&#10;&#10;func (p *productRepository) FindProductAttributesByIDs(productAttributeIDs []int64) (*[]entity.ProductAttribute, error) {&#10;&#9;p.logger.Info(&quot;Finding product attributes by IDs:&quot;, productAttributeIDs)&#10;&#10;&#9;var productAttributes []entity.ProductAttribute&#10;&#9;if err := p.db.Where(&quot;id IN ?&quot;, productAttributeIDs).Find(&amp;productAttributes).Error; err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Failed to find product attributes by IDs:&quot;, productAttributeIDs, &quot;Error:&quot;, err)&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;p.logger.Info(&quot;Found product attributes:&quot;, productAttributes)&#10;&#9;return &amp;productAttributes, nil&#10;}&#10;&#10;func (p *productRepository) FindProductOptionsByIDs(productOptionIDs []int64) (*[]entity.ProductOption, error) {&#10;&#9;p.logger.Info(&quot;Finding product options by IDs:&quot;, productOptionIDs)&#10;&#10;&#9;var productOptions []entity.ProductOption&#10;&#9;if err := p.db.Where(&quot;id IN ?&quot;, productOptionIDs).Find(&amp;productOptions).Error; err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Failed to find product options by IDs:&quot;, productOptionIDs, &quot;Error:&quot;, err)&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;p.logger.Info(&quot;Found product options:&quot;, productOptions)&#10;&#9;return &amp;productOptions, nil&#10;}&#10;&#10;func (p *productRepository) CreateProduct(product *entity.Product) error {&#10;&#9;p.logger.Info(&quot;Creating product:&quot;, product)&#10;&#10;&#9;if err := p.db.Create(product).Error; err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Failed to create product:&quot;, product, &quot;Error:&quot;, err)&#10;&#10;&#9;&#9;// Check for specific database constraint violations&#10;&#9;&#9;errMsg := strings.ToLower(err.Error())&#10;&#10;&#9;&#9;// Check for duplicate slug constraint&#10;&#9;&#9;if strings.Contains(errMsg, &quot;duplicate&quot;) &amp;&amp; strings.Contains(errMsg, &quot;slug&quot;) {&#10;&#9;&#9;&#9;return errors.ErrProductAlreadyExists{Slug: product.Slug}&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// Check for duplicate name constraint&#10;&#9;&#9;if strings.Contains(errMsg, &quot;duplicate&quot;) &amp;&amp; strings.Contains(errMsg, &quot;name&quot;) {&#10;&#9;&#9;&#9;return errors.ErrProductAlreadyExists{Name: product.Name}&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// Check for foreign key violations&#10;&#9;&#9;if strings.Contains(errMsg, &quot;foreign key&quot;) {&#10;&#9;&#9;&#9;if strings.Contains(errMsg, &quot;category&quot;) {&#10;&#9;&#9;&#9;&#9;return errors.ErrCategoryNotFound{ID: product.CategoryID}&#10;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;if strings.Contains(errMsg, &quot;brand&quot;) {&#10;&#9;&#9;&#9;&#9;return errors.ErrBrandNotFound{ID: product.BrandID}&#10;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;if strings.Contains(errMsg, &quot;user&quot;) {&#10;&#9;&#9;&#9;&#9;return errors.ErrUserNotFound{ID: product.UserID}&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// Check for check constraint violations&#10;&#9;&#9;if strings.Contains(errMsg, &quot;check&quot;) || strings.Contains(errMsg, &quot;constraint&quot;) {&#10;&#9;&#9;&#9;if strings.Contains(errMsg, &quot;price&quot;) {&#10;&#9;&#9;&#9;&#9;return errors.ErrInvalidProductData{Field: &quot;price&quot;, Message: &quot;price must be greater than 0&quot;}&#10;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;if strings.Contains(errMsg, &quot;status&quot;) {&#10;&#9;&#9;&#9;&#9;return errors.ErrInvalidProductData{Field: &quot;status&quot;, Message: &quot;invalid status value&quot;}&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// Generic database transaction error&#10;&#9;&#9;return errors.ErrDatabaseTransaction{Operation: &quot;create product&quot;}&#10;&#9;}&#10;&#10;&#9;p.logger.Info(&quot;Product created successfully:&quot;, product.ID)&#10;&#9;return nil&#10;}&#10;&#10;func (p *productRepository) CreateProductAttributeInfo(productAttributeInfos *[]entity.ProductAttributeInfo) error {&#10;&#9;p.logger.Info(&quot;Creating product attribute infos:&quot;, productAttributeInfos)&#10;&#10;&#9;if err := p.db.Create(productAttributeInfos).Error; err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Failed to create product attribute infos:&quot;, productAttributeInfos, &quot;Error:&quot;, err)&#10;&#10;&#9;&#9;errMsg := strings.ToLower(err.Error())&#10;&#10;&#9;&#9;// Check for foreign key violations&#10;&#9;&#9;if strings.Contains(errMsg, &quot;foreign key&quot;) {&#10;&#9;&#9;&#9;if strings.Contains(errMsg, &quot;product_attribute&quot;) {&#10;&#9;&#9;&#9;&#9;return errors.ErrAttributeNotFound{ID: 0} // We'd need to parse which specific ID failed&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#10;&#9;&#9;return errors.ErrDatabaseTransaction{Operation: &quot;create product attribute info&quot;}&#10;&#9;}&#10;&#10;&#9;p.logger.Info(&quot;Product attribute infos created successfully&quot;)&#10;&#9;return nil&#10;}&#10;&#10;func (p *productRepository) CreateProductOptionInfo(productOptionInfos *[]entity.ProductOptionInfo) error {&#10;&#9;p.logger.Info(&quot;Creating product option infos:&quot;, productOptionInfos)&#10;&#10;&#9;if err := p.db.Create(productOptionInfos).Error; err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Failed to create product option infos:&quot;, productOptionInfos, &quot;Error:&quot;, err)&#10;&#10;&#9;&#9;errMsg := strings.ToLower(err.Error())&#10;&#10;&#9;&#9;// Check for foreign key violations&#10;&#9;&#9;if strings.Contains(errMsg, &quot;foreign key&quot;) {&#10;&#9;&#9;&#9;if strings.Contains(errMsg, &quot;product_option&quot;) {&#10;&#9;&#9;&#9;&#9;return errors.ErrOptionNotFound{ID: 0} // We'd need to parse which specific ID failed&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#10;&#9;&#9;return errors.ErrDatabaseTransaction{Operation: &quot;create product option info&quot;}&#10;&#9;}&#10;&#10;&#9;p.logger.Info(&quot;Product option infos created successfully&quot;)&#10;&#9;return nil&#10;}&#10;&#10;func (p *productRepository) CreateProductAttributeValuesIfNotExist(productAttributeValues *[]entity.ProductAttributeValue) error {&#10;&#9;p.logger.Info(&quot;Creating product attribute values&quot;)&#10;&#10;&#9;for _, value := range *productAttributeValues {&#10;&#9;&#9;if err := p.db.Where(&quot;value = ?&quot;, value.Value).FirstOrCreate(&amp;value).Error; err != nil {&#10;&#9;&#9;&#9;p.logger.Error(&quot;Failed to create or find product attribute value:&quot;, value, &quot;Error:&quot;, err)&#10;&#9;&#9;&#9;return err&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;p.logger.Info(&quot;Product attribute values created successfully&quot;)&#10;&#9;return nil&#10;}&#10;&#10;func (p *productRepository) CreateProductProductAttributeValues(i *[]entity.ProductProductAttributeValue) error {&#10;&#9;p.logger.Info(&quot;Creating product product attribute values:&quot;, i)&#10;&#10;&#9;if err := p.db.Create(i).Error; err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Failed to create product product attribute values:&quot;, i, &quot;Error:&quot;, err)&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;p.logger.Info(&quot;Product product attribute values created successfully&quot;)&#10;&#9;return nil&#10;}&#10;&#10;func (p *productRepository) CreateProductSKUs(productSKUs *[]entity.ProductSKU) error {&#10;&#9;p.logger.Info(&quot;Creating product SKUs:&quot;, productSKUs)&#10;&#10;&#9;if err := p.db.Create(productSKUs).Error; err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Failed to create product SKUs:&quot;, productSKUs, &quot;Error:&quot;, err)&#10;&#10;&#9;&#9;errMsg := strings.ToLower(err.Error())&#10;&#10;&#9;&#9;// Check for duplicate SKU constraint&#10;&#9;&#9;if strings.Contains(errMsg, &quot;duplicate&quot;) &amp;&amp; strings.Contains(errMsg, &quot;sku&quot;) {&#10;&#9;&#9;&#9;// Extract SKU from productSKUs if possible&#10;&#9;&#9;&#9;if len(*productSKUs) &gt; 0 {&#10;&#9;&#9;&#9;&#9;return errors.ErrSKUAlreadyExists{SKU: (*productSKUs)[0].SKU}&#10;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;return errors.ErrSKUAlreadyExists{SKU: &quot;unknown&quot;}&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// Check for invalid price&#10;&#9;&#9;if strings.Contains(errMsg, &quot;check&quot;) &amp;&amp; strings.Contains(errMsg, &quot;price&quot;) {&#10;&#9;&#9;&#9;return errors.ErrInvalidSKUData{SKU: &quot;unknown&quot;, Message: &quot;price must be greater than or equal to 0&quot;}&#10;&#9;&#9;}&#10;&#10;&#9;&#9;return errors.ErrDatabaseTransaction{Operation: &quot;create product SKUs&quot;}&#10;&#9;}&#10;&#10;&#9;p.logger.Info(&quot;Product SKUs created successfully&quot;)&#10;&#9;return nil&#10;}&#10;&#10;func (p *productRepository) CreateProductInventories(inventories *[]entity.ProductInventory) error {&#10;&#9;p.logger.Info(&quot;Creating product inventories:&quot;, inventories)&#10;&#10;&#9;if err := p.db.Create(inventories).Error; err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Failed to create product inventories:&quot;, inventories, &quot;Error:&quot;, err)&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;p.logger.Info(&quot;Product inventories created successfully&quot;)&#10;&#9;return nil&#10;}&#10;&#10;func (p *productRepository) CreateProductOptionCombinations(productOptionCombinations *[]entity.ProductOptionCombination) error {&#10;&#9;p.logger.Info(&quot;Creating product option combinations:&quot;, productOptionCombinations)&#10;&#10;&#9;if err := p.db.Create(productOptionCombinations).Error; err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Failed to create product option combinations:&quot;, productOptionCombinations, &quot;Error:&quot;, err)&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;p.logger.Info(&quot;Product option combinations created successfully&quot;)&#10;&#9;return nil&#10;}&#10;&#10;func (p *productRepository) CreateProductOptionValuesIfNotExist(productOptionValues *[]entity.ProductOptionValue) error {&#10;&#9;p.logger.Info(&quot;Creating product option values if not exist:&quot;, productOptionValues)&#10;&#10;&#9;for _, value := range *productOptionValues {&#10;&#9;&#9;if err := p.db.Where(&quot;value = ?&quot;, value.Value).FirstOrCreate(&amp;value).Error; err != nil {&#10;&#9;&#9;&#9;p.logger.Error(&quot;Failed to create or find product option value:&quot;, value, &quot;Error:&quot;, err)&#10;&#9;&#9;&#9;return err&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;p.logger.Info(&quot;Product option values created or found successfully&quot;)&#10;&#9;return nil&#10;}&#10;&#10;func (p *productRepository) DeleteProduct(id int64) error {&#10;&#9;p.logger.Info(&quot;Deleting product with ID:&quot;, id)&#10;&#10;&#9;if err := p.db.Where(&quot;id = ?&quot;, id).Delete(&amp;entity.Product{}).Error; err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Failed to delete product with ID:&quot;, id, &quot;Error:&quot;, err)&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;p.logger.Info(&quot;Product deleted successfully:&quot;, id)&#10;&#9;return nil&#10;}&#10;" />
              <option name="updatedContent" value="package postgres&#10;&#10;import (&#10;&#9;&quot;errors&quot;&#10;&#9;&quot;strings&quot;&#10;&#10;&#9;&quot;github.com/hthinh24/go-store/internal/pkg/logger&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/services/product&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/services/product/internal/dto/repository&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/services/product/internal/entity&quot;&#10;&#9;productErrors &quot;github.com/hthinh24/go-store/services/product/internal/errors&quot;&#10;&#9;&quot;gorm.io/gorm&quot;&#10;)&#10;&#10;type productRepository struct {&#10;&#9;logger        logger.Logger&#10;&#9;db            *gorm.DB&#10;&#9;isTransaction bool&#10;}&#10;&#10;func NewProductRepository(logger logger.Logger, db *gorm.DB) *productRepository {&#10;&#9;return &amp;productRepository{&#10;&#9;&#9;logger:        logger,&#10;&#9;&#9;db:            db,&#10;&#9;&#9;isTransaction: false,&#10;&#9;}&#10;}&#10;&#10;// Transaction methods&#10;func (p *productRepository) WithTransaction() (product.ProductRepository, error) {&#10;&#9;if p.isTransaction {&#10;&#9;&#9;return nil, errors.New(&quot;repository is already in transaction mode&quot;)&#10;&#9;}&#10;&#10;&#9;p.logger.Info(&quot;Creating transactional repository&quot;)&#10;&#10;&#9;tx := p.db.Begin()&#10;&#9;if tx.Error != nil {&#10;&#9;&#9;p.logger.Error(&quot;Failed to begin transaction:&quot;, tx.Error)&#10;&#9;&#9;return nil, tx.Error&#10;&#9;}&#10;&#10;&#9;return &amp;productRepository{&#10;&#9;&#9;logger:        p.logger,&#10;&#9;&#9;db:            tx,&#10;&#9;&#9;isTransaction: true,&#10;&#9;}, nil&#10;}&#10;&#10;func (p *productRepository) Commit() error {&#10;&#9;if !p.isTransaction {&#10;&#9;&#9;return errors.New(&quot;repository is not in transaction mode&quot;)&#10;&#9;}&#10;&#10;&#9;p.logger.Info(&quot;Committing transaction&quot;)&#10;&#10;&#9;if err := p.db.Commit().Error; err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Failed to commit transaction:&quot;, err)&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;p.logger.Info(&quot;Transaction committed successfully&quot;)&#10;&#9;return nil&#10;}&#10;&#10;func (p *productRepository) Rollback() error {&#10;&#9;if !p.isTransaction {&#10;&#9;&#9;return errors.New(&quot;repository is not in transaction mode&quot;)&#10;&#9;}&#10;&#10;&#9;p.logger.Info(&quot;Rolling back transaction&quot;)&#10;&#10;&#9;if err := p.db.Rollback().Error; err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Failed to rollback transaction:&quot;, err)&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;p.logger.Info(&quot;Transaction rolled back successfully&quot;)&#10;&#9;return nil&#10;}&#10;&#10;func (p *productRepository) IsInTransaction() bool {&#10;&#9;return p.isTransaction&#10;}&#10;&#10;func (p *productRepository) FindProductByID(id int64) (*entity.Product, error) {&#10;&#9;p.logger.Info(&quot;Finding product by ID:&quot;, id)&#10;&#10;&#9;var product entity.Product&#10;&#9;if err := p.db.Where(&quot;id = ?&quot;, id).First(&amp;product).Error; err != nil {&#10;&#9;&#9;return nil, productErrors.ErrProductNotFound{}&#10;&#9;}&#10;&#10;&#9;return &amp;product, nil&#10;}&#10;&#10;func (p *productRepository) FindProductAttributesInfoByProductID(productID int64) (*[]entity.ProductAttributeInfo, error) {&#10;&#9;p.logger.Info(&quot;Finding product attributes info by product ID:&quot;, productID)&#10;&#10;&#9;var productAttributesInfo []entity.ProductAttributeInfo&#10;&#9;if err := p.db.Where(&quot;product_id = ?&quot;, productID).Find(&amp;productAttributesInfo).Error; err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Failed to find product attributes info by product ID:&quot;, productID, &quot;Error:&quot;, err)&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;p.logger.Info(&quot;Found product attributes info:&quot;, productAttributesInfo)&#10;&#9;return &amp;productAttributesInfo, nil&#10;}&#10;&#10;func (p *productRepository) FindProductOptionsInfoByProductID(productID int64) (*[]entity.ProductOptionInfo, error) {&#10;&#9;p.logger.Info(&quot;Finding product options info by product ID:&quot;, productID)&#10;&#10;&#9;var productOptionsInfo []entity.ProductOptionInfo&#10;&#9;if err := p.db.Where(&quot;product_id = ?&quot;, productID).Find(&amp;productOptionsInfo).Error; err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Failed to find product options info by product ID:&quot;, productID, &quot;Error:&quot;, err)&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;p.logger.Info(&quot;Found product options info:&quot;, productOptionsInfo)&#10;&#9;return &amp;productOptionsInfo, nil&#10;}&#10;&#10;func (p *productRepository) FindProductSKUsByProductID(id int64) (*[]repository.ProductSKUDetail, error) {&#10;&#9;p.logger.Info(&quot;Finding product SKUs by product ID:&quot;, id)&#10;&#10;&#9;var productSKUsWithInventory []repository.ProductSKUDetail&#10;&#9;if err := p.db.&#10;&#9;&#9;Table(entity.ProductSKU{}.TableName()+&quot; AS ps&quot;).&#10;&#9;&#9;Select(&quot;ps.id, ps.sku, ps.sku_signature, ps.extra_price,&quot;+&#10;&#9;&#9;&#9;&quot;ps.sale_type&quot;, &quot;ps.sale_value&quot;, &quot;ps.sale_start_date&quot;, &quot;ps.sale_end_date&quot;).&#10;&#9;&#9;Joins(&quot;JOIN product_inventory AS pi ON ps.id = pi.product_sku_id&quot;).&#10;&#9;&#9;Where(&quot;ps.product_id = ?&quot;, id).&#10;&#9;&#9;Find(&amp;productSKUsWithInventory).Error; err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Failed to find product SKUs by product ID:&quot;, id, &quot;Error:&quot;, err)&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;return &amp;productSKUsWithInventory, nil&#10;}&#10;&#10;func (p *productRepository) FindProductAttributesByIDs(productAttributeIDs []int64) (*[]entity.ProductAttribute, error) {&#10;&#9;p.logger.Info(&quot;Finding product attributes by IDs:&quot;, productAttributeIDs)&#10;&#10;&#9;var productAttributes []entity.ProductAttribute&#10;&#9;if err := p.db.Where(&quot;id IN ?&quot;, productAttributeIDs).Find(&amp;productAttributes).Error; err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Failed to find product attributes by IDs:&quot;, productAttributeIDs, &quot;Error:&quot;, err)&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;p.logger.Info(&quot;Found product attributes:&quot;, productAttributes)&#10;&#9;return &amp;productAttributes, nil&#10;}&#10;&#10;func (p *productRepository) FindProductOptionsByIDs(productOptionIDs []int64) (*[]entity.ProductOption, error) {&#10;&#9;p.logger.Info(&quot;Finding product options by IDs:&quot;, productOptionIDs)&#10;&#10;&#9;var productOptions []entity.ProductOption&#10;&#9;if err := p.db.Where(&quot;id IN ?&quot;, productOptionIDs).Find(&amp;productOptions).Error; err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Failed to find product options by IDs:&quot;, productOptionIDs, &quot;Error:&quot;, err)&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;p.logger.Info(&quot;Found product options:&quot;, productOptions)&#10;&#9;return &amp;productOptions, nil&#10;}&#10;&#10;func (p *productRepository) CreateProduct(product *entity.Product) error {&#10;&#9;p.logger.Info(&quot;Creating product:&quot;, product)&#10;&#10;&#9;if err := p.db.Create(product).Error; err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Failed to create product:&quot;, product, &quot;Error:&quot;, err)&#10;&#10;&#9;&#9;// Check for specific database constraint violations&#10;&#9;&#9;errMsg := strings.ToLower(err.Error())&#10;&#10;&#9;&#9;// Check for duplicate slug constraint&#10;&#9;&#9;if strings.Contains(errMsg, &quot;duplicate&quot;) &amp;&amp; strings.Contains(errMsg, &quot;slug&quot;) {&#10;&#9;&#9;&#9;return productErrors.ErrProductAlreadyExists{Slug: product.Slug}&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// Check for duplicate name constraint&#10;&#9;&#9;if strings.Contains(errMsg, &quot;duplicate&quot;) &amp;&amp; strings.Contains(errMsg, &quot;name&quot;) {&#10;&#9;&#9;&#9;return productErrors.ErrProductAlreadyExists{Name: product.Name}&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// Check for foreign key violations&#10;&#9;&#9;if strings.Contains(errMsg, &quot;foreign key&quot;) {&#10;&#9;&#9;&#9;if strings.Contains(errMsg, &quot;category&quot;) {&#10;&#9;&#9;&#9;&#9;return productErrors.ErrCategoryNotFound{ID: product.CategoryID}&#10;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;if strings.Contains(errMsg, &quot;brand&quot;) {&#10;&#9;&#9;&#9;&#9;return productErrors.ErrBrandNotFound{ID: product.BrandID}&#10;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;if strings.Contains(errMsg, &quot;user&quot;) {&#10;&#9;&#9;&#9;&#9;return productErrors.ErrUserNotFound{ID: product.UserID}&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// Check for check constraint violations&#10;&#9;&#9;if strings.Contains(errMsg, &quot;check&quot;) || strings.Contains(errMsg, &quot;constraint&quot;) {&#10;&#9;&#9;&#9;if strings.Contains(errMsg, &quot;price&quot;) {&#10;&#9;&#9;&#9;&#9;return productErrors.ErrInvalidProductData{Field: &quot;price&quot;, Message: &quot;price must be greater than 0&quot;}&#10;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;if strings.Contains(errMsg, &quot;status&quot;) {&#10;&#9;&#9;&#9;&#9;return productErrors.ErrInvalidProductData{Field: &quot;status&quot;, Message: &quot;invalid status value&quot;}&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// Generic database transaction error&#10;&#9;&#9;return productErrors.ErrDatabaseTransaction{Operation: &quot;create product&quot;}&#10;&#9;}&#10;&#10;&#9;p.logger.Info(&quot;Product created successfully:&quot;, product.ID)&#10;&#9;return nil&#10;}&#10;&#10;func (p *productRepository) CreateProductAttributeInfo(productAttributeInfos *[]entity.ProductAttributeInfo) error {&#10;&#9;p.logger.Info(&quot;Creating product attribute infos:&quot;, productAttributeInfos)&#10;&#10;&#9;if err := p.db.Create(productAttributeInfos).Error; err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Failed to create product attribute infos:&quot;, productAttributeInfos, &quot;Error:&quot;, err)&#10;&#10;&#9;&#9;errMsg := strings.ToLower(err.Error())&#10;&#10;&#9;&#9;// Check for foreign key violations&#10;&#9;&#9;if strings.Contains(errMsg, &quot;foreign key&quot;) {&#10;&#9;&#9;&#9;if strings.Contains(errMsg, &quot;product_attribute&quot;) {&#10;&#9;&#9;&#9;&#9;return productErrors.ErrAttributeNotFound{ID: 0} // We'd need to parse which specific ID failed&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#10;&#9;&#9;return productErrors.ErrDatabaseTransaction{Operation: &quot;create product attribute info&quot;}&#10;&#9;}&#10;&#10;&#9;p.logger.Info(&quot;Product attribute infos created successfully&quot;)&#10;&#9;return nil&#10;}&#10;&#10;func (p *productRepository) CreateProductOptionInfo(productOptionInfos *[]entity.ProductOptionInfo) error {&#10;&#9;p.logger.Info(&quot;Creating product option infos:&quot;, productOptionInfos)&#10;&#10;&#9;if err := p.db.Create(productOptionInfos).Error; err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Failed to create product option infos:&quot;, productOptionInfos, &quot;Error:&quot;, err)&#10;&#10;&#9;&#9;errMsg := strings.ToLower(err.Error())&#10;&#10;&#9;&#9;// Check for foreign key violations&#10;&#9;&#9;if strings.Contains(errMsg, &quot;foreign key&quot;) {&#10;&#9;&#9;&#9;if strings.Contains(errMsg, &quot;product_option&quot;) {&#10;&#9;&#9;&#9;&#9;return productErrors.ErrOptionNotFound{ID: 0} // We'd need to parse which specific ID failed&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#10;&#9;&#9;return productErrors.ErrDatabaseTransaction{Operation: &quot;create product option info&quot;}&#10;&#9;}&#10;&#10;&#9;p.logger.Info(&quot;Product option infos created successfully&quot;)&#10;&#9;return nil&#10;}&#10;&#10;func (p *productRepository) CreateProductAttributeValuesIfNotExist(productAttributeValues *[]entity.ProductAttributeValue) error {&#10;&#9;p.logger.Info(&quot;Creating product attribute values&quot;)&#10;&#10;&#9;for _, value := range *productAttributeValues {&#10;&#9;&#9;if err := p.db.Where(&quot;value = ?&quot;, value.Value).FirstOrCreate(&amp;value).Error; err != nil {&#10;&#9;&#9;&#9;p.logger.Error(&quot;Failed to create or find product attribute value:&quot;, value, &quot;Error:&quot;, err)&#10;&#9;&#9;&#9;return err&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;p.logger.Info(&quot;Product attribute values created successfully&quot;)&#10;&#9;return nil&#10;}&#10;&#10;func (p *productRepository) CreateProductProductAttributeValues(i *[]entity.ProductProductAttributeValue) error {&#10;&#9;p.logger.Info(&quot;Creating product product attribute values:&quot;, i)&#10;&#10;&#9;if err := p.db.Create(i).Error; err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Failed to create product product attribute values:&quot;, i, &quot;Error:&quot;, err)&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;p.logger.Info(&quot;Product product attribute values created successfully&quot;)&#10;&#9;return nil&#10;}&#10;&#10;func (p *productRepository) CreateProductSKUs(productSKUs *[]entity.ProductSKU) error {&#10;&#9;p.logger.Info(&quot;Creating product SKUs:&quot;, productSKUs)&#10;&#10;&#9;if err := p.db.Create(productSKUs).Error; err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Failed to create product SKUs:&quot;, productSKUs, &quot;Error:&quot;, err)&#10;&#10;&#9;&#9;errMsg := strings.ToLower(err.Error())&#10;&#10;&#9;&#9;// Check for duplicate SKU constraint&#10;&#9;&#9;if strings.Contains(errMsg, &quot;duplicate&quot;) &amp;&amp; strings.Contains(errMsg, &quot;sku&quot;) {&#10;&#9;&#9;&#9;// Extract SKU from productSKUs if possible&#10;&#9;&#9;&#9;if len(*productSKUs) &gt; 0 {&#10;&#9;&#9;&#9;&#9;return productErrors.ErrSKUAlreadyExists{SKU: (*productSKUs)[0].SKU}&#10;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;return productErrors.ErrSKUAlreadyExists{SKU: &quot;unknown&quot;}&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// Check for invalid price&#10;&#9;&#9;if strings.Contains(errMsg, &quot;check&quot;) &amp;&amp; strings.Contains(errMsg, &quot;price&quot;) {&#10;&#9;&#9;&#9;return productErrors.ErrInvalidSKUData{SKU: &quot;unknown&quot;, Message: &quot;price must be greater than or equal to 0&quot;}&#10;&#9;&#9;}&#10;&#10;&#9;&#9;return productErrors.ErrDatabaseTransaction{Operation: &quot;create product SKUs&quot;}&#10;&#9;}&#10;&#10;&#9;p.logger.Info(&quot;Product SKUs created successfully&quot;)&#10;&#9;return nil&#10;}&#10;&#10;func (p *productRepository) CreateProductInventories(inventories *[]entity.ProductInventory) error {&#10;&#9;p.logger.Info(&quot;Creating product inventories:&quot;, inventories)&#10;&#10;&#9;if err := p.db.Create(inventories).Error; err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Failed to create product inventories:&quot;, inventories, &quot;Error:&quot;, err)&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;p.logger.Info(&quot;Product inventories created successfully&quot;)&#10;&#9;return nil&#10;}&#10;&#10;func (p *productRepository) CreateProductOptionCombinations(productOptionCombinations *[]entity.ProductOptionCombination) error {&#10;&#9;p.logger.Info(&quot;Creating product option combinations:&quot;, productOptionCombinations)&#10;&#10;&#9;if err := p.db.Create(productOptionCombinations).Error; err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Failed to create product option combinations:&quot;, productOptionCombinations, &quot;Error:&quot;, err)&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;p.logger.Info(&quot;Product option combinations created successfully&quot;)&#10;&#9;return nil&#10;}&#10;&#10;func (p *productRepository) CreateProductOptionValuesIfNotExist(productOptionValues *[]entity.ProductOptionValue) error {&#10;&#9;p.logger.Info(&quot;Creating product option values if not exist:&quot;, productOptionValues)&#10;&#10;&#9;for _, value := range *productOptionValues {&#10;&#9;&#9;if err := p.db.Where(&quot;value = ?&quot;, value.Value).FirstOrCreate(&amp;value).Error; err != nil {&#10;&#9;&#9;&#9;p.logger.Error(&quot;Failed to create or find product option value:&quot;, value, &quot;Error:&quot;, err)&#10;&#9;&#9;&#9;return err&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;p.logger.Info(&quot;Product option values created or found successfully&quot;)&#10;&#9;return nil&#10;}&#10;&#10;func (p *productRepository) DeleteProduct(id int64) error {&#10;&#9;p.logger.Info(&quot;Deleting product with ID:&quot;, id)&#10;&#10;&#9;if err := p.db.Where(&quot;id = ?&quot;, id).Delete(&amp;entity.Product{}).Error; err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Failed to delete product with ID:&quot;, id, &quot;Error:&quot;, err)&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;p.logger.Info(&quot;Product deleted successfully:&quot;, id)&#10;&#9;return nil&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/internal/services/product/internal/service/product_service.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/internal/services/product/internal/service/product_service.go" />
              <option name="originalContent" value="package service&#10;&#10;import (&#10;&#9;&quot;github.com/hthinh24/go-store/internal/pkg/logger&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/services/product&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/services/product/internal/constants&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/services/product/internal/dto/repository&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/services/product/internal/dto/request&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/services/product/internal/dto/response&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/services/product/internal/entity&quot;&#10;&#9;&quot;strings&quot;&#10;)&#10;&#10;type productService struct {&#10;&#9;logger            logger.Logger&#10;&#9;productRepository product.ProductRepository&#10;}&#10;&#10;// NewProductService creates a new instance of ProductService&#10;func NewProductService(logger logger.Logger, productRepository product.ProductRepository) product.ProductService {&#10;&#9;return &amp;productService{&#10;&#9;&#9;logger:            logger,&#10;&#9;&#9;productRepository: productRepository,&#10;&#9;}&#10;}&#10;&#10;func (p *productService) GetProductByID(id int64) (*response.ProductResponse, error) {&#10;&#9;p.logger.Info(&quot;Get product with ID: &quot;, id)&#10;&#10;&#9;productEntity, err := p.productRepository.FindProductByID(id)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;p.logger.Info(&quot;Product retrieved successfully, ID: &quot;, productEntity.ID)&#10;&#9;return p.createProductResponse(productEntity), nil&#10;}&#10;&#10;func (p *productService) GetProductDetailByID(id int64) (*response.ProductDetailResponse, error) {&#10;&#9;p.logger.Info(&quot;Get product with ID: &quot;, id)&#10;&#10;&#9;productEntity, err := p.productRepository.FindProductByID(id)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;p.logger.Info(&quot;Product retrieved successfully, ID: &quot;, productEntity.ID)&#10;&#9;return p.createProductDetailResponse(productEntity), nil&#10;}&#10;&#10;func (p *productService) CreateProduct(data *request.CreateProductRequest) (*response.ProductDetailResponse, error) {&#10;&#9;p.logger.Info(&quot;Creating product with name&quot;, data.Name)&#10;&#10;&#9;// Create Product Entity from request data&#10;&#9;productEntity := p.createProductEntity(data)&#10;&#10;&#9;// Begin a transaction&#10;&#9;if err := p.productRepository.BeginTx(); err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;// 1. Create &amp; Insert the base product entity&#10;&#9;if err := p.processCreateProduct(productEntity); err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;// 2. Create &amp; Insert product attribute info&#10;&#9;if err := p.processCreateProductAttributeInfo(productEntity.ID, data.ProductAttributes); err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;// 3. Create &amp; Insert product option info&#10;&#9;if err := p.processCreateProductOptionInfo(productEntity.ID, data.OptionValues); err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;// 4. Create &amp; Insert product attribute values&#10;&#9;if err := p.processCreateProductAttributes(data.ProductAttributes); err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;// 5. Create &amp; Insert product SKUs&#10;&#9;if err := p.processCreateProductSKUs(productEntity.ID, productEntity.Name, &amp;data.ProductSKUs); err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;// 6. Create &amp; Insert product option combinations&#10;&#9;if err := p.processCreateProductOptionCombinations(productEntity.ID, data.OptionValues); err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;// Commit the transaction&#10;&#9;if err := p.productRepository.CommitTx(); err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Error committing transaction, rolling back&quot;, err)&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;p.logger.Info(&quot;Product created successfully, ID: &quot;, productEntity.ID)&#10;&#9;return p.createProductDetailResponse(productEntity), nil&#10;}&#10;&#10;func (p *productService) DeleteProduct(id int64) error {&#10;&#9;p.logger.Info(&quot;Deleting product with ID: &quot;, id)&#10;&#10;&#9;err := p.productRepository.DeleteProduct(id)&#10;&#9;if err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Error deleting product&quot;, err)&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;p.logger.Info(&quot;Product deleted successfully, ID: &quot;, id)&#10;&#9;return nil&#10;}&#10;&#10;func (p *productService) processCreateProduct(product *entity.Product) error {&#10;&#9;if err := p.productRepository.CreateProduct(product); err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Error saving product to repository, error: &quot;, err)&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;return nil&#10;}&#10;&#10;func (p *productService) processCreateProductAttributeInfo(productID int64, attributeMap map[int64][]string) error {&#10;&#9;var attributeIDs []int64&#10;&#9;var productAttributeInfoEntities []entity.ProductAttributeInfo&#10;&#9;for attributeID, _ := range attributeMap {&#10;&#9;&#9;attributeIDs = append(attributeIDs, attributeID)&#10;&#9;}&#10;&#10;&#9;// 1. Find product attributes by IDs&#10;&#9;productAttributes, err := p.productRepository.FindProductAttributesByIDs(attributeIDs)&#10;&#9;if err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Error finding product attributes by IDs, error: &quot;, err)&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;// 2. Create product attribute info entities from the attribute map&#10;&#9;for _, attribute := range *productAttributes {&#10;&#9;&#9;if values, ok := attributeMap[attribute.ID]; ok {&#10;&#9;&#9;&#9;for _, value := range values {&#10;&#9;&#9;&#9;&#9;productAttributeInfoEntity := p.createProductAttributeInfoEntity(productID, attribute.Name, value)&#10;&#9;&#9;&#9;&#9;productAttributeInfoEntities = append(productAttributeInfoEntities, *productAttributeInfoEntity)&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;// 3. Save product attribute info entities to the repository&#10;&#9;if err := p.productRepository.CreateProductAttributeInfo(&amp;productAttributeInfoEntities); err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Error saving product attribute info to repository, error: &quot;, err)&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;return nil&#10;}&#10;&#10;func (p *productService) processCreateProductOptionInfo(productID int64, optionMap map[int64][]string) error {&#10;&#9;var productOptionIDs []int64&#10;&#9;var productOptionInfoEntities []entity.ProductOptionInfo&#10;&#10;&#9;for productOptionID, _ := range optionMap {&#10;&#9;&#9;productOptionIDs = append(productOptionIDs, productOptionID)&#10;&#9;}&#10;&#10;&#9;// 1. Find product options by IDs&#10;&#9;productOptions, err := p.productRepository.FindProductOptionsByIDs(productOptionIDs)&#10;&#9;if err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Error finding product options by IDs, error: &quot;, err)&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;// 2. Create product option info entities from the option map&#10;&#9;for _, option := range *productOptions {&#10;&#9;&#9;if values, ok := optionMap[option.ID]; ok {&#10;&#9;&#9;&#9;for _, value := range values {&#10;&#9;&#9;&#9;&#9;productOptionInfoEntity := p.createProductOptionInfoEntity(productID, option.Name, value)&#10;&#9;&#9;&#9;&#9;productOptionInfoEntities = append(productOptionInfoEntities, *productOptionInfoEntity)&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;// 3. Save product option info entities to the repository&#10;&#9;if err := p.productRepository.CreateProductOptionInfo(&amp;productOptionInfoEntities); err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Error saving product option info to repository, error: &quot;, err)&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;return nil&#10;}&#10;&#10;func (p *productService) processCreateProductAttributes(attributeValues map[int64][]string) error {&#10;&#9;// 1. Create product attribute values entities from the attribute values map&#10;&#9;var productAttributeValueEntities []entity.ProductAttributeValue&#10;&#9;for attributeID, values := range attributeValues {&#10;&#9;&#9;for _, value := range values {&#10;&#9;&#9;&#9;productAttributeValueEntity := p.createProductAttributeValueEntity(attributeID, value)&#10;&#9;&#9;&#9;productAttributeValueEntities = append(productAttributeValueEntities, *productAttributeValueEntity)&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;// 2. Save product attribute values to the repository&#10;&#9;err := p.productRepository.CreateProductAttributeValuesIfNotExist(&amp;productAttributeValueEntities)&#10;&#9;if err != nil {&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;return nil&#10;}&#10;&#10;func (p *productService) processCreateProductSKUs(productID int64,&#10;&#9;productName string,&#10;&#9;productSKUData *[]request.CreateProductSKURequest) error {&#10;&#9;// 1. Create product SKU entities from the product SKU data&#10;&#9;var productSKUEntities []entity.ProductSKU&#10;&#9;for _, sku := range *productSKUData {&#10;&#9;&#9;productSKUEntity := p.createProductSKUEntity(productID, productName, &amp;sku)&#10;&#9;&#9;productSKUEntities = append(productSKUEntities, *productSKUEntity)&#10;&#9;}&#10;&#10;&#9;// 2. Save product SKUs to the repository&#10;&#9;if err := p.productRepository.CreateProductSKUs(&amp;productSKUEntities); err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Error saving product SKUs to repository, error: &quot;, err)&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;// 3. Create product inventory entities based on product SKUs and stock data&#10;&#9;var productInventoryEntities []entity.ProductInventory&#10;&#9;for i, productSKUEntity := range productSKUEntities {&#10;&#9;&#9;productInventory := p.createProductInventoryEntity(&amp;productSKUEntity, (*productSKUData)[i].Stock)&#10;&#9;&#9;productInventoryEntities = append(productInventoryEntities, *productInventory)&#10;&#9;}&#10;&#10;&#9;// 4. Save product inventory entities to repository&#10;&#9;if err := p.productRepository.CreateProductInventories(&amp;productInventoryEntities); err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Error saving product inventory to repository, error: &quot;, err)&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;return nil&#10;}&#10;&#10;func (p *productService) processCreateProductOptionCombinations(id int64, optionValues map[int64][]string) error {&#10;&#9;var productOptionCombinationEntities []entity.ProductOptionCombination&#10;&#10;&#9;// 1. Create product option combination entities from the option values map&#10;&#9;displayOrder := int32(1)&#10;&#9;for option, _ := range optionValues {&#10;&#9;&#9;productOptionCombinationEntity := p.createProductOptionCombinationEntity(id, option, int32(displayOrder))&#10;&#9;&#9;productOptionCombinationEntities = append(productOptionCombinationEntities, *productOptionCombinationEntity)&#10;&#9;&#9;displayOrder++&#10;&#9;}&#10;&#9;// 2. Save product option combinations to the repository&#10;&#9;if err := p.productRepository.CreateProductOptionCombinations(&amp;productOptionCombinationEntities); err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Error saving product option combinations to repository, error: &quot;, err)&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;// 3. Create product option value entities from the option values map&#10;&#9;var productOptionValueEntities []entity.ProductOptionValue&#10;&#9;for optionID, values := range optionValues {&#10;&#9;&#9;for _, value := range values {&#10;&#9;&#9;&#9;productOptionValueEntity := p.createProductOptionValueEntity(optionID, value)&#10;&#9;&#9;&#9;productOptionValueEntities = append(productOptionValueEntities, *productOptionValueEntity)&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;// 4. Create product option values in the repository if they do not already exist&#10;&#9;if err := p.productRepository.CreateProductOptionValuesIfNotExist(&amp;productOptionValueEntities); err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Error saving product option values to repository, error: &quot;, err)&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;return nil&#10;}&#10;&#10;func (p *productService) createProductEntity(data *request.CreateProductRequest) *entity.Product {&#10;&#9;return &amp;entity.Product{&#10;&#9;&#9;Name:             data.Name,&#10;&#9;&#9;Description:      data.Description,&#10;&#9;&#9;ShortDescription: data.ShortDescription,&#10;&#9;&#9;ImageURL:         data.ImageURL,&#10;&#9;&#9;Slug:             data.Slug,&#10;&#9;&#9;BasePrice:        data.BasePrice,&#10;&#9;&#9;SalePrice:        data.SalePrice,&#10;&#9;&#9;IsFeatured:       data.IsFeatured,&#10;&#9;&#9;SaleStartDate:    data.SaleStartDate,&#10;&#9;&#9;SaleEndDate:      data.SaleEndDate,&#10;&#9;&#9;Status:           data.Status,&#10;&#9;&#9;BrandID:          data.BrandID,&#10;&#9;&#9;CategoryID:       data.CategoryID,&#10;&#9;&#9;UserID:           data.UserID,&#10;&#9;}&#10;}&#10;&#10;func (p *productService) createProductAttributeInfoEntity(productID int64, attributeName string, attributeValue string) *entity.ProductAttributeInfo {&#10;&#9;return &amp;entity.ProductAttributeInfo{&#10;&#9;&#9;AttributeName:  attributeName,&#10;&#9;&#9;AttributeValue: attributeValue,&#10;&#9;&#9;ProductID:      productID,&#10;&#9;}&#10;}&#10;&#10;func (p *productService) createProductOptionInfoEntity(productID int64, optionName string, optionValue string) *entity.ProductOptionInfo {&#10;&#9;return &amp;entity.ProductOptionInfo{&#10;&#9;&#9;OptionName:  optionName,&#10;&#9;&#9;OptionValue: optionValue,&#10;&#9;&#9;ProductID:   productID,&#10;&#9;}&#10;}&#10;&#10;func (p *productService) createProductAttributeValueEntity(productAttributeID int64, value string) *entity.ProductAttributeValue {&#10;&#9;return &amp;entity.ProductAttributeValue{&#10;&#9;&#9;ProductAttributeID: productAttributeID,&#10;&#9;&#9;Value:              value,&#10;&#9;}&#10;}&#10;&#10;func (p *productService) createProductSKUEntity(productID int64, productName string, data *request.CreateProductSKURequest) *entity.ProductSKU {&#10;&#9;return &amp;entity.ProductSKU{&#10;&#9;&#9;SKU:           data.SKU,&#10;&#9;&#9;SKUSignature:  p.generateSKUSignature(productName, data.SKU),&#10;&#9;&#9;ExtraPrice:    data.ExtraPrice,&#10;&#9;&#9;SaleType:      data.SaleType,&#10;&#9;&#9;SaleValue:     data.SaleValue,&#10;&#9;&#9;SaleStartDate: data.SaleStartDate,&#10;&#9;&#9;SaleEndDate:   data.SaleEndDate,&#10;&#9;&#9;Status:        string(constants.ProductStatusActive),&#10;&#9;&#9;ProductID:     productID,&#10;&#9;}&#10;}&#10;&#10;func (p *productService) createProductInventoryEntity(productSKU *entity.ProductSKU, stock int32) *entity.ProductInventory {&#10;&#9;return &amp;entity.ProductInventory{&#10;&#9;&#9;ProductID:      productSKU.ProductID,&#10;&#9;&#9;ProductSKUID:   productSKU.ID,&#10;&#9;&#9;AvailableStock: stock,&#10;&#9;&#9;ReservedStock:  0,&#10;&#9;&#9;DamagedStock:   0,&#10;&#9;}&#10;}&#10;&#10;func (p *productService) createProductOptionCombinationEntity(productID int64, productOptionID int64, displayOrder int32) *entity.ProductOptionCombination {&#10;&#9;return &amp;entity.ProductOptionCombination{&#10;&#9;&#9;ProductID:       productID,&#10;&#9;&#9;ProductOptionID: productOptionID,&#10;&#9;&#9;DisplayOrder:    displayOrder,&#10;&#9;}&#10;}&#10;&#10;func (p *productService) createProductOptionValueEntity(id int64, value string) *entity.ProductOptionValue {&#10;&#9;return &amp;entity.ProductOptionValue{&#10;&#9;&#9;ProductOptionID: id,&#10;&#9;&#9;Value:           value,&#10;&#9;}&#10;}&#10;&#10;func (p *productService) createProductResponse(product *entity.Product) *response.ProductResponse {&#10;&#9;return &amp;response.ProductResponse{&#10;&#9;&#9;ID:               product.ID,&#10;&#9;&#9;Name:             product.Name,&#10;&#9;&#9;ShortDescription: product.ShortDescription,&#10;&#9;&#9;ImageURL:         product.ImageURL,&#10;&#9;&#9;BasePrice:        product.BasePrice,&#10;&#9;&#9;SalePrice:        product.SalePrice,&#10;&#9;&#9;IsFeatured:       product.IsFeatured,&#10;&#9;&#9;SaleStartDate:    product.SaleStartDate,&#10;&#9;&#9;SaleEndDate:      product.SaleEndDate,&#10;&#9;&#9;Status:           product.Status,&#10;&#9;&#9;BrandID:          product.BrandID,&#10;&#9;&#9;CategoryID:       product.CategoryID,&#10;&#9;&#9;UserID:           product.UserID,&#10;&#9;}&#10;}&#10;&#10;func (p *productService) createProductDetailResponse(product *entity.Product) *response.ProductDetailResponse {&#10;&#9;// 1. Fetch product attributes and options&#10;&#9;productAttributes, err := p.productRepository.FindProductAttributesInfoByProductID(product.ID)&#10;&#9;if err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Error fetching product attributes for product ID&quot;, product.ID, &quot;Error:&quot;, err)&#10;&#9;&#9;return nil&#10;&#9;}&#10;&#9;productOptions, err := p.productRepository.FindProductOptionsInfoByProductID(product.ID)&#10;&#9;if err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Error fetching product options for product ID&quot;, product.ID, &quot;Error:&quot;, err)&#10;&#9;&#9;return nil&#10;&#9;}&#10;&#10;&#9;// 3. Fetch product SKUs&#10;&#9;productSKUWithInventories, err := p.productRepository.FindProductSKUsByProductID(product.ID)&#10;&#9;if productSKUWithInventories == nil {&#10;&#9;&#9;p.logger.Error(&quot;No product SKUs found for product ID&quot;, product.ID)&#10;&#9;&#9;return nil&#10;&#9;}&#10;&#10;&#9;// 2. Create response objects for attributes and options&#10;&#9;var attributeValues []*response.ProductWithAttributeValuesResponse&#10;&#9;var optionValues []*response.ProductWithOptionValuesResponse&#10;&#9;for _, attribute := range *productAttributes {&#10;&#9;&#9;attributeValues = append(attributeValues, p.createProductWithAttributeValuesResponse(&amp;attribute))&#10;&#9;}&#10;&#9;for _, option := range *productOptions {&#10;&#9;&#9;optionValues = append(optionValues, p.createProductWithOptionValuesResponse(&amp;option))&#10;&#9;}&#10;&#10;&#9;var productSKUResponses []*response.ProductSKUDetailResponse&#10;&#9;for _, sku := range *productSKUWithInventories {&#10;&#9;&#9;productSKUResponse := p.createProductSKUWithInventoryResponse(product.BasePrice, &amp;sku)&#10;&#9;&#9;productSKUResponses = append(productSKUResponses, productSKUResponse)&#10;&#9;}&#10;&#10;&#9;return &amp;response.ProductDetailResponse{&#10;&#9;&#9;ID:               product.ID,&#10;&#9;&#9;Name:             product.Name,&#10;&#9;&#9;Description:      product.Description,&#10;&#9;&#9;ShortDescription: product.ShortDescription,&#10;&#9;&#9;ImageURL:         product.ImageURL,&#10;&#9;&#9;Slug:             product.Slug,&#10;&#9;&#9;BasePrice:        product.BasePrice,&#10;&#9;&#9;SalePrice:        product.SalePrice,&#10;&#9;&#9;IsFeatured:       product.IsFeatured,&#10;&#9;&#9;SaleStartDate:    product.SaleStartDate,&#10;&#9;&#9;SaleEndDate:      product.SaleEndDate,&#10;&#9;&#9;Status:           product.Status,&#10;&#9;&#9;BrandID:          product.BrandID,&#10;&#9;&#9;CategoryID:       product.CategoryID,&#10;&#9;&#9;UserID:           product.UserID,&#10;&#9;&#9;Version:          product.Version,&#10;&#9;&#9;AttributeValues:  &amp;attributeValues,&#10;&#9;&#9;ProductSKUs:      &amp;productSKUResponses,&#10;&#9;&#9;OptionValues:     &amp;optionValues,&#10;&#9;}&#10;&#10;}&#10;&#10;func (p *productService) createProductWithAttributeValuesResponse(attribute *entity.ProductAttributeInfo) *response.ProductWithAttributeValuesResponse {&#10;&#9;return &amp;response.ProductWithAttributeValuesResponse{&#10;&#9;&#9;ID:              attribute.ID,&#10;&#9;&#9;AttributeName:   attribute.AttributeName,&#10;&#9;&#9;AttributeValues: attribute.AttributeValue,&#10;&#9;}&#10;}&#10;&#10;func (p *productService) createProductWithOptionValuesResponse(option *entity.ProductOptionInfo) *response.ProductWithOptionValuesResponse {&#10;&#9;return &amp;response.ProductWithOptionValuesResponse{&#10;&#9;&#9;ID:           option.ID,&#10;&#9;&#9;OptionNames:  option.OptionName,&#10;&#9;&#9;OptionValues: option.OptionValue,&#10;&#9;}&#10;}&#10;&#10;func (p *productService) createProductSKUWithInventoryResponse(&#10;&#9;productPrice float64,&#10;&#9;productSKUWithInventory *repository.ProductSKUDetail,&#10;) *response.ProductSKUDetailResponse {&#10;&#9;productSKUPrice := p.calculateProductSKUPrice(productPrice, productSKUWithInventory.ExtraPrice)&#10;&#9;return &amp;response.ProductSKUDetailResponse{&#10;&#9;&#9;ID:            productSKUWithInventory.ID,&#10;&#9;&#9;SKU:           productSKUWithInventory.SKU,&#10;&#9;&#9;SKUSignature:  productSKUWithInventory.SKUSignature,&#10;&#9;&#9;Price:         productSKUPrice,&#10;&#9;&#9;SalePrice:     p.calculateProductSKUSalePrice(productSKUPrice, productSKUWithInventory.SaleType, productSKUWithInventory.SaleValue),&#10;&#9;&#9;SaleStartDate: productSKUWithInventory.SaleStartDate,&#10;&#9;&#9;SaleEndDate:   productSKUWithInventory.SaleEndDate,&#10;&#9;&#9;Stock:         productSKUWithInventory.Stock,&#10;&#9;&#9;Status:        productSKUWithInventory.Status,&#10;&#9;&#9;ProductID:     productSKUWithInventory.ProductID,&#10;&#9;}&#10;}&#10;&#10;func (p *productService) generateSKUSignature(name string, sku string) string {&#10;&#9;skuSignature := strings.ToLower(name + &quot;-&quot; + sku)&#10;&#9;skuSignature = strings.ReplaceAll(sku, &quot; &quot;, &quot;-&quot;)&#10;&#10;&#9;return skuSignature&#10;}&#10;&#10;func (p *productService) calculateProductSKUPrice(productPrice float64, extraPrice float64) float64 {&#10;&#9;if extraPrice &lt; 0 {&#10;&#9;&#9;return productPrice&#10;&#9;}&#10;&#10;&#9;finalPrice := productPrice + productPrice*extraPrice&#10;&#9;return finalPrice&#10;}&#10;&#10;func (p *productService) calculateProductSKUSalePrice(productSKUPrice float64, saleType *string, saleValue *float64) *float64 {&#10;&#9;if saleType == nil || saleValue == nil {&#10;&#9;&#9;return nil&#10;&#9;}&#10;&#10;&#9;if *saleType == constants.SaleTypePercentage {&#10;&#9;&#9;// Calculate sale price as a percentage discount&#10;&#9;&#9;finalPrice := productSKUPrice - (productSKUPrice * *saleValue)&#10;&#9;&#9;return &amp;finalPrice&#10;&#9;} else if *saleType == constants.SaleTypeFixed {&#10;&#9;&#9;finalPrice := productSKUPrice - *saleValue&#10;&#9;&#9;if finalPrice &lt; 0 {&#10;&#9;&#9;&#9;finalPrice = 0&#10;&#9;&#9;}&#10;&#9;&#9;return &amp;finalPrice&#10;&#9;}&#10;&#10;&#9;return nil&#10;}&#10;&#10;// CreateProductWithoutSKU Help to create a product without SKU (for case app only have backend API)&#10;func (p *productService) CreateProductWithoutSKU(data *request.CreateProductWithoutSKURequest) (*response.ProductDetailResponse, error) {&#10;&#9;p.logger.Info(&quot;Creating product without SKU with name: &quot;, data.Name)&#10;&#10;&#9;// Generate all SKU combinations automatically from option values&#10;&#9;productSKUs, err := p.generateAllSKUCombinations(data.Name, data.OptionValues)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;// Create the full CreateProductRequest with generated SKUs&#10;&#9;createProductRequest := &amp;request.CreateProductRequest{&#10;&#9;&#9;Name:              data.Name,&#10;&#9;&#9;Description:       data.Description,&#10;&#9;&#9;ShortDescription:  data.ShortDescription,&#10;&#9;&#9;ImageURL:          data.ImageURL,&#10;&#9;&#9;Slug:              data.Slug,&#10;&#9;&#9;BasePrice:         data.BasePrice,&#10;&#9;&#9;SalePrice:         data.SalePrice,&#10;&#9;&#9;IsFeatured:        data.IsFeatured,&#10;&#9;&#9;SaleStartDate:     data.SaleStartDate,&#10;&#9;&#9;SaleEndDate:       data.SaleEndDate,&#10;&#9;&#9;Status:            string(constants.ProductStatusActive),&#10;&#9;&#9;BrandID:           data.BrandID,&#10;&#9;&#9;CategoryID:        data.CategoryID,&#10;&#9;&#9;UserID:            data.UserID,&#10;&#9;&#9;ProductAttributes: data.ProductAttributes,&#10;&#9;&#9;OptionValues:      data.OptionValues,&#10;&#9;&#9;ProductSKUs:       *productSKUs,&#10;&#9;}&#10;&#10;&#9;// Call the existing CreateProduct function&#10;&#9;return p.CreateProduct(createProductRequest)&#10;}&#10;&#10;// generateAllSKUCombinations generates all possible SKU combinations from option values&#10;func (p *productService) generateAllSKUCombinations(productName string, optionValues map[int64][]string) (*[]request.CreateProductSKURequest, error) {&#10;&#9;// Clean up option values - remove empty options&#10;&#9;cleanedOptions := make(map[int64][]string)&#10;&#9;optionIDs := make([]int64, 0)&#10;&#10;&#9;for optionID, values := range optionValues {&#10;&#9;&#9;if len(values) &gt; 0 {&#10;&#9;&#9;&#9;cleanedOptions[optionID] = values&#10;&#9;&#9;&#9;optionIDs = append(optionIDs, optionID)&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;// If no options, create a single default SKU&#10;&#9;if len(cleanedOptions) == 0 {&#10;&#9;&#9;defaultSKU := []request.CreateProductSKURequest{&#10;&#9;&#9;&#9;{&#10;&#9;&#9;&#9;&#9;SKU:        productName + &quot;_default&quot;,&#10;&#9;&#9;&#9;&#9;ExtraPrice: 0,&#10;&#9;&#9;&#9;&#9;Stock:      100,&#10;&#9;&#9;&#9;},&#10;&#9;&#9;}&#10;&#9;&#9;return &amp;defaultSKU, nil&#10;&#9;}&#10;&#10;&#9;// Generate all combinations using cartesian product&#10;&#9;combinations := p.generateCartesianProduct(cleanedOptions, optionIDs)&#10;&#10;&#9;// Create SKU requests from combinations&#10;&#9;var productSKUs []request.CreateProductSKURequest&#10;&#9;for _, combination := range combinations {&#10;&#9;&#9;sku := p.buildSKUFromCombination(productName, combination, optionIDs)&#10;&#9;&#9;price := constants.DefaultPrice&#10;&#9;&#9;stock := constants.DefaultStock&#10;&#10;&#9;&#9;productSKUs = append(productSKUs, request.CreateProductSKURequest{&#10;&#9;&#9;&#9;SKU:        sku,&#10;&#9;&#9;&#9;ExtraPrice: price,&#10;&#9;&#9;&#9;Stock:      int32(stock),&#10;&#9;&#9;})&#10;&#9;}&#10;&#10;&#9;return &amp;productSKUs, nil&#10;}&#10;&#10;// generateCartesianProduct generates all possible combinations of option values&#10;func (p *productService) generateCartesianProduct(optionValues map[int64][]string, optionIDs []int64) []map[int64]string {&#10;&#9;if len(optionIDs) == 0 {&#10;&#9;&#9;return []map[int64]string{}&#10;&#9;}&#10;&#10;&#9;// Start with the first option&#10;&#9;var result []map[int64]string&#10;&#9;firstOptionID := optionIDs[0]&#10;&#9;firstValues := optionValues[firstOptionID]&#10;&#10;&#9;for _, value := range firstValues {&#10;&#9;&#9;combination := make(map[int64]string)&#10;&#9;&#9;combination[firstOptionID] = value&#10;&#9;&#9;result = append(result, combination)&#10;&#9;}&#10;&#10;&#9;// Add remaining options one by one&#10;&#9;for i := 1; i &lt; len(optionIDs); i++ {&#10;&#9;&#9;optionID := optionIDs[i]&#10;&#9;&#9;values := optionValues[optionID]&#10;&#10;&#9;&#9;var newResult []map[int64]string&#10;&#9;&#9;for _, existingCombination := range result {&#10;&#9;&#9;&#9;for _, value := range values {&#10;&#9;&#9;&#9;&#9;newCombination := make(map[int64]string)&#10;&#9;&#9;&#9;&#9;// Copy existing combination&#10;&#9;&#9;&#9;&#9;for k, v := range existingCombination {&#10;&#9;&#9;&#9;&#9;&#9;newCombination[k] = v&#10;&#9;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;&#9;// Add new option value&#10;&#9;&#9;&#9;&#9;newCombination[optionID] = value&#10;&#9;&#9;&#9;&#9;newResult = append(newResult, newCombination)&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#9;&#9;result = newResult&#10;&#9;}&#10;&#10;&#9;return result&#10;}&#10;&#10;// buildSKUFromCombination builds SKU string from option combination&#10;func (p *productService) buildSKUFromCombination(productName string, combination map[int64]string, optionIDs []int64) string {&#10;&#9;skuParts := []string{productName}&#10;&#10;&#9;// Add option values in consistent order&#10;&#9;for _, optionID := range optionIDs {&#10;&#9;&#9;if value, exists := combination[optionID]; exists {&#10;&#9;&#9;&#9;// Clean up value for SKU (remove spaces, special chars)&#10;&#9;&#9;&#9;cleanValue := strings.ReplaceAll(value, &quot; &quot;, &quot;&quot;)&#10;&#9;&#9;&#9;skuParts = append(skuParts, cleanValue)&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;return strings.Join(skuParts, &quot;_&quot;)&#10;}&#10;" />
              <option name="updatedContent" value="package service&#10;&#10;import (&#10;&#9;&quot;github.com/hthinh24/go-store/internal/pkg/logger&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/services/product&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/services/product/internal/constants&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/services/product/internal/dto/repository&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/services/product/internal/dto/request&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/services/product/internal/dto/response&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/services/product/internal/entity&quot;&#10;&#9;&quot;strings&quot;&#10;)&#10;&#10;type productService struct {&#10;&#9;logger            logger.Logger&#10;&#9;productRepository product.ProductRepository&#10;}&#10;&#10;// NewProductService creates a new instance of ProductService&#10;func NewProductService(logger logger.Logger, productRepository product.ProductRepository) product.ProductService {&#10;&#9;return &amp;productService{&#10;&#9;&#9;logger:            logger,&#10;&#9;&#9;productRepository: productRepository,&#10;&#9;}&#10;}&#10;&#10;func (p *productService) GetProductByID(id int64) (*response.ProductResponse, error) {&#10;&#9;p.logger.Info(&quot;Get product with ID: &quot;, id)&#10;&#10;&#9;productEntity, err := p.productRepository.FindProductByID(id)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;p.logger.Info(&quot;Product retrieved successfully, ID: &quot;, productEntity.ID)&#10;&#9;return p.createProductResponse(productEntity), nil&#10;}&#10;&#10;func (p *productService) GetProductDetailByID(id int64) (*response.ProductDetailResponse, error) {&#10;&#9;p.logger.Info(&quot;Get product with ID: &quot;, id)&#10;&#10;&#9;productEntity, err := p.productRepository.FindProductByID(id)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;p.logger.Info(&quot;Product retrieved successfully, ID: &quot;, productEntity.ID)&#10;&#9;return p.createProductDetailResponse(productEntity), nil&#10;}&#10;&#10;func (p *productService) CreateProduct(data *request.CreateProductRequest) (*response.ProductDetailResponse, error) {&#10;&#9;p.logger.Info(&quot;Creating product with name&quot;, data.Name)&#10;&#10;&#9;// Create Product Entity from request data&#10;&#9;productEntity := p.createProductEntity(data)&#10;&#10;&#9;// Create transactional repository&#10;&#9;txRepo, err := p.productRepository.WithTransaction()&#10;&#9;if err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Failed to create transaction:&quot;, err)&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;// Ensure rollback on error or panic&#10;&#9;defer func() {&#10;&#9;&#9;if r := recover(); r != nil {&#10;&#9;&#9;&#9;txRepo.Rollback()&#10;&#9;&#9;&#9;panic(r)&#10;&#9;&#9;}&#10;&#9;}()&#10;&#10;&#9;// 1. Create &amp; Insert the base product entity&#10;&#9;if err := txRepo.CreateProduct(productEntity); err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Error creating product:&quot;, err)&#10;&#9;&#9;txRepo.Rollback()&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;// 2. Create &amp; Insert product attribute info&#10;&#9;if err := p.processCreateProductAttributeInfoWithTx(txRepo, productEntity.ID, data.ProductAttributes); err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Error creating product attribute info:&quot;, err)&#10;&#9;&#9;txRepo.Rollback()&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;// 3. Create &amp; Insert product option info&#10;&#9;if err := p.processCreateProductOptionInfoWithTx(txRepo, productEntity.ID, data.OptionValues); err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Error creating product option info:&quot;, err)&#10;&#9;&#9;txRepo.Rollback()&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;// 4. Create &amp; Insert product attribute values&#10;&#9;if err := p.processCreateProductAttributesWithTx(txRepo, data.ProductAttributes); err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Error creating product attributes:&quot;, err)&#10;&#9;&#9;txRepo.Rollback()&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;// 5. Create &amp; Insert product SKUs&#10;&#9;if err := p.processCreateProductSKUsWithTx(txRepo, productEntity.ID, productEntity.Name, &amp;data.ProductSKUs); err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Error creating product SKUs:&quot;, err)&#10;&#9;&#9;txRepo.Rollback()&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;// 6. Create &amp; Insert product option combinations&#10;&#9;if err := p.processCreateProductOptionCombinationsWithTx(txRepo, productEntity.ID, data.OptionValues); err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Error creating product option combinations:&quot;, err)&#10;&#9;&#9;txRepo.Rollback()&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;// Commit the transaction&#10;&#9;if err := txRepo.Commit(); err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Failed to commit transaction:&quot;, err)&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;p.logger.Info(&quot;Product created successfully, ID: &quot;, productEntity.ID)&#10;&#9;return p.createProductDetailResponse(productEntity), nil&#10;}&#10;&#10;// Transaction-aware helper methods&#10;func (p *productService) processCreateProductAttributeInfoWithTx(txRepo product.ProductRepository, productID int64, attributeMap map[int64][]string) error {&#10;&#9;var attributeIDs []int64&#10;&#9;var productAttributeInfoEntities []entity.ProductAttributeInfo&#10;&#9;&#10;&#9;for attributeID, _ := range attributeMap {&#10;&#9;&#9;attributeIDs = append(attributeIDs, attributeID)&#10;&#9;}&#10;&#10;&#9;// 1. Find product attributes by IDs&#10;&#9;productAttributes, err := txRepo.FindProductAttributesByIDs(attributeIDs)&#10;&#9;if err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Error finding product attributes by IDs, error: &quot;, err)&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;// 2. Create product attribute info entities from the attribute map&#10;&#9;for _, attribute := range *productAttributes {&#10;&#9;&#9;if values, ok := attributeMap[attribute.ID]; ok {&#10;&#9;&#9;&#9;for _, value := range values {&#10;&#9;&#9;&#9;&#9;productAttributeInfoEntity := p.createProductAttributeInfoEntity(productID, attribute.Name, value)&#10;&#9;&#9;&#9;&#9;productAttributeInfoEntities = append(productAttributeInfoEntities, *productAttributeInfoEntity)&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;// 3. Save product attribute info entities to the repository&#10;&#9;if err := txRepo.CreateProductAttributeInfo(&amp;productAttributeInfoEntities); err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Error saving product attribute info to repository, error: &quot;, err)&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;return nil&#10;}&#10;&#10;func (p *productService) processCreateProductOptionInfoWithTx(txRepo product.ProductRepository, productID int64, optionMap map[int64][]string) error {&#10;&#9;var productOptionIDs []int64&#10;&#9;var productOptionInfoEntities []entity.ProductOptionInfo&#10;&#10;&#9;for productOptionID, _ := range optionMap {&#10;&#9;&#9;productOptionIDs = append(productOptionIDs, productOptionID)&#10;&#9;}&#10;&#10;&#9;// 1. Find product options by IDs&#10;&#9;productOptions, err := txRepo.FindProductOptionsByIDs(productOptionIDs)&#10;&#9;if err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Error finding product options by IDs, error: &quot;, err)&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;// 2. Create product option info entities from the option map&#10;&#9;for _, option := range *productOptions {&#10;&#9;&#9;if values, ok := optionMap[option.ID]; ok {&#10;&#9;&#9;&#9;for _, value := range values {&#10;&#9;&#9;&#9;&#9;productOptionInfoEntity := p.createProductOptionInfoEntity(productID, option.Name, value)&#10;&#9;&#9;&#9;&#9;productOptionInfoEntities = append(productOptionInfoEntities, *productOptionInfoEntity)&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;// 3. Save product option info entities to the repository&#10;&#9;if err := txRepo.CreateProductOptionInfo(&amp;productOptionInfoEntities); err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Error saving product option info to repository, error: &quot;, err)&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;return nil&#10;}&#10;&#10;func (p *productService) processCreateProductAttributesWithTx(txRepo product.ProductRepository, attributeValues map[int64][]string) error {&#10;&#9;// 1. Create product attribute values entities from the attribute values map&#10;&#9;var productAttributeValueEntities []entity.ProductAttributeValue&#10;&#9;for attributeID, values := range attributeValues {&#10;&#9;&#9;for _, value := range values {&#10;&#9;&#9;&#9;productAttributeValueEntity := p.createProductAttributeValueEntity(attributeID, value)&#10;&#9;&#9;&#9;productAttributeValueEntities = append(productAttributeValueEntities, *productAttributeValueEntity)&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;// 2. Save product attribute values to the repository&#10;&#9;err := txRepo.CreateProductAttributeValuesIfNotExist(&amp;productAttributeValueEntities)&#10;&#9;if err != nil {&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;return nil&#10;}&#10;&#10;func (p *productService) processCreateProductSKUsWithTx(txRepo product.ProductRepository, productID int64, productName string, productSKUData *[]request.CreateProductSKURequest) error {&#10;&#9;// 1. Create product SKU entities from the product SKU data&#10;&#9;var productSKUEntities []entity.ProductSKU&#10;&#9;for _, sku := range *productSKUData {&#10;&#9;&#9;productSKUEntity := p.createProductSKUEntity(productID, productName, &amp;sku)&#10;&#9;&#9;productSKUEntities = append(productSKUEntities, *productSKUEntity)&#10;&#9;}&#10;&#10;&#9;// 2. Save product SKUs to the repository&#10;&#9;if err := txRepo.CreateProductSKUs(&amp;productSKUEntities); err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Error saving product SKUs to repository, error: &quot;, err)&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;// 3. Create product inventory entities based on product SKUs and stock data&#10;&#9;var productInventoryEntities []entity.ProductInventory&#10;&#9;for i, productSKUEntity := range productSKUEntities {&#10;&#9;&#9;productInventory := p.createProductInventoryEntity(&amp;productSKUEntity, (*productSKUData)[i].Stock)&#10;&#9;&#9;productInventoryEntities = append(productInventoryEntities, *productInventory)&#10;&#9;}&#10;&#10;&#9;// 4. Save product inventory entities to repository&#10;&#9;if err := txRepo.CreateProductInventories(&amp;productInventoryEntities); err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Error saving product inventory to repository, error: &quot;, err)&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;return nil&#10;}&#10;&#10;func (p *productService) processCreateProductOptionCombinationsWithTx(txRepo product.ProductRepository, id int64, optionValues map[int64][]string) error {&#10;&#9;var productOptionCombinationEntities []entity.ProductOptionCombination&#10;&#10;&#9;// 1. Create product option combination entities from the option values map&#10;&#9;displayOrder := int32(1)&#10;&#9;for option, _ := range optionValues {&#10;&#9;&#9;productOptionCombinationEntity := p.createProductOptionCombinationEntity(id, option, int32(displayOrder))&#10;&#9;&#9;productOptionCombinationEntities = append(productOptionCombinationEntities, *productOptionCombinationEntity)&#10;&#9;&#9;displayOrder++&#10;&#9;}&#10;&#9;&#10;&#9;// 2. Save product option combinations to the repository&#10;&#9;if err := txRepo.CreateProductOptionCombinations(&amp;productOptionCombinationEntities); err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Error saving product option combinations to repository, error: &quot;, err)&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;// 3. Create product option value entities from the option values map&#10;&#9;var productOptionValueEntities []entity.ProductOptionValue&#10;&#9;for optionID, values := range optionValues {&#10;&#9;&#9;for _, value := range values {&#10;&#9;&#9;&#9;productOptionValueEntity := p.createProductOptionValueEntity(optionID, value)&#10;&#9;&#9;&#9;productOptionValueEntities = append(productOptionValueEntities, *productOptionValueEntity)&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;// 4. Create product option values in the repository if they do not already exist&#10;&#9;if err := txRepo.CreateProductOptionValuesIfNotExist(&amp;productOptionValueEntities); err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Error saving product option values to repository, error: &quot;, err)&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;return nil&#10;}&#10;&#10;func (p *productService) createProductEntity(data *request.CreateProductRequest) *entity.Product {&#10;&#9;return &amp;entity.Product{&#10;&#9;&#9;Name:             data.Name,&#10;&#9;&#9;Description:      data.Description,&#10;&#9;&#9;ShortDescription: data.ShortDescription,&#10;&#9;&#9;ImageURL:         data.ImageURL,&#10;&#9;&#9;Slug:             data.Slug,&#10;&#9;&#9;BasePrice:        data.BasePrice,&#10;&#9;&#9;SalePrice:        data.SalePrice,&#10;&#9;&#9;IsFeatured:       data.IsFeatured,&#10;&#9;&#9;SaleStartDate:    data.SaleStartDate,&#10;&#9;&#9;SaleEndDate:      data.SaleEndDate,&#10;&#9;&#9;Status:           data.Status,&#10;&#9;&#9;BrandID:          data.BrandID,&#10;&#9;&#9;CategoryID:       data.CategoryID,&#10;&#9;&#9;UserID:           data.UserID,&#10;&#9;}&#10;}&#10;&#10;func (p *productService) createProductAttributeInfoEntity(productID int64, attributeName string, attributeValue string) *entity.ProductAttributeInfo {&#10;&#9;return &amp;entity.ProductAttributeInfo{&#10;&#9;&#9;AttributeName:  attributeName,&#10;&#9;&#9;AttributeValue: attributeValue,&#10;&#9;&#9;ProductID:      productID,&#10;&#9;}&#10;}&#10;&#10;func (p *productService) createProductOptionInfoEntity(productID int64, optionName string, optionValue string) *entity.ProductOptionInfo {&#10;&#9;return &amp;entity.ProductOptionInfo{&#10;&#9;&#9;OptionName:  optionName,&#10;&#9;&#9;OptionValue: optionValue,&#10;&#9;&#9;ProductID:   productID,&#10;&#9;}&#10;}&#10;&#10;func (p *productService) createProductAttributeValueEntity(productAttributeID int64, value string) *entity.ProductAttributeValue {&#10;&#9;return &amp;entity.ProductAttributeValue{&#10;&#9;&#9;ProductAttributeID: productAttributeID,&#10;&#9;&#9;Value:              value,&#10;&#9;}&#10;}&#10;&#10;func (p *productService) createProductSKUEntity(productID int64, productName string, data *request.CreateProductSKURequest) *entity.ProductSKU {&#10;&#9;return &amp;entity.ProductSKU{&#10;&#9;&#9;SKU:           data.SKU,&#10;&#9;&#9;SKUSignature:  p.generateSKUSignature(productName, data.SKU),&#10;&#9;&#9;ExtraPrice:    data.ExtraPrice,&#10;&#9;&#9;SaleType:      data.SaleType,&#10;&#9;&#9;SaleValue:     data.SaleValue,&#10;&#9;&#9;SaleStartDate: data.SaleStartDate,&#10;&#9;&#9;SaleEndDate:   data.SaleEndDate,&#10;&#9;&#9;Status:        string(constants.ProductStatusActive),&#10;&#9;&#9;ProductID:     productID,&#10;&#9;}&#10;}&#10;&#10;func (p *productService) createProductInventoryEntity(productSKU *entity.ProductSKU, stock int32) *entity.ProductInventory {&#10;&#9;return &amp;entity.ProductInventory{&#10;&#9;&#9;ProductID:      productSKU.ProductID,&#10;&#9;&#9;ProductSKUID:   productSKU.ID,&#10;&#9;&#9;AvailableStock: stock,&#10;&#9;&#9;ReservedStock:  0,&#10;&#9;&#9;DamagedStock:   0,&#10;&#9;}&#10;}&#10;&#10;func (p *productService) createProductOptionCombinationEntity(productID int64, productOptionID int64, displayOrder int32) *entity.ProductOptionCombination {&#10;&#9;return &amp;entity.ProductOptionCombination{&#10;&#9;&#9;ProductID:       productID,&#10;&#9;&#9;ProductOptionID: productOptionID,&#10;&#9;&#9;DisplayOrder:    displayOrder,&#10;&#9;}&#10;}&#10;&#10;func (p *productService) createProductOptionValueEntity(id int64, value string) *entity.ProductOptionValue {&#10;&#9;return &amp;entity.ProductOptionValue{&#10;&#9;&#9;ProductOptionID: id,&#10;&#9;&#9;Value:           value,&#10;&#9;}&#10;}&#10;&#10;func (p *productService) createProductResponse(product *entity.Product) *response.ProductResponse {&#10;&#9;return &amp;response.ProductResponse{&#10;&#9;&#9;ID:               product.ID,&#10;&#9;&#9;Name:             product.Name,&#10;&#9;&#9;ShortDescription: product.ShortDescription,&#10;&#9;&#9;ImageURL:         product.ImageURL,&#10;&#9;&#9;BasePrice:        product.BasePrice,&#10;&#9;&#9;SalePrice:        product.SalePrice,&#10;&#9;&#9;IsFeatured:       product.IsFeatured,&#10;&#9;&#9;SaleStartDate:    product.SaleStartDate,&#10;&#9;&#9;SaleEndDate:      product.SaleEndDate,&#10;&#9;&#9;Status:           product.Status,&#10;&#9;&#9;BrandID:          product.BrandID,&#10;&#9;&#9;CategoryID:       product.CategoryID,&#10;&#9;&#9;UserID:           product.UserID,&#10;&#9;}&#10;}&#10;&#10;func (p *productService) createProductDetailResponse(product *entity.Product) *response.ProductDetailResponse {&#10;&#9;// 1. Fetch product attributes and options&#10;&#9;productAttributes, err := p.productRepository.FindProductAttributesInfoByProductID(product.ID)&#10;&#9;if err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Error fetching product attributes for product ID&quot;, product.ID, &quot;Error:&quot;, err)&#10;&#9;&#9;return nil&#10;&#9;}&#10;&#9;productOptions, err := p.productRepository.FindProductOptionsInfoByProductID(product.ID)&#10;&#9;if err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Error fetching product options for product ID&quot;, product.ID, &quot;Error:&quot;, err)&#10;&#9;&#9;return nil&#10;&#9;}&#10;&#10;&#9;// 3. Fetch product SKUs&#10;&#9;productSKUWithInventories, err := p.productRepository.FindProductSKUsByProductID(product.ID)&#10;&#9;if productSKUWithInventories == nil {&#10;&#9;&#9;p.logger.Error(&quot;No product SKUs found for product ID&quot;, product.ID)&#10;&#9;&#9;return nil&#10;&#9;}&#10;&#10;&#9;// 2. Create response objects for attributes and options&#10;&#9;var attributeValues []*response.ProductWithAttributeValuesResponse&#10;&#9;var optionValues []*response.ProductWithOptionValuesResponse&#10;&#9;for _, attribute := range *productAttributes {&#10;&#9;&#9;attributeValues = append(attributeValues, p.createProductWithAttributeValuesResponse(&amp;attribute))&#10;&#9;}&#10;&#9;for _, option := range *productOptions {&#10;&#9;&#9;optionValues = append(optionValues, p.createProductWithOptionValuesResponse(&amp;option))&#10;&#9;}&#10;&#10;&#9;var productSKUResponses []*response.ProductSKUDetailResponse&#10;&#9;for _, sku := range *productSKUWithInventories {&#10;&#9;&#9;productSKUResponse := p.createProductSKUWithInventoryResponse(product.BasePrice, &amp;sku)&#10;&#9;&#9;productSKUResponses = append(productSKUResponses, productSKUResponse)&#10;&#9;}&#10;&#10;&#9;return &amp;response.ProductDetailResponse{&#10;&#9;&#9;ID:               product.ID,&#10;&#9;&#9;Name:             product.Name,&#10;&#9;&#9;Description:      product.Description,&#10;&#9;&#9;ShortDescription: product.ShortDescription,&#10;&#9;&#9;ImageURL:         product.ImageURL,&#10;&#9;&#9;Slug:             product.Slug,&#10;&#9;&#9;BasePrice:        product.BasePrice,&#10;&#9;&#9;SalePrice:        product.SalePrice,&#10;&#9;&#9;IsFeatured:       product.IsFeatured,&#10;&#9;&#9;SaleStartDate:    product.SaleStartDate,&#10;&#9;&#9;SaleEndDate:      product.SaleEndDate,&#10;&#9;&#9;Status:           product.Status,&#10;&#9;&#9;BrandID:          product.BrandID,&#10;&#9;&#9;CategoryID:       product.CategoryID,&#10;&#9;&#9;UserID:           product.UserID,&#10;&#9;&#9;Version:          product.Version,&#10;&#9;&#9;AttributeValues:  &amp;attributeValues,&#10;&#9;&#9;ProductSKUs:      &amp;productSKUResponses,&#10;&#9;&#9;OptionValues:     &amp;optionValues,&#10;&#9;}&#10;&#10;}&#10;&#10;func (p *productService) createProductWithAttributeValuesResponse(attribute *entity.ProductAttributeInfo) *response.ProductWithAttributeValuesResponse {&#10;&#9;return &amp;response.ProductWithAttributeValuesResponse{&#10;&#9;&#9;ID:              attribute.ID,&#10;&#9;&#9;AttributeName:   attribute.AttributeName,&#10;&#9;&#9;AttributeValues: attribute.AttributeValue,&#10;&#9;}&#10;}&#10;&#10;func (p *productService) createProductWithOptionValuesResponse(option *entity.ProductOptionInfo) *response.ProductWithOptionValuesResponse {&#10;&#9;return &amp;response.ProductWithOptionValuesResponse{&#10;&#9;&#9;ID:           option.ID,&#10;&#9;&#9;OptionNames:  option.OptionName,&#10;&#9;&#9;OptionValues: option.OptionValue,&#10;&#9;}&#10;}&#10;&#10;func (p *productService) createProductSKUWithInventoryResponse(&#10;&#9;productPrice float64,&#10;&#9;productSKUWithInventory *repository.ProductSKUDetail,&#10;) *response.ProductSKUDetailResponse {&#10;&#9;productSKUPrice := p.calculateProductSKUPrice(productPrice, productSKUWithInventory.ExtraPrice)&#10;&#9;return &amp;response.ProductSKUDetailResponse{&#10;&#9;&#9;ID:            productSKUWithInventory.ID,&#10;&#9;&#9;SKU:           productSKUWithInventory.SKU,&#10;&#9;&#9;SKUSignature:  productSKUWithInventory.SKUSignature,&#10;&#9;&#9;Price:         productSKUPrice,&#10;&#9;&#9;SalePrice:     p.calculateProductSKUSalePrice(productSKUPrice, productSKUWithInventory.SaleType, productSKUWithInventory.SaleValue),&#10;&#9;&#9;SaleStartDate: productSKUWithInventory.SaleStartDate,&#10;&#9;&#9;SaleEndDate:   productSKUWithInventory.SaleEndDate,&#10;&#9;&#9;Stock:         productSKUWithInventory.Stock,&#10;&#9;&#9;Status:        productSKUWithInventory.Status,&#10;&#9;&#9;ProductID:     productSKUWithInventory.ProductID,&#10;&#9;}&#10;}&#10;&#10;func (p *productService) generateSKUSignature(name string, sku string) string {&#10;&#9;skuSignature := strings.ToLower(name + &quot;-&quot; + sku)&#10;&#9;skuSignature = strings.ReplaceAll(sku, &quot; &quot;, &quot;-&quot;)&#10;&#10;&#9;return skuSignature&#10;}&#10;&#10;func (p *productService) calculateProductSKUPrice(productPrice float64, extraPrice float64) float64 {&#10;&#9;if extraPrice &lt; 0 {&#10;&#9;&#9;return productPrice&#10;&#9;}&#10;&#10;&#9;finalPrice := productPrice + productPrice*extraPrice&#10;&#9;return finalPrice&#10;}&#10;&#10;func (p *productService) calculateProductSKUSalePrice(productSKUPrice float64, saleType *string, saleValue *float64) *float64 {&#10;&#9;if saleType == nil || saleValue == nil {&#10;&#9;&#9;return nil&#10;&#9;}&#10;&#10;&#9;if *saleType == constants.SaleTypePercentage {&#10;&#9;&#9;// Calculate sale price as a percentage discount&#10;&#9;&#9;finalPrice := productSKUPrice - (productSKUPrice * *saleValue)&#10;&#9;&#9;return &amp;finalPrice&#10;&#9;} else if *saleType == constants.SaleTypeFixed {&#10;&#9;&#9;finalPrice := productSKUPrice - *saleValue&#10;&#9;&#9;if finalPrice &lt; 0 {&#10;&#9;&#9;&#9;finalPrice = 0&#10;&#9;&#9;}&#10;&#9;&#9;return &amp;finalPrice&#10;&#9;}&#10;&#10;&#9;return nil&#10;}&#10;&#10;// CreateProductWithoutSKU Help to create a product without SKU (for case app only have backend API)&#10;func (p *productService) CreateProductWithoutSKU(data *request.CreateProductWithoutSKURequest) (*response.ProductDetailResponse, error) {&#10;&#9;p.logger.Info(&quot;Creating product without SKU with name: &quot;, data.Name)&#10;&#10;&#9;// Generate all SKU combinations automatically from option values&#10;&#9;productSKUs, err := p.generateAllSKUCombinations(data.Name, data.OptionValues)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;// Create the full CreateProductRequest with generated SKUs&#10;&#9;createProductRequest := &amp;request.CreateProductRequest{&#10;&#9;&#9;Name:              data.Name,&#10;&#9;&#9;Description:       data.Description,&#10;&#9;&#9;ShortDescription:  data.ShortDescription,&#10;&#9;&#9;ImageURL:          data.ImageURL,&#10;&#9;&#9;Slug:              data.Slug,&#10;&#9;&#9;BasePrice:         data.BasePrice,&#10;&#9;&#9;SalePrice:         data.SalePrice,&#10;&#9;&#9;IsFeatured:        data.IsFeatured,&#10;&#9;&#9;SaleStartDate:     data.SaleStartDate,&#10;&#9;&#9;SaleEndDate:       data.SaleEndDate,&#10;&#9;&#9;Status:            string(constants.ProductStatusActive),&#10;&#9;&#9;BrandID:           data.BrandID,&#10;&#9;&#9;CategoryID:        data.CategoryID,&#10;&#9;&#9;UserID:            data.UserID,&#10;&#9;&#9;ProductAttributes: data.ProductAttributes,&#10;&#9;&#9;OptionValues:      data.OptionValues,&#10;&#9;&#9;ProductSKUs:       *productSKUs,&#10;&#9;}&#10;&#10;&#9;// Call the existing CreateProduct function&#10;&#9;return p.CreateProduct(createProductRequest)&#10;}&#10;&#10;// generateAllSKUCombinations generates all possible SKU combinations from option values&#10;func (p *productService) generateAllSKUCombinations(productName string, optionValues map[int64][]string) (*[]request.CreateProductSKURequest, error) {&#10;&#9;// Clean up option values - remove empty options&#10;&#9;cleanedOptions := make(map[int64][]string)&#10;&#9;optionIDs := make([]int64, 0)&#10;&#10;&#9;for optionID, values := range optionValues {&#10;&#9;&#9;if len(values) &gt; 0 {&#10;&#9;&#9;&#9;cleanedOptions[optionID] = values&#10;&#9;&#9;&#9;optionIDs = append(optionIDs, optionID)&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;// If no options, create a single default SKU&#10;&#9;if len(cleanedOptions) == 0 {&#10;&#9;&#9;defaultSKU := []request.CreateProductSKURequest{&#10;&#9;&#9;&#9;{&#10;&#9;&#9;&#9;&#9;SKU:        productName + &quot;_default&quot;,&#10;&#9;&#9;&#9;&#9;ExtraPrice: 0,&#10;&#9;&#9;&#9;&#9;Stock:      100,&#10;&#9;&#9;&#9;},&#10;&#9;&#9;}&#10;&#9;&#9;return &amp;defaultSKU, nil&#10;&#9;}&#10;&#10;&#9;// Generate all combinations using cartesian product&#10;&#9;combinations := p.generateCartesianProduct(cleanedOptions, optionIDs)&#10;&#10;&#9;// Create SKU requests from combinations&#10;&#9;var productSKUs []request.CreateProductSKURequest&#10;&#9;for _, combination := range combinations {&#10;&#9;&#9;sku := p.buildSKUFromCombination(productName, combination, optionIDs)&#10;&#9;&#9;price := constants.DefaultPrice&#10;&#9;&#9;stock := constants.DefaultStock&#10;&#10;&#9;&#9;productSKUs = append(productSKUs, request.CreateProductSKURequest{&#10;&#9;&#9;&#9;SKU:        sku,&#10;&#9;&#9;&#9;ExtraPrice: price,&#10;&#9;&#9;&#9;Stock:      int32(stock),&#10;&#9;&#9;})&#10;&#9;}&#10;&#10;&#9;return &amp;productSKUs, nil&#10;}&#10;&#10;// generateCartesianProduct generates all possible combinations of option values&#10;func (p *productService) generateCartesianProduct(optionValues map[int64][]string, optionIDs []int64) []map[int64]string {&#10;&#9;if len(optionIDs) == 0 {&#10;&#9;&#9;return []map[int64]string{}&#10;&#9;}&#10;&#10;&#9;// Start with the first option&#10;&#9;var result []map[int64]string&#10;&#9;firstOptionID := optionIDs[0]&#10;&#9;firstValues := optionValues[firstOptionID]&#10;&#10;&#9;for _, value := range firstValues {&#10;&#9;&#9;combination := make(map[int64]string)&#10;&#9;&#9;combination[firstOptionID] = value&#10;&#9;&#9;result = append(result, combination)&#10;&#9;}&#10;&#10;&#9;// Add remaining options one by one&#10;&#9;for i := 1; i &lt; len(optionIDs); i++ {&#10;&#9;&#9;optionID := optionIDs[i]&#10;&#9;&#9;values := optionValues[optionID]&#10;&#10;&#9;&#9;var newResult []map[int64]string&#10;&#9;&#9;for _, existingCombination := range result {&#10;&#9;&#9;&#9;for _, value := range values {&#10;&#9;&#9;&#9;&#9;newCombination := make(map[int64]string)&#10;&#9;&#9;&#9;&#9;// Copy existing combination&#10;&#9;&#9;&#9;&#9;for k, v := range existingCombination {&#10;&#9;&#9;&#9;&#9;&#9;newCombination[k] = v&#10;&#9;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;&#9;// Add new option value&#10;&#9;&#9;&#9;&#9;newCombination[optionID] = value&#10;&#9;&#9;&#9;&#9;newResult = append(newResult, newCombination)&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#9;&#9;result = newResult&#10;&#9;}&#10;&#10;&#9;return result&#10;}&#10;&#10;// buildSKUFromCombination builds SKU string from option combination&#10;func (p *productService) buildSKUFromCombination(productName string, combination map[int64]string, optionIDs []int64) string {&#10;&#9;skuParts := []string{productName}&#10;&#10;&#9;// Add option values in consistent order&#10;&#9;for _, optionID := range optionIDs {&#10;&#9;&#9;if value, exists := combination[optionID]; exists {&#10;&#9;&#9;&#9;// Clean up value for SKU (remove spaces, special chars)&#10;&#9;&#9;&#9;cleanValue := strings.ReplaceAll(value, &quot; &quot;, &quot;&quot;)&#10;&#9;&#9;&#9;skuParts = append(skuParts, cleanValue)&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;return strings.Join(skuParts, &quot;_&quot;)&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/internal/services/product/product_repository.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/internal/services/product/product_repository.go" />
              <option name="originalContent" value="package product&#10;&#10;import (&#10;&#9;&quot;github.com/hthinh24/go-store/services/product/internal/dto/repository&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/services/product/internal/entity&quot;&#10;)&#10;&#10;type ProductRepository interface {&#10;&#9;BeginTx() error&#10;&#9;CommitTx() error&#10;&#10;&#9;FindProductByID(id int64) (*entity.Product, error)&#10;&#9;FindProductAttributesInfoByProductID(productID int64) (*[]entity.ProductAttributeInfo, error)&#10;&#9;FindProductOptionsInfoByProductID(productID int64) (*[]entity.ProductOptionInfo, error)&#10;&#9;FindProductSKUsByProductID(id int64) (*[]repository.ProductSKUDetail, error)&#10;&#10;&#9;FindProductAttributesByIDs(productAttributeIDs []int64) (*[]entity.ProductAttribute, error)&#10;&#9;FindProductOptionsByIDs(productOptionIDs []int64) (*[]entity.ProductOption, error)&#10;&#10;&#9;CreateProduct(product *entity.Product) error&#10;&#9;CreateProductAttributeInfo(productAttributeInfos *[]entity.ProductAttributeInfo) error&#10;&#9;CreateProductOptionInfo(productOptionInfos *[]entity.ProductOptionInfo) error&#10;&#9;CreateProductAttributeValuesIfNotExist(*[]entity.ProductAttributeValue) error&#10;&#9;CreateProductProductAttributeValues(*[]entity.ProductProductAttributeValue) error&#10;&#9;CreateProductSKUs(productSKUs *[]entity.ProductSKU) error&#10;&#9;CreateProductInventories(inventories *[]entity.ProductInventory) error&#10;&#9;CreateProductOptionCombinations(productOptionCombinations *[]entity.ProductOptionCombination) error&#10;&#9;CreateProductOptionValuesIfNotExist(productOptionValues *[]entity.ProductOptionValue) error&#10;&#10;&#9;DeleteProduct(id int64) error&#10;}&#10;" />
              <option name="updatedContent" value="package product&#10;&#10;import (&#10;&#9;&quot;github.com/hthinh24/go-store/services/product/internal/dto/repository&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/services/product/internal/entity&quot;&#10;)&#10;&#10;type ProductRepository interface {&#10;&#9;// Transaction methods&#10;&#9;WithTransaction() (ProductRepository, error)&#10;&#9;Commit() error&#10;&#9;Rollback() error&#10;&#9;IsInTransaction() bool&#10;&#10;&#9;FindProductByID(id int64) (*entity.Product, error)&#10;&#9;FindProductAttributesInfoByProductID(productID int64) (*[]entity.ProductAttributeInfo, error)&#10;&#9;FindProductOptionsInfoByProductID(productID int64) (*[]entity.ProductOptionInfo, error)&#10;&#9;FindProductSKUsByProductID(id int64) (*[]repository.ProductSKUDetail, error)&#10;&#10;&#9;FindProductAttributesByIDs(productAttributeIDs []int64) (*[]entity.ProductAttribute, error)&#10;&#9;FindProductOptionsByIDs(productOptionIDs []int64) (*[]entity.ProductOption, error)&#10;&#10;&#9;CreateProduct(product *entity.Product) error&#10;&#9;CreateProductAttributeInfo(productAttributeInfos *[]entity.ProductAttributeInfo) error&#10;&#9;CreateProductOptionInfo(productOptionInfos *[]entity.ProductOptionInfo) error&#10;&#9;CreateProductAttributeValuesIfNotExist(*[]entity.ProductAttributeValue) error&#10;&#9;CreateProductProductAttributeValues(*[]entity.ProductProductAttributeValue) error&#10;&#9;CreateProductSKUs(productSKUs *[]entity.ProductSKU) error&#10;&#9;CreateProductInventories(inventories *[]entity.ProductInventory) error&#10;&#9;CreateProductOptionCombinations(productOptionCombinations *[]entity.ProductOptionCombination) error&#10;&#9;CreateProductOptionValuesIfNotExist(productOptionValues *[]entity.ProductOptionValue) error&#10;&#10;&#9;DeleteProduct(id int64) error&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>