<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/internal/services/identity/internal/controller/auth_controller.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/internal/services/identity/internal/controller/auth_controller.go" />
              <option name="originalContent" value="package controller&#10;&#10;import (&#10;&#9;&quot;github.com/gin-gonic/gin&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/internal/pkg/logger&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/internal/pkg/rest&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/services/identity&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/services/identity/internal/dto/request&quot;&#10;&#9;&quot;net/http&quot;&#10;)&#10;&#10;type AuthController struct {&#10;&#9;logger      logger.Logger&#10;&#9;authService identity.AuthService&#10;}&#10;&#10;func NewAuthController(logger logger.Logger, service identity.AuthService) *AuthController {&#10;&#9;return &amp;AuthController{&#10;&#9;&#9;logger:      logger,&#10;&#9;&#9;authService: service,&#10;&#9;}&#10;}&#10;&#10;func (a *AuthController) Login() func(ctx *gin.Context) {&#10;&#9;return func(ctx *gin.Context) {&#10;&#9;&#9;var AuthRequest request.AuthRequest&#10;&#9;&#9;if err := ctx.ShouldBindJSON(&amp;AuthRequest); err != nil {&#10;&#9;&#9;&#9;a.logger.Error(&quot;Error binding JSON:&quot;, err)&#10;&#9;&#9;&#9;ctx.JSON(http.StatusBadRequest, rest.ErrorResponse{ApiError: rest.BadRequestError, Message: &quot;Invalid request body&quot;})&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#10;&#9;&#9;a.logger.Info(&quot;Processing login for user:&quot;, AuthRequest.Email)&#10;&#9;&#9;authResponse, err := a.authService.Login(AuthRequest)&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;a.logger.Error(&quot;Error during login:&quot;, err)&#10;&#9;&#9;&#9;ctx.JSON(http.StatusInternalServerError, rest.ErrorResponse{ApiError: rest.InternalServerErrorError, Message: &quot;Login failed&quot;})&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#10;&#9;&#9;a.logger.Info(&quot;Login successful for user:&quot;, AuthRequest.Email)&#10;&#9;&#9;ctx.JSON(http.StatusOK, rest.NewAPIResponse(http.StatusOK, &quot;Login successful&quot;, authResponse))&#10;&#9;}&#10;}&#10;" />
              <option name="updatedContent" value="package controller&#10;&#10;import (&#10;&#9;&quot;github.com/gin-gonic/gin&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/internal/pkg/logger&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/internal/pkg/rest&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/services/identity&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/services/identity/internal/dto/request&quot;&#10;&#9;&quot;net/http&quot;&#10;)&#10;&#10;type AuthController struct {&#10;&#9;logger      logger.Logger&#10;&#9;authService identity.AuthService&#10;}&#10;&#10;func NewAuthController(logger logger.Logger, service identity.AuthService) *AuthController {&#10;&#9;return &amp;AuthController{&#10;&#9;&#9;logger:      logger,&#10;&#9;&#9;authService: service,&#10;&#9;}&#10;}&#10;&#10;func (a *AuthController) Login() func(ctx *gin.Context) {&#10;&#9;return func(ctx *gin.Context) {&#10;&#9;&#9;var AuthRequest request.AuthRequest&#10;&#9;&#9;if err := ctx.ShouldBindJSON(&amp;AuthRequest); err != nil {&#10;&#9;&#9;&#9;a.logger.Error(&quot;Error binding JSON:&quot;, err)&#10;&#9;&#9;&#9;ctx.JSON(http.StatusBadRequest, rest.ErrorResponse{ApiError: rest.BadRequestError, Message: &quot;Invalid request body&quot;})&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#10;&#9;&#9;a.logger.Info(&quot;Processing login for user:&quot;, AuthRequest.Email)&#10;&#9;&#9;authResponse, err := a.authService.Login(AuthRequest)&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;a.logger.Error(&quot;Error during login:&quot;, err)&#10;&#9;&#9;&#9;ctx.JSON(http.StatusInternalServerError, rest.ErrorResponse{ApiError: rest.InternalServerErrorError, Message: &quot;Login failed&quot;})&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#10;&#9;&#9;a.logger.Info(&quot;Login successful for user:&quot;, AuthRequest.Email)&#10;&#9;&#9;ctx.JSON(http.StatusOK, rest.NewAPIResponse(http.StatusOK, &quot;Login successful&quot;, authResponse))&#10;&#9;}&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/internal/services/identity/internal/dto/request/refresh_token_request.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/internal/services/identity/internal/dto/request/refresh_token_request.go" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/internal/services/identity/internal/middleware/auth_middleware.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/internal/services/identity/internal/middleware/auth_middleware.go" />
              <option name="originalContent" value="package middleware&#10;&#10;import (&#10;&#9;&quot;net/http&quot;&#10;&#9;&quot;strings&quot;&#10;&#9;&quot;time&quot;&#10;&#10;&#9;&quot;github.com/gin-gonic/gin&quot;&#10;&#9;&quot;github.com/golang-jwt/jwt/v4&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/internal/pkg/logger&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/internal/pkg/rest&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/services/identity&quot;&#10;)&#10;&#10;type AuthMiddleware struct {&#10;&#9;logger         logger.Logger&#10;&#9;authService    identity.AuthService&#10;&#9;authRepository identity.AuthRepository&#10;&#9;jwtSecret      string&#10;}&#10;&#10;type JWTClaims struct {&#10;&#9;UserID           int64     `json:&quot;user_id&quot;`&#10;&#9;Email            string    `json:&quot;email&quot;`&#10;&#9;Roles            []string  `json:&quot;roles&quot;`&#10;&#9;Permissions      []string  `json:&quot;permissions&quot;`&#10;&#9;RefreshExpiresAt time.Time `json:&quot;refresh_expires_at&quot;`&#10;&#9;jwt.RegisteredClaims&#10;}&#10;&#10;func NewAuthMiddleware(logger logger.Logger, authRepository identity.AuthRepository, jwtSecret string) *AuthMiddleware {&#10;&#9;return &amp;AuthMiddleware{&#10;&#9;&#9;logger:         logger,&#10;&#9;&#9;authRepository: authRepository,&#10;&#9;&#9;jwtSecret:      jwtSecret,&#10;&#9;}&#10;}&#10;&#10;// AuthRequired validates JWT token and sets user info in context&#10;func (m *AuthMiddleware) AuthRequired() gin.HandlerFunc {&#10;&#9;return func(c *gin.Context) {&#10;&#9;&#9;authHeader := c.GetHeader(&quot;Authorization&quot;)&#10;&#9;&#9;if authHeader == &quot;&quot; {&#10;&#9;&#9;&#9;c.JSON(http.StatusUnauthorized, rest.ErrorResponse{&#10;&#9;&#9;&#9;&#9;ApiError: rest.UnauthorizedError,&#10;&#9;&#9;&#9;&#9;Message:  &quot;Authorization header required&quot;,&#10;&#9;&#9;&#9;})&#10;&#9;&#9;&#9;c.Abort()&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#10;&#9;&#9;tokenString := strings.TrimPrefix(authHeader, &quot;Bearer &quot;)&#10;&#9;&#9;if tokenString == authHeader {&#10;&#9;&#9;&#9;c.JSON(http.StatusUnauthorized, rest.ErrorResponse{&#10;&#9;&#9;&#9;&#9;ApiError: rest.UnauthorizedError,&#10;&#9;&#9;&#9;&#9;Message:  &quot;Bearer token required&quot;,&#10;&#9;&#9;&#9;})&#10;&#9;&#9;&#9;c.Abort()&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#10;&#9;&#9;claims, err := m.validateToken(tokenString)&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;m.logger.Error(&quot;Failed to validate JWT token&quot;, &quot;error&quot;, err)&#10;&#9;&#9;&#9;c.JSON(http.StatusUnauthorized, rest.ErrorResponse{&#10;&#9;&#9;&#9;&#9;ApiError: rest.UnauthorizedError,&#10;&#9;&#9;&#9;&#9;Message:  &quot;Invalid token&quot;,&#10;&#9;&#9;&#9;})&#10;&#9;&#9;&#9;c.Abort()&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// Set user info in context&#10;&#9;&#9;c.Set(&quot;user_id&quot;, claims.UserID)&#10;&#9;&#9;c.Set(&quot;email&quot;, claims.Email)&#10;&#9;&#9;c.Set(&quot;roles&quot;, claims.Roles)&#10;&#9;&#9;c.Set(&quot;permissions&quot;, claims.Permissions)&#10;&#10;&#9;&#9;c.Next()&#10;&#9;}&#10;}&#10;&#10;// RequirePermission checks if user has specific permission from JWT token&#10;func (m *AuthMiddleware) RequirePermission(permission string) gin.HandlerFunc {&#10;&#9;return func(c *gin.Context) {&#10;&#9;&#9;permissions, exists := c.Get(&quot;permissions&quot;)&#10;&#9;&#9;if !exists {&#10;&#9;&#9;&#9;c.JSON(http.StatusUnauthorized, rest.ErrorResponse{&#10;&#9;&#9;&#9;&#9;ApiError: rest.UnauthorizedError,&#10;&#9;&#9;&#9;&#9;Message:  &quot;User not authenticated&quot;,&#10;&#9;&#9;&#9;})&#10;&#9;&#9;&#9;c.Abort()&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#10;&#9;&#9;userPermissions := permissions.([]string)&#10;&#9;&#9;for _, userPermission := range userPermissions {&#10;&#9;&#9;&#9;if userPermission == permission {&#10;&#9;&#9;&#9;&#9;c.Next()&#10;&#9;&#9;&#9;&#9;return&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#10;&#9;&#9;c.JSON(http.StatusForbidden, rest.ErrorResponse{&#10;&#9;&#9;&#9;ApiError: rest.ForbiddenError,&#10;&#9;&#9;&#9;Message:  &quot;Insufficient permissions&quot;,&#10;&#9;&#9;})&#10;&#9;&#9;c.Abort()&#10;&#9;}&#10;}&#10;&#10;// RequireRole checks if user has specific role&#10;// NOTE: This middleware should be used AFTER AuthRequired middleware&#10;func (m *AuthMiddleware) RequireRole(role string) gin.HandlerFunc {&#10;&#9;return func(c *gin.Context) {&#10;&#9;&#9;roles, exists := c.Get(&quot;roles&quot;)&#10;&#9;&#9;if !exists {&#10;&#9;&#9;&#9;c.JSON(http.StatusUnauthorized, rest.ErrorResponse{&#10;&#9;&#9;&#9;&#9;ApiError: rest.UnauthorizedError,&#10;&#9;&#9;&#9;&#9;Message:  &quot;User not authenticated&quot;,&#10;&#9;&#9;&#9;})&#10;&#9;&#9;&#9;c.Abort()&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#10;&#9;&#9;userRoles := roles.([]string)&#10;&#9;&#9;for _, userRole := range userRoles {&#10;&#9;&#9;&#9;if userRole == role {&#10;&#9;&#9;&#9;&#9;c.Next()&#10;&#9;&#9;&#9;&#9;return&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#10;&#9;&#9;c.JSON(http.StatusForbidden, rest.ErrorResponse{&#10;&#9;&#9;&#9;ApiError: rest.ForbiddenError,&#10;&#9;&#9;&#9;Message:  &quot;Insufficient role permissions&quot;,&#10;&#9;&#9;})&#10;&#9;&#9;c.Abort()&#10;&#9;}&#10;}&#10;&#10;func (m *AuthMiddleware) validateToken(tokenString string) (*JWTClaims, error) {&#10;&#9;token, err := jwt.ParseWithClaims(tokenString, &amp;JWTClaims{}, func(token *jwt.Token) (interface{}, error) {&#10;&#9;&#9;return []byte(m.jwtSecret), nil&#10;&#9;})&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;// Convert claims to our custom JWTClaims type &amp; check validity&#10;&#9;claims, ok := token.Claims.(*JWTClaims)&#10;&#9;if ok {&#10;&#9;&#9;return claims, nil&#10;&#9;}&#10;&#10;&#9;// Check if token is valid and not expired&#10;&#9;if time.Now().After(claims.ExpiresAt.Time) {&#10;&#10;&#9;&#9;// If refresh token is not set or expired, return error&#10;&#9;&#9;if claims.RefreshExpiresAt.IsZero() || time.Now().After(claims.RefreshExpiresAt) {&#10;&#9;&#9;&#9;m.logger.Warn(&quot;Token expired&quot;, &quot;user_id&quot;, claims.UserID, &quot;email&quot;, claims.Email)&#10;&#9;&#9;&#9;return nil, jwt.ErrTokenExpired&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// If refresh token is valid, we can return the claims&#10;&#9;&#9;m.logger.Info(&quot;Token refreshed&quot;, &quot;user_id&quot;, claims.UserID, &quot;email&quot;, claims.Email)&#10;&#9;}&#10;&#10;&#9;return nil, jwt.ErrTokenMalformed&#10;}&#10;" />
              <option name="updatedContent" value="package middleware&#10;&#10;import (&#10;&#9;&quot;net/http&quot;&#10;&#9;&quot;strings&quot;&#10;&#9;&quot;time&quot;&#10;&#10;&#9;&quot;github.com/gin-gonic/gin&quot;&#10;&#9;&quot;github.com/golang-jwt/jwt/v4&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/internal/pkg/logger&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/internal/pkg/rest&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/services/identity&quot;&#10;)&#10;&#10;type AuthMiddleware struct {&#10;&#9;logger         logger.Logger&#10;&#9;authService    identity.AuthService&#10;&#9;authRepository identity.AuthRepository&#10;&#9;jwtSecret      string&#10;}&#10;&#10;type JWTClaims struct {&#10;&#9;UserID           int64     `json:&quot;user_id&quot;`&#10;&#9;Email            string    `json:&quot;email&quot;`&#10;&#9;Roles            []string  `json:&quot;roles&quot;`&#10;&#9;Permissions      []string  `json:&quot;permissions&quot;`&#10;&#9;RefreshExpiresAt time.Time `json:&quot;refresh_expires_at&quot;`&#10;&#9;jwt.RegisteredClaims&#10;}&#10;&#10;func NewAuthMiddleware(logger logger.Logger, authRepository identity.AuthRepository, jwtSecret string) *AuthMiddleware {&#10;&#9;return &amp;AuthMiddleware{&#10;&#9;&#9;logger:         logger,&#10;&#9;&#9;authRepository: authRepository,&#10;&#9;&#9;jwtSecret:      jwtSecret,&#10;&#9;}&#10;}&#10;&#10;// AuthRequired validates JWT token and sets user info in context&#10;func (m *AuthMiddleware) AuthRequired() gin.HandlerFunc {&#10;&#9;return func(c *gin.Context) {&#10;&#9;&#9;authHeader := c.GetHeader(&quot;Authorization&quot;)&#10;&#9;&#9;if authHeader == &quot;&quot; {&#10;&#9;&#9;&#9;c.JSON(http.StatusUnauthorized, rest.ErrorResponse{&#10;&#9;&#9;&#9;&#9;ApiError: rest.UnauthorizedError,&#10;&#9;&#9;&#9;&#9;Message:  &quot;Authorization header required&quot;,&#10;&#9;&#9;&#9;})&#10;&#9;&#9;&#9;c.Abort()&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#10;&#9;&#9;tokenString := strings.TrimPrefix(authHeader, &quot;Bearer &quot;)&#10;&#9;&#9;if tokenString == authHeader {&#10;&#9;&#9;&#9;c.JSON(http.StatusUnauthorized, rest.ErrorResponse{&#10;&#9;&#9;&#9;&#9;ApiError: rest.UnauthorizedError,&#10;&#9;&#9;&#9;&#9;Message:  &quot;Bearer token required&quot;,&#10;&#9;&#9;&#9;})&#10;&#9;&#9;&#9;c.Abort()&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#10;&#9;&#9;claims, newToken, err := m.validateTokenWithRefresh(tokenString)&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;m.logger.Error(&quot;Failed to validate JWT token&quot;, &quot;error&quot;, err)&#10;&#9;&#9;&#9;c.JSON(http.StatusUnauthorized, rest.ErrorResponse{&#10;&#9;&#9;&#9;&#9;ApiError: rest.UnauthorizedError,&#10;&#9;&#9;&#9;&#9;Message:  &quot;Invalid token&quot;,&#10;&#9;&#9;&#9;})&#10;&#9;&#9;&#9;c.Abort()&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// If a new token was generated, add it to response headers&#10;&#9;&#9;if newToken != &quot;&quot; {&#10;&#9;&#9;&#9;c.Header(&quot;X-New-Access-Token&quot;, newToken)&#10;&#9;&#9;&#9;m.logger.Info(&quot;Token auto-refreshed for user&quot;, &quot;user_id&quot;, claims.UserID, &quot;email&quot;, claims.Email)&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// Set user info in context&#10;&#9;&#9;c.Set(&quot;user_id&quot;, claims.UserID)&#10;&#9;&#9;c.Set(&quot;email&quot;, claims.Email)&#10;&#9;&#9;c.Set(&quot;roles&quot;, claims.Roles)&#10;&#9;&#9;c.Set(&quot;permissions&quot;, claims.Permissions)&#10;&#10;&#9;&#9;c.Next()&#10;&#9;}&#10;}&#10;&#10;// RequirePermission checks if user has specific permission from JWT token&#10;func (m *AuthMiddleware) RequirePermission(permission string) gin.HandlerFunc {&#10;&#9;return func(c *gin.Context) {&#10;&#9;&#9;permissions, exists := c.Get(&quot;permissions&quot;)&#10;&#9;&#9;if !exists {&#10;&#9;&#9;&#9;c.JSON(http.StatusUnauthorized, rest.ErrorResponse{&#10;&#9;&#9;&#9;&#9;ApiError: rest.UnauthorizedError,&#10;&#9;&#9;&#9;&#9;Message:  &quot;User not authenticated&quot;,&#10;&#9;&#9;&#9;})&#10;&#9;&#9;&#9;c.Abort()&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#10;&#9;&#9;userPermissions := permissions.([]string)&#10;&#9;&#9;for _, userPermission := range userPermissions {&#10;&#9;&#9;&#9;if userPermission == permission {&#10;&#9;&#9;&#9;&#9;c.Next()&#10;&#9;&#9;&#9;&#9;return&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#10;&#9;&#9;c.JSON(http.StatusForbidden, rest.ErrorResponse{&#10;&#9;&#9;&#9;ApiError: rest.ForbiddenError,&#10;&#9;&#9;&#9;Message:  &quot;Insufficient permissions&quot;,&#10;&#9;&#9;})&#10;&#9;&#9;c.Abort()&#10;&#9;}&#10;}&#10;&#10;// RequireRole checks if user has specific role&#10;// NOTE: This middleware should be used AFTER AuthRequired middleware&#10;func (m *AuthMiddleware) RequireRole(role string) gin.HandlerFunc {&#10;&#9;return func(c *gin.Context) {&#10;&#9;&#9;roles, exists := c.Get(&quot;roles&quot;)&#10;&#9;&#9;if !exists {&#10;&#9;&#9;&#9;c.JSON(http.StatusUnauthorized, rest.ErrorResponse{&#10;&#9;&#9;&#9;&#9;ApiError: rest.UnauthorizedError,&#10;&#9;&#9;&#9;&#9;Message:  &quot;User not authenticated&quot;,&#10;&#9;&#9;&#9;})&#10;&#9;&#9;&#9;c.Abort()&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#10;&#9;&#9;userRoles := roles.([]string)&#10;&#9;&#9;for _, userRole := range userRoles {&#10;&#9;&#9;&#9;if userRole == role {&#10;&#9;&#9;&#9;&#9;c.Next()&#10;&#9;&#9;&#9;&#9;return&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#10;&#9;&#9;c.JSON(http.StatusForbidden, rest.ErrorResponse{&#10;&#9;&#9;&#9;ApiError: rest.ForbiddenError,&#10;&#9;&#9;&#9;Message:  &quot;Insufficient role permissions&quot;,&#10;&#9;&#9;})&#10;&#9;&#9;c.Abort()&#10;&#9;}&#10;}&#10;&#10;func (m *AuthMiddleware) validateToken(tokenString string) (*JWTClaims, error) {&#10;&#9;token, err := jwt.ParseWithClaims(tokenString, &amp;JWTClaims{}, func(token *jwt.Token) (interface{}, error) {&#10;&#9;&#9;return []byte(m.jwtSecret), nil&#10;&#9;})&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;// Convert claims to our custom JWTClaims type &amp; check validity&#10;&#9;claims, ok := token.Claims.(*JWTClaims)&#10;&#9;if ok {&#10;&#9;&#9;return claims, nil&#10;&#9;}&#10;&#10;&#9;// Check if token is valid and not expired&#10;&#9;if time.Now().After(claims.ExpiresAt.Time) {&#10;&#10;&#9;&#9;// If refresh token is not set or expired, return error&#10;&#9;&#9;if claims.RefreshExpiresAt.IsZero() || time.Now().After(claims.RefreshExpiresAt) {&#10;&#9;&#9;&#9;m.logger.Warn(&quot;Token expired&quot;, &quot;user_id&quot;, claims.UserID, &quot;email&quot;, claims.Email)&#10;&#9;&#9;&#9;return nil, jwt.ErrTokenExpired&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// If refresh token is valid, we can return the claims&#10;&#9;&#9;m.logger.Info(&quot;Token refreshed&quot;, &quot;user_id&quot;, claims.UserID, &quot;email&quot;, claims.Email)&#10;&#9;}&#10;&#10;&#9;return nil, jwt.ErrTokenMalformed&#10;}&#10;&#10;func (m *AuthMiddleware) validateTokenWithRefresh(tokenString string) (*JWTClaims, string, error) {&#10;&#9;token, err := jwt.ParseWithClaims(tokenString, &amp;JWTClaims{}, func(token *jwt.Token) (interface{}, error) {&#10;&#9;&#9;return []byte(m.jwtSecret), nil&#10;&#9;})&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, &quot;&quot;, err&#10;&#9;}&#10;&#10;&#9;// Convert claims to our custom JWTClaims type &amp; check validity&#10;&#9;claims, ok := token.Claims.(*JWTClaims)&#10;&#9;if ok {&#10;&#9;&#9;return claims, &quot;&quot;, nil&#10;&#9;}&#10;&#10;&#9;// Check if token is valid and not expired&#10;&#9;if time.Now().After(claims.ExpiresAt.Time) {&#10;&#10;&#9;&#9;// If refresh token is not set or expired, return error&#10;&#9;&#9;if claims.RefreshExpiresAt.IsZero() || time.Now().After(claims.RefreshExpiresAt) {&#10;&#9;&#9;&#9;m.logger.Warn(&quot;Token expired&quot;, &quot;user_id&quot;, claims.UserID, &quot;email&quot;, claims.Email)&#10;&#9;&#9;&#9;return nil, &quot;&quot;, jwt.ErrTokenExpired&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// If refresh token is valid, we can return the claims&#10;&#9;&#9;m.logger.Info(&quot;Token refreshed&quot;, &quot;user_id&quot;, claims.UserID, &quot;email&quot;, claims.Email)&#10;&#10;&#9;&#9;// Generate new access token&#10;&#9;&#9;newToken, err := m.generateToken(claims)&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;return nil, &quot;&quot;, err&#10;&#9;&#9;}&#10;&#10;&#9;&#9;return claims, newToken, nil&#10;&#9;}&#10;&#10;&#9;return nil, &quot;&quot;, jwt.ErrTokenMalformed&#10;}&#10;&#10;func (m *AuthMiddleware) generateToken(claims *JWTClaims) (string, error) {&#10;&#9;// Set token claims&#10;&#9;claims.ExpiresAt = jwt.NewNumericDate(time.Now().Add(15 * time.Minute))&#10;&#9;claims.IssuedAt = jwt.NewNumericDate(time.Now())&#10;&#10;&#9;// Generate new token&#10;&#9;token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)&#10;&#9;return token.SignedString([]byte(m.jwtSecret))&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>