<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/internal/pkg/auth/auth_middleware.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/internal/pkg/auth/auth_middleware.go" />
              <option name="updatedContent" value="package auth&#10;&#10;import (&#10;&#9;&quot;net/http&quot;&#10;&#9;&quot;strings&quot;&#10;&#9;&quot;time&quot;&#10;&#10;&#9;&quot;github.com/gin-gonic/gin&quot;&#10;&#9;&quot;github.com/golang-jwt/jwt/v4&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/internal/pkg/logger&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/internal/pkg/rest&quot;&#10;)&#10;&#10;type SharedAuthMiddleware struct {&#10;&#9;logger    logger.Logger&#10;&#9;jwtSecret string&#10;}&#10;&#10;type JWTClaims struct {&#10;&#9;UserID           int64     `json:&quot;user_id&quot;`&#10;&#9;Email            string    `json:&quot;email&quot;`&#10;&#9;Roles            []string  `json:&quot;roles&quot;`&#10;&#9;Permissions      []string  `json:&quot;permissions&quot;`&#10;&#9;RefreshExpiresAt time.Time `json:&quot;refresh_expires_at&quot;`&#10;&#9;jwt.RegisteredClaims&#10;}&#10;&#10;func NewSharedAuthMiddleware(logger logger.Logger, jwtSecret string) *SharedAuthMiddleware {&#10;&#9;return &amp;SharedAuthMiddleware{&#10;&#9;&#9;logger:    logger,&#10;&#9;&#9;jwtSecret: jwtSecret,&#10;&#9;}&#10;}&#10;&#10;// AuthRequired validates JWT token and sets user info in context&#10;func (m *SharedAuthMiddleware) AuthRequired() gin.HandlerFunc {&#10;&#9;return func(c *gin.Context) {&#10;&#9;&#9;authHeader := c.GetHeader(&quot;Authorization&quot;)&#10;&#9;&#9;if authHeader == &quot;&quot; {&#10;&#9;&#9;&#9;c.JSON(http.StatusUnauthorized, rest.ErrorResponse{&#10;&#9;&#9;&#9;&#9;ApiError: rest.UnauthorizedError,&#10;&#9;&#9;&#9;&#9;Message:  &quot;Authorization header required&quot;,&#10;&#9;&#9;&#9;})&#10;&#9;&#9;&#9;c.Abort()&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#10;&#9;&#9;tokenString := strings.TrimPrefix(authHeader, &quot;Bearer &quot;)&#10;&#9;&#9;if tokenString == authHeader {&#10;&#9;&#9;&#9;c.JSON(http.StatusUnauthorized, rest.ErrorResponse{&#10;&#9;&#9;&#9;&#9;ApiError: rest.UnauthorizedError,&#10;&#9;&#9;&#9;&#9;Message:  &quot;Bearer token required&quot;,&#10;&#9;&#9;&#9;})&#10;&#9;&#9;&#9;c.Abort()&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#10;&#9;&#9;claims, err := m.validateToken(tokenString)&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;m.logger.Error(&quot;Failed to validate JWT token&quot;, &quot;error&quot;, err)&#10;&#9;&#9;&#9;c.JSON(http.StatusUnauthorized, rest.ErrorResponse{&#10;&#9;&#9;&#9;&#9;ApiError: rest.UnauthorizedError,&#10;&#9;&#9;&#9;&#9;Message:  &quot;Invalid token&quot;,&#10;&#9;&#9;&#9;})&#10;&#9;&#9;&#9;c.Abort()&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// Set user info in context for all services to use&#10;&#9;&#9;c.Set(&quot;user_id&quot;, claims.UserID)&#10;&#9;&#9;c.Set(&quot;email&quot;, claims.Email)&#10;&#9;&#9;c.Set(&quot;roles&quot;, claims.Roles)&#10;&#9;&#9;c.Set(&quot;permissions&quot;, claims.Permissions)&#10;&#10;&#9;&#9;c.Next()&#10;&#9;}&#10;}&#10;&#10;// RequirePermissions checks if user has ALL specified permissions&#10;func (m *SharedAuthMiddleware) RequirePermissions(requiredPermissions ...string) gin.HandlerFunc {&#10;&#9;return func(c *gin.Context) {&#10;&#9;&#9;permissions, exists := c.Get(&quot;permissions&quot;)&#10;&#9;&#9;if !exists {&#10;&#9;&#9;&#9;c.JSON(http.StatusUnauthorized, rest.ErrorResponse{&#10;&#9;&#9;&#9;&#9;ApiError: rest.UnauthorizedError,&#10;&#9;&#9;&#9;&#9;Message:  &quot;User not authenticated&quot;,&#10;&#9;&#9;&#9;})&#10;&#9;&#9;&#9;c.Abort()&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#10;&#9;&#9;userPermissions := permissions.([]string)&#10;&#9;&#9;userPermMap := make(map[string]bool)&#10;&#9;&#9;for _, perm := range userPermissions {&#10;&#9;&#9;&#9;userPermMap[perm] = true&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// Check if user has all required permissions&#10;&#9;&#9;for _, requiredPerm := range requiredPermissions {&#10;&#9;&#9;&#9;if !userPermMap[requiredPerm] {&#10;&#9;&#9;&#9;&#9;m.logger.Warn(&quot;Access denied - missing permission&quot;, &#10;&#9;&#9;&#9;&#9;&#9;&quot;user_id&quot;, c.Get(&quot;user_id&quot;), &#10;&#9;&#9;&#9;&#9;&#9;&quot;required_permission&quot;, requiredPerm)&#10;&#9;&#9;&#9;&#9;c.JSON(http.StatusForbidden, rest.ErrorResponse{&#10;&#9;&#9;&#9;&#9;&#9;ApiError: rest.ForbiddenError,&#10;&#9;&#9;&#9;&#9;&#9;Message:  &quot;Insufficient permissions&quot;,&#10;&#9;&#9;&#9;&#9;})&#10;&#9;&#9;&#9;&#9;c.Abort()&#10;&#9;&#9;&#9;&#9;return&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#10;&#9;&#9;c.Next()&#10;&#9;}&#10;}&#10;&#10;// RequireAnyPermission checks if user has ANY of the specified permissions&#10;func (m *SharedAuthMiddleware) RequireAnyPermission(permissions ...string) gin.HandlerFunc {&#10;&#9;return func(c *gin.Context) {&#10;&#9;&#9;userPermissions, exists := c.Get(&quot;permissions&quot;)&#10;&#9;&#9;if !exists {&#10;&#9;&#9;&#9;c.JSON(http.StatusUnauthorized, rest.ErrorResponse{&#10;&#9;&#9;&#9;&#9;ApiError: rest.UnauthorizedError,&#10;&#9;&#9;&#9;&#9;Message:  &quot;User not authenticated&quot;,&#10;&#9;&#9;&#9;})&#10;&#9;&#9;&#9;c.Abort()&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#10;&#9;&#9;userPerms := userPermissions.([]string)&#10;&#9;&#9;for _, userPerm := range userPerms {&#10;&#9;&#9;&#9;for _, requiredPerm := range permissions {&#10;&#9;&#9;&#9;&#9;if userPerm == requiredPerm {&#10;&#9;&#9;&#9;&#9;&#9;c.Next()&#10;&#9;&#9;&#9;&#9;&#9;return&#10;&#9;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#10;&#9;&#9;c.JSON(http.StatusForbidden, rest.ErrorResponse{&#10;&#9;&#9;&#9;ApiError: rest.ForbiddenError,&#10;&#9;&#9;&#9;Message:  &quot;Insufficient permissions&quot;,&#10;&#9;&#9;})&#10;&#9;&#9;c.Abort()&#10;&#9;}&#10;}&#10;&#10;// RequireRole checks if user has specific role&#10;func (m *SharedAuthMiddleware) RequireRole(role string) gin.HandlerFunc {&#10;&#9;return func(c *gin.Context) {&#10;&#9;&#9;roles, exists := c.Get(&quot;roles&quot;)&#10;&#9;&#9;if !exists {&#10;&#9;&#9;&#9;c.JSON(http.StatusUnauthorized, rest.ErrorResponse{&#10;&#9;&#9;&#9;&#9;ApiError: rest.UnauthorizedError,&#10;&#9;&#9;&#9;&#9;Message:  &quot;User not authenticated&quot;,&#10;&#9;&#9;&#9;})&#10;&#9;&#9;&#9;c.Abort()&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#10;&#9;&#9;userRoles := roles.([]string)&#10;&#9;&#9;for _, userRole := range userRoles {&#10;&#9;&#9;&#9;if userRole == role {&#10;&#9;&#9;&#9;&#9;c.Next()&#10;&#9;&#9;&#9;&#9;return&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#10;&#9;&#9;c.JSON(http.StatusForbidden, rest.ErrorResponse{&#10;&#9;&#9;&#9;ApiError: rest.ForbiddenError,&#10;&#9;&#9;&#9;Message:  &quot;Insufficient role permissions&quot;,&#10;&#9;&#9;})&#10;&#9;&#9;c.Abort()&#10;&#9;}&#10;}&#10;&#10;func (m *SharedAuthMiddleware) validateToken(tokenString string) (*JWTClaims, error) {&#10;&#9;token, err := jwt.ParseWithClaims(tokenString, &amp;JWTClaims{}, func(token *jwt.Token) (interface{}, error) {&#10;&#9;&#9;return []byte(m.jwtSecret), nil&#10;&#9;})&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;claims, ok := token.Claims.(*JWTClaims)&#10;&#9;if !ok {&#10;&#9;&#9;return nil, jwt.ErrTokenMalformed&#10;&#9;}&#10;&#10;&#9;now := time.Now()&#10;&#10;&#9;// Check if refresh token is expired (hard expiration)&#10;&#9;if !claims.RefreshExpiresAt.IsZero() &amp;&amp; now.After(claims.RefreshExpiresAt) {&#10;&#9;&#9;m.logger.Warn(&quot;Refresh token has expired&quot;, &quot;user_id&quot;, claims.UserID)&#10;&#9;&#9;return nil, jwt.NewValidationError(&quot;refresh token expired&quot;, jwt.ValidationErrorExpired)&#10;&#9;}&#10;&#10;&#9;// Check if access token is expired&#10;&#9;if claims.ExpiresAt != nil &amp;&amp; now.After(claims.ExpiresAt.Time) {&#10;&#9;&#9;m.logger.Info(&quot;Access token expired&quot;, &quot;user_id&quot;, claims.UserID)&#10;&#9;&#9;return nil, jwt.NewValidationError(&quot;access token expired&quot;, jwt.ValidationErrorExpired)&#10;&#9;}&#10;&#10;&#9;// Check not before&#10;&#9;if claims.NotBefore != nil &amp;&amp; now.Before(claims.NotBefore.Time) {&#10;&#9;&#9;return nil, jwt.NewValidationError(&quot;token used before valid&quot;, jwt.ValidationErrorNotValidYet)&#10;&#9;}&#10;&#10;&#9;// Check issued at&#10;&#9;if claims.IssuedAt != nil &amp;&amp; now.Before(claims.IssuedAt.Time) {&#10;&#9;&#9;return nil, jwt.NewValidationError(&quot;token issued in the future&quot;, jwt.ValidationErrorIssuedAt)&#10;&#9;}&#10;&#10;&#9;return claims, nil&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/internal/pkg/gateway/api_gateway.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/internal/pkg/gateway/api_gateway.go" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/internal/services/identity/cmd/main.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/internal/services/identity/cmd/main.go" />
              <option name="originalContent" value="package main&#10;&#10;import (&#10;&#9;&quot;errors&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/services/identity&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/services/identity/internal/config&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/services/identity/internal/constants&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/services/identity/internal/controller&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/services/identity/internal/entity&quot;&#10;&#9;customErr &quot;github.com/hthinh24/go-store/services/identity/internal/errors&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/services/identity/internal/middleware&quot;&#10;&#9;repository &quot;github.com/hthinh24/go-store/services/identity/internal/repository/postgres&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/services/identity/internal/service&quot;&#10;&#9;&quot;golang.org/x/crypto/bcrypt&quot;&#10;&#9;&quot;gorm.io/driver/postgres&quot;&#10;&#9;&quot;log&quot;&#10;&#9;&quot;time&quot;&#10;&#10;&#9;&quot;github.com/gin-gonic/gin&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/internal/pkg/logger&quot;&#10;&#9;&quot;gorm.io/gorm&quot;&#10;)&#10;&#10;func main() {&#10;&#9;// Load configuration from environment variables&#10;&#9;cfg, err := config.LoadConfig(&quot;.env&quot;)&#10;&#9;if err != nil {&#10;&#9;&#9;log.Fatalf(&quot;Failed to load config: %v&quot;, err)&#10;&#9;}&#10;&#10;&#9;// Initialize logger&#10;&#9;appLogger := logger.NewAppLogger(cfg.LogLevel)&#10;&#9;appLogger.Info(&quot;Starting Identity Service...&quot;)&#10;&#9;appLogger.Info(&quot;Environment: %s&quot;, cfg.Environment)&#10;&#10;&#9;// Initialize database connection&#10;&#9;db, err := initDatabase(cfg)&#10;&#9;if err != nil {&#10;&#9;&#9;appLogger.Error(&quot;Failed to connect to database: %v&quot;, err)&#10;&#9;&#9;log.Fatal(err)&#10;&#9;}&#10;&#9;appLogger.Info(&quot;Database connected successfully&quot;)&#10;&#10;&#9;// Initialize repositories&#10;&#9;userRepo := repository.NewUserRepository(logger.WithComponent(cfg.LogLevel, &quot;USER-REPOSITORY&quot;), db)&#10;&#9;authRepo := repository.NewAuthRepository(logger.WithComponent(cfg.LogLevel, &quot;AUTH-REPOSITORY&quot;), db)&#10;&#10;&#9;// Initialize services&#10;&#9;authService := service.NewAuthService(logger.WithComponent(cfg.LogLevel, &quot;AUTH-SERVICE&quot;), userRepo, authRepo, cfg)&#10;&#9;userService := service.NewUserService(logger.WithComponent(cfg.LogLevel, &quot;USER-SERVICE&quot;), userRepo, authRepo)&#10;&#10;&#9;// Initialize middleware&#10;&#9;authMiddleware := middleware.NewAuthMiddleware(logger.WithComponent(cfg.LogLevel, &quot;AUTH-MIDDLEWARE&quot;), cfg.JWTSecret)&#10;&#10;&#9;// Initialize controllers&#10;&#9;authController := controller.NewAuthController(logger.WithComponent(cfg.LogLevel, &quot;AUTH-CONTROLLER&quot;), authService)&#10;&#9;userController := controller.NewUserController(logger.WithComponent(cfg.LogLevel, &quot;USER-CONTROLLER&quot;), userService)&#10;&#10;&#9;// Setup router&#10;&#9;router := setupRouter(authController, userController, authMiddleware)&#10;&#10;&#9;// Initialize user data&#10;&#9;if err := initUserData(userRepo, authRepo); err != nil {&#10;&#9;&#9;appLogger.Error(&quot;Failed to initialize user data: %v&quot;, err)&#10;&#9;&#9;log.Fatal(err)&#10;&#9;} else {&#10;&#9;&#9;appLogger.Info(&quot;User data initialized successfully&quot;)&#10;&#9;}&#10;&#10;&#9;// Start server&#10;&#9;serverAddr := cfg.GetServerAddress()&#10;&#9;appLogger.Info(&quot;Server starting on %s&quot;, serverAddr)&#10;&#9;if err := router.Run(serverAddr); err != nil {&#10;&#9;&#9;appLogger.Error(&quot;Failed to start server: %v&quot;, err)&#10;&#9;&#9;log.Fatal(err)&#10;&#9;}&#10;}&#10;&#10;func initDatabase(cfg *config.AppConfig) (*gorm.DB, error) {&#10;&#9;db, err := gorm.Open(postgres.Open(cfg.GetDatabaseURL()), &amp;gorm.Config{})&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;return db, nil&#10;}&#10;&#10;func setupRouter(authController *controller.AuthController, userController *controller.UserController, authMiddleware *middleware.AuthMiddleware) *gin.Engine {&#10;&#9;router := gin.Default()&#10;&#10;&#9;// Health check endpoint&#10;&#9;router.GET(&quot;/health&quot;, func(c *gin.Context) {&#10;&#9;&#9;c.JSON(200, gin.H{&quot;status&quot;: &quot;healthy&quot;})&#10;&#9;})&#10;&#10;&#9;// API routes&#10;&#9;api := router.Group(&quot;/api/v1&quot;)&#10;&#9;{&#10;&#9;&#9;auth := api.Group(&quot;/auth&quot;)&#10;&#9;&#9;users := api.Group(&quot;/users&quot;)&#10;&#10;&#9;&#9;// Public routes&#10;&#9;&#9;{&#10;&#9;&#9;&#9;users.POST(&quot;&quot;, userController.CreateUser())&#10;&#10;&#9;&#9;&#9;auth.POST(&quot;/login&quot;, authController.Login())&#10;&#9;&#9;&#9;auth.GET(&quot;/verify&quot;, authController.Verify())&#10;&#9;&#9;}&#10;&#10;&#9;&#9;auth.Use(authMiddleware.AuthRequired())&#10;&#9;&#9;{&#10;&#9;&#9;&#9;// TODO - Create login, register, logout endpoints&#10;&#9;&#9;&#9;//auth.POST(&quot;/register&quot;, authController.Register())&#10;&#9;&#9;&#9;//auth.POST(&quot;/logout&quot;, authMiddleware.AuthRequired(), authController.Logout())&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// User routes (protected)&#10;&#9;&#9;users.Use(authMiddleware.AuthRequired())&#10;&#9;&#9;{&#10;&#9;&#9;&#9;users.GET(&quot;:id&quot;, userController.GetUserByID())&#10;&#10;&#9;&#9;&#9;users.PUT(&quot;/:id/profile&quot;, userController.UpdateUserProfile())&#10;&#9;&#9;&#9;users.PATCH(&quot;/:id/register-merchant&quot;,&#10;&#9;&#9;&#9;&#9;userController.UpdateToMerchantAccount())&#10;&#9;&#9;&#9;users.PATCH(&quot;/:id/password&quot;, userController.UpdateUserPassword())&#10;&#10;&#9;&#9;&#9;// Admin only routes&#10;&#9;&#9;&#9;users.GET(&quot;&quot;, authMiddleware.RequireRole(&quot;admin&quot;), userController.GetUsers())&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;return router&#10;}&#10;&#10;func initUserData(userRepository identity.UserRepository, authRepository identity.AuthRepository) error {&#10;&#9;user, err := userRepository.FindUserByID(1)&#10;&#9;if user != nil {&#10;&#9;&#9;return nil&#10;&#9;}&#10;&#10;&#9;// Create admin user if it does not exist&#10;&#9;if errors.Is(err, customErr.ErrUserNotFound{}) {&#10;&#9;&#9;user = createAdminUser()&#10;&#9;&#9;if err := userRepository.CreateUser(user); err != nil {&#10;&#9;&#9;&#9;return err&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;// Assign admin role to the user&#10;&#9;role, err := authRepository.FindRoleByName(string(constants.RoleAdmin))&#10;&#9;if err != nil {&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;adminRole := entity.UserRoles{&#10;&#9;&#9;UserID: user.ID,&#10;&#9;&#9;RoleID: role.ID,&#10;&#9;}&#10;&#10;&#9;if err := authRepository.AddRoleToUser(&amp;adminRole); err != nil {&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;log.Printf(&quot;Admin user initialized: %s&quot;, user.Email)&#10;&#9;return nil&#10;}&#10;&#10;func createAdminUser() *entity.User {&#10;&#9;password := &quot;admin&quot;&#10;&#9;hashedPassword, _ := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)&#10;&#10;&#9;return &amp;entity.User{&#10;&#9;&#9;Email:        &quot;test@gmail.com&quot;,&#10;&#9;&#9;Password:     string(hashedPassword),&#10;&#9;&#9;ProviderID:   &quot;1&quot;,&#10;&#9;&#9;ProviderName: &quot;app&quot;,&#10;&#9;&#9;LastName:     &quot;Admin&quot;,&#10;&#9;&#9;FirstName:    &quot;Admin&quot;,&#10;&#9;&#9;Avatar:       &quot;https://example.com/avatar.png&quot;,&#10;&#9;&#9;Gender:       string(constants.GenderOther),&#10;&#9;&#9;PhoneNumber:  &quot;1234567890&quot;,&#10;&#9;&#9;DateOfBirth:  time.Now(),&#10;&#9;&#9;Status:       string(constants.UserStatusActive),&#10;&#9;}&#10;}&#10;" />
              <option name="updatedContent" value="package main&#10;&#10;import (&#10;&#9;&quot;errors&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/services/identity&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/services/identity/internal/client&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/services/identity/internal/config&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/services/identity/internal/constants&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/services/identity/internal/controller&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/services/identity/internal/entity&quot;&#10;&#9;customErr &quot;github.com/hthinh24/go-store/services/identity/internal/errors&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/services/identity/internal/middleware&quot;&#10;&#9;repository &quot;github.com/hthinh24/go-store/services/identity/internal/repository/postgres&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/services/identity/internal/service&quot;&#10;&#9;&quot;golang.org/x/crypto/bcrypt&quot;&#10;&#9;&quot;gorm.io/driver/postgres&quot;&#10;&#9;&quot;log&quot;&#10;&#9;&quot;time&quot;&#10;&#10;&#9;&quot;github.com/gin-gonic/gin&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/internal/pkg/logger&quot;&#10;&#9;&quot;gorm.io/gorm&quot;&#10;)&#10;&#10;func main() {&#10;&#9;// Load configuration from environment variables&#10;&#9;cfg, err := config.LoadConfig(&quot;.env&quot;)&#10;&#9;if err != nil {&#10;&#9;&#9;log.Fatalf(&quot;Failed to load config: %v&quot;, err)&#10;&#9;}&#10;&#10;&#9;// Initialize logger&#10;&#9;appLogger := logger.NewAppLogger(cfg.LogLevel)&#10;&#9;appLogger.Info(&quot;Starting Identity Service...&quot;)&#10;&#9;appLogger.Info(&quot;Environment: %s&quot;, cfg.Environment)&#10;&#10;&#9;// Initialize database connection&#10;&#9;db, err := initDatabase(cfg)&#10;&#9;if err != nil {&#10;&#9;&#9;appLogger.Error(&quot;Failed to connect to database: %v&quot;, err)&#10;&#9;&#9;log.Fatal(err)&#10;&#9;}&#10;&#9;appLogger.Info(&quot;Database connected successfully&quot;)&#10;&#10;&#9;// Initialize repositories&#10;&#9;userRepo := repository.NewUserRepository(logger.WithComponent(cfg.LogLevel, &quot;USER-REPOSITORY&quot;), db)&#10;&#9;authRepo := repository.NewAuthRepository(logger.WithComponent(cfg.LogLevel, &quot;AUTH-REPOSITORY&quot;), db)&#10;&#10;&#9;// Initialize external service clients&#10;&#9;var cartClient client.CartClient&#10;&#9;if cfg.CartServiceURL != &quot;&quot; {&#10;&#9;&#9;cartClient = client.NewCartClient(cfg.CartServiceURL)&#10;&#9;&#9;appLogger.Info(&quot;Cart service client initialized with URL: %s&quot;, cfg.CartServiceURL)&#10;&#9;} else {&#10;&#9;&#9;appLogger.Warn(&quot;Cart service URL not configured, cart creation will be skipped&quot;)&#10;&#9;&#9;cartClient = client.NewCartClient(&quot;&quot;) // This will effectively disable cart creation&#10;&#9;}&#10;&#10;&#9;// Initialize services&#10;&#9;authService := service.NewAuthService(logger.WithComponent(cfg.LogLevel, &quot;AUTH-SERVICE&quot;), userRepo, authRepo, cfg)&#10;&#9;userService := service.NewUserService(logger.WithComponent(cfg.LogLevel, &quot;USER-SERVICE&quot;), userRepo, authRepo, cartClient)&#10;&#10;&#9;// Initialize middleware&#10;&#9;authMiddleware := middleware.NewAuthMiddleware(logger.WithComponent(cfg.LogLevel, &quot;AUTH-MIDDLEWARE&quot;), cfg.JWTSecret)&#10;&#10;&#9;// Initialize controllers&#10;&#9;authController := controller.NewAuthController(logger.WithComponent(cfg.LogLevel, &quot;AUTH-CONTROLLER&quot;), authService)&#10;&#9;userController := controller.NewUserController(logger.WithComponent(cfg.LogLevel, &quot;USER-CONTROLLER&quot;), userService)&#10;&#10;&#9;// Setup router&#10;&#9;router := setupRouter(authController, userController, authMiddleware)&#10;&#10;&#9;// Initialize user data&#10;&#9;if err := initUserData(userRepo, authRepo); err != nil {&#10;&#9;&#9;appLogger.Error(&quot;Failed to initialize user data: %v&quot;, err)&#10;&#9;&#9;log.Fatal(err)&#10;&#9;} else {&#10;&#9;&#9;appLogger.Info(&quot;User data initialized successfully&quot;)&#10;&#9;}&#10;&#10;&#9;// Start server&#10;&#9;serverAddr := cfg.GetServerAddress()&#10;&#9;appLogger.Info(&quot;Server starting on %s&quot;, serverAddr)&#10;&#9;if err := router.Run(serverAddr); err != nil {&#10;&#9;&#9;appLogger.Error(&quot;Failed to start server: %v&quot;, err)&#10;&#9;&#9;log.Fatal(err)&#10;&#9;}&#10;}&#10;&#10;func initDatabase(cfg *config.AppConfig) (*gorm.DB, error) {&#10;&#9;db, err := gorm.Open(postgres.Open(cfg.GetDatabaseURL()), &amp;gorm.Config{})&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;return db, nil&#10;}&#10;&#10;func setupRouter(authController *controller.AuthController, userController *controller.UserController, authMiddleware *middleware.AuthMiddleware) *gin.Engine {&#10;&#9;router := gin.Default()&#10;&#10;&#9;// Health check endpoint&#10;&#9;router.GET(&quot;/health&quot;, func(c *gin.Context) {&#10;&#9;&#9;c.JSON(200, gin.H{&quot;status&quot;: &quot;healthy&quot;})&#10;&#9;})&#10;&#10;&#9;// API routes&#10;&#9;api := router.Group(&quot;/api/v1&quot;)&#10;&#9;{&#10;&#9;&#9;auth := api.Group(&quot;/auth&quot;)&#10;&#9;&#9;users := api.Group(&quot;/users&quot;)&#10;&#10;&#9;&#9;// Public routes&#10;&#9;&#9;{&#10;&#9;&#9;&#9;users.POST(&quot;&quot;, userController.CreateUser())&#10;&#10;&#9;&#9;&#9;auth.POST(&quot;/login&quot;, authController.Login())&#10;&#9;&#9;&#9;auth.GET(&quot;/verify&quot;, authController.Verify())&#10;&#9;&#9;}&#10;&#10;&#9;&#9;auth.Use(authMiddleware.AuthRequired())&#10;&#9;&#9;{&#10;&#9;&#9;&#9;// TODO - Create login, register, logout endpoints&#10;&#9;&#9;&#9;//auth.POST(&quot;/register&quot;, authController.Register())&#10;&#9;&#9;&#9;//auth.POST(&quot;/logout&quot;, authMiddleware.AuthRequired(), authController.Logout())&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// User routes (protected)&#10;&#9;&#9;users.Use(authMiddleware.AuthRequired())&#10;&#9;&#9;{&#10;&#9;&#9;&#9;users.GET(&quot;:id&quot;, userController.GetUserByID())&#10;&#10;&#9;&#9;&#9;users.PUT(&quot;/:id/profile&quot;, userController.UpdateUserProfile())&#10;&#9;&#9;&#9;users.PATCH(&quot;/:id/register-merchant&quot;,&#10;&#9;&#9;&#9;&#9;userController.UpdateToMerchantAccount())&#10;&#9;&#9;&#9;users.PATCH(&quot;/:id/password&quot;, userController.UpdateUserPassword())&#10;&#10;&#9;&#9;&#9;// Admin only routes&#10;&#9;&#9;&#9;users.GET(&quot;&quot;, authMiddleware.RequireRole(&quot;admin&quot;), userController.GetUsers())&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;return router&#10;}&#10;&#10;func initUserData(userRepository identity.UserRepository, authRepository identity.AuthRepository) error {&#10;&#9;user, err := userRepository.FindUserByID(1)&#10;&#9;if user != nil {&#10;&#9;&#9;return nil&#10;&#9;}&#10;&#10;&#9;// Create admin user if it does not exist&#10;&#9;if errors.Is(err, customErr.ErrUserNotFound{}) {&#10;&#9;&#9;user = createAdminUser()&#10;&#9;&#9;if err := userRepository.CreateUser(user); err != nil {&#10;&#9;&#9;&#9;return err&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;// Assign admin role to the user&#10;&#9;role, err := authRepository.FindRoleByName(string(constants.RoleAdmin))&#10;&#9;if err != nil {&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;adminRole := entity.UserRoles{&#10;&#9;&#9;UserID: user.ID,&#10;&#9;&#9;RoleID: role.ID,&#10;&#9;}&#10;&#10;&#9;if err := authRepository.AddRoleToUser(&amp;adminRole); err != nil {&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;log.Printf(&quot;Admin user initialized: %s&quot;, user.Email)&#10;&#9;return nil&#10;}&#10;&#10;func createAdminUser() *entity.User {&#10;&#9;password := &quot;admin&quot;&#10;&#9;hashedPassword, _ := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)&#10;&#10;&#9;return &amp;entity.User{&#10;&#9;&#9;Email:        &quot;test@gmail.com&quot;,&#10;&#9;&#9;Password:     string(hashedPassword),&#10;&#9;&#9;ProviderID:   &quot;1&quot;,&#10;&#9;&#9;ProviderName: &quot;app&quot;,&#10;&#9;&#9;LastName:     &quot;Admin&quot;,&#10;&#9;&#9;FirstName:    &quot;Admin&quot;,&#10;&#9;&#9;Avatar:       &quot;https://example.com/avatar.png&quot;,&#10;&#9;&#9;Gender:       string(constants.GenderOther),&#10;&#9;&#9;PhoneNumber:  &quot;1234567890&quot;,&#10;&#9;&#9;DateOfBirth:  time.Now(),&#10;&#9;&#9;Status:       string(constants.UserStatusActive),&#10;&#9;}&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/internal/services/identity/internal/client/cart_client.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/internal/services/identity/internal/client/cart_client.go" />
              <option name="updatedContent" value="package client&#10;&#10;import (&#10;&#9;&quot;bytes&quot;&#10;&#9;&quot;context&quot;&#10;&#9;&quot;encoding/json&quot;&#10;&#9;&quot;fmt&quot;&#10;&#9;&quot;net/http&quot;&#10;&#9;&quot;time&quot;&#10;)&#10;&#10;type CartClient interface {&#10;&#9;CreateCart(ctx context.Context, userID int64) error&#10;}&#10;&#10;type cartClient struct {&#10;&#9;baseURL    string&#10;&#9;httpClient *http.Client&#10;}&#10;&#10;func NewCartClient(baseURL string) CartClient {&#10;&#9;return &amp;cartClient{&#10;&#9;&#9;baseURL: baseURL,&#10;&#9;&#9;httpClient: &amp;http.Client{&#10;&#9;&#9;&#9;Timeout: 10 * time.Second,&#10;&#9;&#9;},&#10;&#9;}&#10;}&#10;&#10;type CreateCartRequest struct {&#10;&#9;UserID int64 `json:&quot;user_id&quot;`&#10;}&#10;&#10;func (c *cartClient) CreateCart(ctx context.Context, userID int64) error {&#10;&#9;req := CreateCartRequest{&#10;&#9;&#9;UserID: userID,&#10;&#9;}&#10;&#10;&#9;jsonData, err := json.Marshal(req)&#10;&#9;if err != nil {&#10;&#9;&#9;return fmt.Errorf(&quot;failed to marshal cart request: %w&quot;, err)&#10;&#9;}&#10;&#10;&#9;httpReq, err := http.NewRequestWithContext(ctx, &quot;POST&quot;, c.baseURL+&quot;/carts&quot;, bytes.NewBuffer(jsonData))&#10;&#9;if err != nil {&#10;&#9;&#9;return fmt.Errorf(&quot;failed to create request: %w&quot;, err)&#10;&#9;}&#10;&#10;&#9;httpReq.Header.Set(&quot;Content-Type&quot;, &quot;application/json&quot;)&#10;&#10;&#9;resp, err := c.httpClient.Do(httpReq)&#10;&#9;if err != nil {&#10;&#9;&#9;return fmt.Errorf(&quot;failed to call cart service: %w&quot;, err)&#10;&#9;}&#10;&#9;defer resp.Body.Close()&#10;&#10;&#9;if resp.StatusCode != http.StatusCreated {&#10;&#9;&#9;return fmt.Errorf(&quot;cart service returned status: %d&quot;, resp.StatusCode)&#10;&#9;}&#10;&#10;&#9;return nil&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/internal/services/identity/internal/config/config.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/internal/services/identity/internal/config/config.go" />
              <option name="originalContent" value="package config&#10;&#10;import (&#10;&#9;&quot;fmt&quot;&#10;&#9;&quot;os&quot;&#10;&#9;&quot;time&quot;&#10;&#10;&#9;&quot;github.com/joho/godotenv&quot;&#10;)&#10;&#10;type AppConfig struct {&#10;&#9;// Database Configuration&#10;&#9;DBHost     string&#10;&#9;DBPort     string&#10;&#9;DBUser     string&#10;&#9;DBPassword string&#10;&#9;DBName     string&#10;&#9;DBSSLMode  string&#10;&#10;&#9;// JWT Configuration&#10;&#9;JWTSecret           string&#10;&#9;JWTExpiresIn        time.Duration&#10;&#9;JWTRefreshExpiresIn time.Duration&#10;&#10;&#9;// Server Configuration&#10;&#9;ServerPort string&#10;&#9;ServerHost string&#10;&#10;&#9;// Log Configuration&#10;&#9;LogLevel string&#10;&#10;&#9;// Redis Configuration&#10;&#9;RedisHost     string&#10;&#9;RedisPort     string&#10;&#9;RedisPassword string&#10;&#10;&#9;// Environment&#10;&#9;Environment string&#10;}&#10;&#10;func LoadConfig(filename string) (*AppConfig, error) {&#10;&#9;// Load .env file in development&#10;&#9;if os.Getenv(&quot;ENV&quot;) != &quot;production&quot; {&#10;&#9;&#9;err := godotenv.Load(filename)&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;// Don't fail if .env file doesn't exist&#10;&#9;&#9;&#9;fmt.Println(&quot;Warning: .env file not found, using system environment variables&quot;)&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;config := &amp;AppConfig{&#10;&#9;&#9;DBHost:     getEnv(&quot;DB_HOST&quot;, &quot;localhost&quot;),&#10;&#9;&#9;DBPort:     getEnv(&quot;DB_PORT&quot;, &quot;5432&quot;),&#10;&#9;&#9;DBUser:     getEnv(&quot;DB_USER&quot;, &quot;postgres&quot;),&#10;&#9;&#9;DBPassword: getEnv(&quot;DB_PASSWORD&quot;, &quot;&quot;),&#10;&#9;&#9;DBName:     getEnv(&quot;DB_NAME&quot;, &quot;go_store_identity&quot;),&#10;&#9;&#9;DBSSLMode:  getEnv(&quot;DB_SSL_MODE&quot;, &quot;disable&quot;),&#10;&#10;&#9;&#9;JWTSecret:           getEnv(&quot;JWT_SECRET&quot;, &quot;&quot;),&#10;&#9;&#9;JWTExpiresIn:        time.Hour * 24,      // Default to 24 hours&#10;&#9;&#9;JWTRefreshExpiresIn: time.Hour * 24 * 30, // Default to 30 days&#10;&#10;&#9;&#9;ServerPort: getEnv(&quot;SERVER_PORT&quot;, &quot;8080&quot;),&#10;&#9;&#9;ServerHost: getEnv(&quot;SERVER_HOST&quot;, &quot;localhost&quot;),&#10;&#10;&#9;&#9;LogLevel: getEnv(&quot;LOG_LEVEL&quot;, &quot;info&quot;),&#10;&#10;&#9;&#9;RedisHost:     getEnv(&quot;REDIS_HOST&quot;, &quot;localhost&quot;),&#10;&#9;&#9;RedisPort:     getEnv(&quot;REDIS_PORT&quot;, &quot;6379&quot;),&#10;&#9;&#9;RedisPassword: getEnv(&quot;REDIS_PASSWORD&quot;, &quot;&quot;),&#10;&#10;&#9;&#9;Environment: getEnv(&quot;ENV&quot;, &quot;development&quot;),&#10;&#9;}&#10;&#10;&#9;// Validate required fields&#10;&#9;if err := config.validate(); err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;return config, nil&#10;}&#10;&#10;func (c *AppConfig) validate() error {&#10;&#9;if c.JWTSecret == &quot;&quot; {&#10;&#9;&#9;return fmt.Errorf(&quot;JWT_SECRET is required&quot;)&#10;&#9;}&#10;&#10;&#9;if len(c.JWTSecret) &lt; 32 {&#10;&#9;&#9;return fmt.Errorf(&quot;JWT_SECRET must be at least 32 characters long&quot;)&#10;&#9;}&#10;&#10;&#9;if c.DBPassword == &quot;&quot; {&#10;&#9;&#9;return fmt.Errorf(&quot;DB_PASSWORD is required&quot;)&#10;&#9;}&#10;&#10;&#9;return nil&#10;}&#10;&#10;func (c *AppConfig) GetDatabaseURL() string {&#10;&#9;return fmt.Sprintf(&quot;host=%s user=%s password=%s dbname=%s port=%s sslmode=%s TimeZone=Asia/Shanghai&quot;,&#10;&#9;&#9;c.DBHost, c.DBUser, c.DBPassword, c.DBName, c.DBPort, c.DBSSLMode)&#10;}&#10;&#10;func (c *AppConfig) GetServerAddress() string {&#10;&#9;return fmt.Sprintf(&quot;%s:%s&quot;, c.ServerHost, c.ServerPort)&#10;}&#10;&#10;func (c *AppConfig) IsProduction() bool {&#10;&#9;return c.Environment == &quot;production&quot;&#10;}&#10;&#10;// getEnv gets environment variable with fallback&#10;func getEnv(key, fallback string) string {&#10;&#9;if value := os.Getenv(key); value != &quot;&quot; {&#10;&#9;&#9;return value&#10;&#9;}&#10;&#9;return fallback&#10;}&#10;" />
              <option name="updatedContent" value="package config&#13;&#10;&#13;&#10;import (&#13;&#10;&#9;&quot;fmt&quot;&#13;&#10;&#9;&quot;os&quot;&#13;&#10;&#9;&quot;time&quot;&#13;&#10;&#13;&#10;&#9;&quot;github.com/joho/godotenv&quot;&#13;&#10;)&#13;&#10;&#13;&#10;type AppConfig struct {&#13;&#10;&#9;// Database Configuration&#13;&#10;&#9;DBHost     string&#13;&#10;&#9;DBPort     string&#13;&#10;&#9;DBUser     string&#13;&#10;&#9;DBPassword string&#13;&#10;&#9;DBName     string&#13;&#10;&#9;DBSSLMode  string&#13;&#10;&#13;&#10;&#9;// JWT Configuration&#13;&#10;&#9;JWTSecret           string&#13;&#10;&#9;JWTExpiresIn        time.Duration&#13;&#10;&#9;JWTRefreshExpiresIn time.Duration&#13;&#10;&#13;&#10;&#9;// Server Configuration&#13;&#10;&#9;ServerPort string&#13;&#10;&#9;ServerHost string&#13;&#10;&#13;&#10;&#9;// Log Configuration&#13;&#10;&#9;LogLevel string&#13;&#10;&#13;&#10;&#9;// Redis Configuration&#13;&#10;&#9;RedisHost     string&#13;&#10;&#9;RedisPort     string&#13;&#10;&#9;RedisPassword string&#13;&#10;&#13;&#10;&#9;// External Services&#13;&#10;&#9;CartServiceURL string&#13;&#10;&#13;&#10;&#9;// Environment&#13;&#10;&#9;Environment string&#13;&#10;}&#13;&#10;&#13;&#10;func LoadConfig(filename string) (*AppConfig, error) {&#13;&#10;&#9;// Load .env file in development&#13;&#10;&#9;if os.Getenv(&quot;ENV&quot;) != &quot;production&quot; {&#13;&#10;&#9;&#9;err := godotenv.Load(filename)&#13;&#10;&#9;&#9;if err != nil {&#13;&#10;&#9;&#9;&#9;// Don't fail if .env file doesn't exist&#13;&#10;&#9;&#9;&#9;fmt.Println(&quot;Warning: .env file not found, using system environment variables&quot;)&#13;&#10;&#9;&#9;}&#13;&#10;&#9;}&#13;&#10;&#13;&#10;&#9;config := &amp;AppConfig{&#13;&#10;&#9;&#9;DBHost:     getEnv(&quot;DB_HOST&quot;, &quot;localhost&quot;),&#13;&#10;&#9;&#9;DBPort:     getEnv(&quot;DB_PORT&quot;, &quot;5432&quot;),&#13;&#10;&#9;&#9;DBUser:     getEnv(&quot;DB_USER&quot;, &quot;postgres&quot;),&#13;&#10;&#9;&#9;DBPassword: getEnv(&quot;DB_PASSWORD&quot;, &quot;&quot;),&#13;&#10;&#9;&#9;DBName:     getEnv(&quot;DB_NAME&quot;, &quot;go_store_identity&quot;),&#13;&#10;&#9;&#9;DBSSLMode:  getEnv(&quot;DB_SSL_MODE&quot;, &quot;disable&quot;),&#13;&#10;&#13;&#10;&#9;&#9;JWTSecret:           getEnv(&quot;JWT_SECRET&quot;, &quot;&quot;),&#13;&#10;&#9;&#9;JWTExpiresIn:        time.Hour * 24,      // Default to 24 hours&#13;&#10;&#9;&#9;JWTRefreshExpiresIn: time.Hour * 24 * 30, // Default to 30 days&#13;&#10;&#13;&#10;&#9;&#9;ServerPort: getEnv(&quot;SERVER_PORT&quot;, &quot;8080&quot;),&#13;&#10;&#9;&#9;ServerHost: getEnv(&quot;SERVER_HOST&quot;, &quot;localhost&quot;),&#13;&#10;&#13;&#10;&#9;&#9;LogLevel: getEnv(&quot;LOG_LEVEL&quot;, &quot;info&quot;),&#13;&#10;&#13;&#10;&#9;&#9;RedisHost:     getEnv(&quot;REDIS_HOST&quot;, &quot;localhost&quot;),&#13;&#10;&#9;&#9;RedisPort:     getEnv(&quot;REDIS_PORT&quot;, &quot;6379&quot;),&#13;&#10;&#9;&#9;RedisPassword: getEnv(&quot;REDIS_PASSWORD&quot;, &quot;&quot;),&#13;&#10;&#13;&#10;&#9;&#9;CartServiceURL: getEnv(&quot;CART_SERVICE_URL&quot;, &quot;&quot;),&#13;&#10;&#13;&#10;&#9;&#9;Environment: getEnv(&quot;ENV&quot;, &quot;development&quot;),&#13;&#10;&#9;}&#13;&#10;&#13;&#10;&#9;// Validate required fields&#13;&#10;&#9;if err := config.validate(); err != nil {&#13;&#10;&#9;&#9;return nil, err&#13;&#10;&#9;}&#13;&#10;&#13;&#10;&#9;return config, nil&#13;&#10;}&#13;&#10;&#13;&#10;func (c *AppConfig) validate() error {&#13;&#10;&#9;if c.JWTSecret == &quot;&quot; {&#13;&#10;&#9;&#9;return fmt.Errorf(&quot;JWT_SECRET is required&quot;)&#13;&#10;&#9;}&#13;&#10;&#13;&#10;&#9;if len(c.JWTSecret) &lt; 32 {&#13;&#10;&#9;&#9;return fmt.Errorf(&quot;JWT_SECRET must be at least 32 characters long&quot;)&#13;&#10;&#9;}&#13;&#10;&#13;&#10;&#9;if c.DBPassword == &quot;&quot; {&#13;&#10;&#9;&#9;return fmt.Errorf(&quot;DB_PASSWORD is required&quot;)&#13;&#10;&#9;}&#13;&#10;&#13;&#10;&#9;return nil&#13;&#10;}&#13;&#10;&#13;&#10;func (c *AppConfig) GetDatabaseURL() string {&#13;&#10;&#9;return fmt.Sprintf(&quot;host=%s user=%s password=%s dbname=%s port=%s sslmode=%s TimeZone=Asia/Shanghai&quot;,&#13;&#10;&#9;&#9;c.DBHost, c.DBUser, c.DBPassword, c.DBName, c.DBPort, c.DBSSLMode)&#13;&#10;}&#13;&#10;&#13;&#10;func (c *AppConfig) GetServerAddress() string {&#13;&#10;&#9;return fmt.Sprintf(&quot;%s:%s&quot;, c.ServerHost, c.ServerPort)&#13;&#10;}&#13;&#10;&#13;&#10;func (c *AppConfig) IsProduction() bool {&#13;&#10;&#9;return c.Environment == &quot;production&quot;&#13;&#10;}&#13;&#10;&#13;&#10;// getEnv gets environment variable with fallback&#13;&#10;func getEnv(key, fallback string) string {&#13;&#10;&#9;if value := os.Getenv(key); value != &quot;&quot; {&#13;&#10;&#9;&#9;return value&#13;&#10;&#9;}&#13;&#10;&#9;return fallback&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/internal/services/identity/internal/dto/request/refresh_token_request.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/internal/services/identity/internal/dto/request/refresh_token_request.go" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/internal/services/identity/internal/service/user_service.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/internal/services/identity/internal/service/user_service.go" />
              <option name="originalContent" value="package service&#10;&#10;import (&#10;&#9;log &quot;github.com/hthinh24/go-store/internal/pkg/logger&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/services/identity&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/services/identity/internal/constants&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/services/identity/internal/dto/request&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/services/identity/internal/dto/response&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/services/identity/internal/entity&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/services/identity/internal/errors&quot;&#10;&#9;&quot;golang.org/x/crypto/bcrypt&quot;&#10;)&#10;&#10;type userService struct {&#10;&#9;logger         log.Logger&#10;&#9;userRepository identity.UserRepository&#10;&#9;authRepository identity.AuthRepository&#10;}&#10;&#10;func NewUserService(logger log.Logger,&#10;&#9;userRepository identity.UserRepository,&#10;&#9;authRepository identity.AuthRepository) identity.UserService {&#10;&#9;return &amp;userService{&#10;&#9;&#9;logger:         logger,&#10;&#9;&#9;userRepository: userRepository,&#10;&#9;&#9;authRepository: authRepository,&#10;&#9;}&#10;}&#10;&#10;func (u *userService) GetUserByID(id int64) (*response.UserResponse, error) {&#10;&#9;u.logger.Info(&quot;Get user by ID:&quot;, id)&#10;&#10;&#9;user, err := u.userRepository.FindUserByID(id)&#10;&#9;if err != nil {&#10;&#9;&#9;u.logger.Error(&quot;Error fetching user by ID:&quot;, err)&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;u.logger.Info(&quot;Get user successfully&quot;)&#10;&#9;return createUserResponse(user), nil&#10;}&#10;&#10;func (u *userService) GetUsers() (*[]response.UserResponse, error) {&#10;&#9;u.logger.Info(&quot;Get all users&quot;)&#10;&#10;&#9;users, err := u.userRepository.FindUsers()&#10;&#9;if err != nil {&#10;&#9;&#9;u.logger.Error(&quot;Error fetching users:&quot;, err)&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;u.logger.Info(&quot;Get all users successfully&quot;)&#10;&#9;var userResponses []response.UserResponse&#10;&#9;for _, user := range *users {&#10;&#9;&#9;userResponses = append(userResponses, *createUserResponse(&amp;user))&#10;&#9;}&#10;&#9;return &amp;userResponses, nil&#10;}&#10;&#10;func (u *userService) CreateUser(data *request.CreateUserRequest) (*response.UserResponse, error) {&#10;&#9;u.logger.Info(&quot;Creating new user with email:&quot;, data.Email)&#10;&#10;&#9;hashedPassword, err := bcrypt.GenerateFromPassword([]byte(data.Password), bcrypt.DefaultCost)&#10;&#9;if err != nil {&#10;&#9;&#9;u.logger.Error(&quot;Error hashing password:&quot;, err)&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;data.Password = string(hashedPassword)&#10;&#9;user := u.createUserEntity(data)&#10;&#9;if err := u.userRepository.CreateUser(user); err != nil {&#10;&#9;&#9;u.logger.Error(&quot;Error creating user:&quot;, err)&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;if err := u.setUserRoleToUser(user); err != nil {&#10;&#9;&#9;u.logger.Error(&quot;Error setting user role:&quot;, err)&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;u.logger.Info(&quot;Successfully created user with ID:&quot;, user.ID)&#10;&#9;return createUserResponse(user), nil&#10;}&#10;&#10;func (u *userService) UpdateUserProfile(id int64, data *request.UpdateUserProfileRequest) (*response.UserResponse, error) {&#10;&#9;user, err := u.userRepository.FindUserByID(id)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;u.logger.Info(&quot;Updating user profile with ID:&quot;, id)&#10;&#10;&#9;updateUserEntity(user, data)&#10;&#9;if err := u.userRepository.UpdateUserProfile(user); err != nil {&#10;&#9;&#9;u.logger.Error(&quot;Error updating user profile:&quot;, err)&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;u.logger.Info(&quot;Successfully updated user profile with ID:&quot;, id)&#10;&#9;return createUserResponse(user), nil&#10;}&#10;&#10;func (u *userService) UpdateUserPassword(id int64, data *request.UpdateUserPasswordRequest) (*response.UserResponse, error) {&#10;&#9;u.logger.Info(&quot;Find user by ID:&quot;, id)&#10;&#10;&#9;user, err := u.userRepository.FindUserByID(id)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;u.logger.Info(&quot;Updating user password for ID:&quot;, id)&#10;&#10;&#9;if err := bcrypt.CompareHashAndPassword([]byte(user.Password), []byte(data.OldPassword)); err != nil {&#10;&#9;&#9;u.logger.Error(&quot;Old password does not match for user ID:&quot;, id)&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;hashedPassword, err := bcrypt.GenerateFromPassword([]byte(data.NewPassword), bcrypt.DefaultCost)&#10;&#9;if err != nil {&#10;&#9;&#9;u.logger.Error(&quot;Error hashing new password:&quot;, err)&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;user.Password = string(hashedPassword)&#10;&#9;if err := u.userRepository.UpdateUserPassword(user); err != nil {&#10;&#9;&#9;u.logger.Error(&quot;Error updating user password:&quot;, err)&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#9;u.logger.Info(&quot;Successfully updated user password for ID:&quot;, id)&#10;&#9;return createUserResponse(user), nil&#10;}&#10;&#10;func (u *userService) UpdateToMerchantAccount(userID int64) error {&#10;&#9;u.logger.Info(&quot;Updating user to merchant account with ID:&quot;, userID)&#10;&#10;&#9;// TODO - Implement logic to update user to merchant account&#10;&#10;&#9;user, err := u.userRepository.FindUserByID(userID)&#10;&#9;if err != nil {&#10;&#9;&#9;u.logger.Error(&quot;Error finding user by ID:&quot;, userID, &quot;Error:&quot;, err)&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;if user.Status != string(constants.UserStatusActive) {&#10;&#9;&#9;u.logger.Error(&quot;User is not active, cannot update to merchant account:&quot;, userID)&#10;&#9;&#9;return errors.ErrUserNotActive{}&#10;&#9;}&#10;&#10;&#9;role, err := u.authRepository.FindRoleByName(string(constants.RoleMerchant))&#10;&#9;if err != nil {&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;userRoles := createUserRoleEntity(user, role)&#10;&#9;if err := u.authRepository.AddRoleToUser(userRoles); err != nil {&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;return nil&#10;}&#10;&#10;func (u *userService) DeleteUser(id int64) error {&#10;&#9;u.logger.Info(&quot;Deleting user with ID:&quot;, id)&#10;&#10;&#9;err := u.userRepository.DeleteUser(id)&#10;&#9;if err != nil {&#10;&#9;&#9;u.logger.Error(&quot;Error deleting user with ID:&quot;, id, &quot;Error:&quot;, err)&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;u.logger.Info(&quot;Successfully deleted user with ID:&quot;, id)&#10;&#9;return nil&#10;}&#10;&#10;func (u *userService) createUserEntity(user *request.CreateUserRequest) *entity.User {&#10;&#9;return &amp;entity.User{&#10;&#9;&#9;Email:        user.Email,&#10;&#9;&#9;Password:     user.Password,&#10;&#9;&#9;ProviderID:   user.ProviderID,&#10;&#9;&#9;ProviderName: user.ProviderName,&#10;&#9;&#9;LastName:     user.LastName,&#10;&#9;&#9;FirstName:    user.FirstName,&#10;&#9;&#9;Avatar:       user.Avatar,&#10;&#9;&#9;Gender:       user.Gender,&#10;&#9;&#9;PhoneNumber:  user.PhoneNumber,&#10;&#9;&#9;DateOfBirth:  user.DateOfBirth,&#10;&#9;&#9;Status:       user.Status,&#10;&#9;}&#10;}&#10;&#10;func createUserRoleEntity(user *entity.User, role *entity.Role) *entity.UserRoles {&#10;&#9;return &amp;entity.UserRoles{&#10;&#9;&#9;UserID: user.ID,&#10;&#9;&#9;RoleID: role.ID,&#10;&#9;}&#10;}&#10;&#10;func updateUserEntity(user *entity.User, data *request.UpdateUserProfileRequest) {&#10;&#9;if data.Email != nil {&#10;&#9;&#9;user.Email = *data.Email&#10;&#9;}&#10;&#9;if data.LastName != nil {&#10;&#9;&#9;user.LastName = *data.LastName&#10;&#9;}&#10;&#9;if data.FirstName != nil {&#10;&#9;&#9;user.FirstName = *data.FirstName&#10;&#9;}&#10;&#9;if data.Avatar != nil {&#10;&#9;&#9;user.Avatar = *data.Avatar&#10;&#9;}&#10;&#9;if data.Gender != nil {&#10;&#9;&#9;user.Gender = *data.Gender&#10;&#9;}&#10;&#9;if data.PhoneNumber != nil {&#10;&#9;&#9;user.PhoneNumber = *data.PhoneNumber&#10;&#9;}&#10;&#9;if data.DateOfBirth != nil {&#10;&#9;&#9;user.DateOfBirth = *data.DateOfBirth&#10;&#9;}&#10;}&#10;&#10;func createUserResponse(user *entity.User) *response.UserResponse {&#10;&#9;return &amp;response.UserResponse{&#10;&#9;&#9;ID:          user.ID,&#10;&#9;&#9;Email:       user.Email,&#10;&#9;&#9;LastName:    user.LastName,&#10;&#9;&#9;FirstName:   user.FirstName,&#10;&#9;&#9;Avatar:      user.Avatar,&#10;&#9;&#9;Gender:      user.Gender,&#10;&#9;&#9;PhoneNumber: user.PhoneNumber,&#10;&#9;&#9;DateOfBirth: user.DateOfBirth,&#10;&#9;&#9;Status:      user.Status,&#10;&#9;}&#10;}&#10;&#10;func (u *userService) setUserRoleToUser(user *entity.User) error {&#10;&#9;role, err := u.authRepository.FindRoleByName(string(constants.RoleUser))&#10;&#9;if err != nil {&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;userRoles := createUserRoleEntity(user, role)&#10;&#10;&#9;if err := u.authRepository.AddRoleToUser(userRoles); err != nil {&#10;&#9;&#9;u.logger.Error(&quot;Error assigning role to user:&quot;, err)&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;u.logger.Info(&quot;Successfully assigned role to user with ID:&quot;, user.ID)&#10;&#9;return nil&#10;}&#10;" />
              <option name="updatedContent" value="package service&#10;&#10;import (&#10;&#9;&quot;context&quot;&#10;&#9;&quot;time&quot;&#10;&#10;&#9;log &quot;github.com/hthinh24/go-store/internal/pkg/logger&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/services/identity&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/services/identity/internal/client&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/services/identity/internal/constants&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/services/identity/internal/dto/request&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/services/identity/internal/dto/response&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/services/identity/internal/entity&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/services/identity/internal/errors&quot;&#10;&#9;&quot;golang.org/x/crypto/bcrypt&quot;&#10;)&#10;&#10;type userService struct {&#10;&#9;logger         log.Logger&#10;&#9;userRepository identity.UserRepository&#10;&#9;authRepository identity.AuthRepository&#10;&#9;cartClient     client.CartClient&#10;}&#10;&#10;func NewUserService(logger log.Logger,&#10;&#9;userRepository identity.UserRepository,&#10;&#9;authRepository identity.AuthRepository,&#10;&#9;cartClient client.CartClient) identity.UserService {&#10;&#9;return &amp;userService{&#10;&#9;&#9;logger:         logger,&#10;&#9;&#9;userRepository: userRepository,&#10;&#9;&#9;authRepository: authRepository,&#10;&#9;&#9;cartClient:     cartClient,&#10;&#9;}&#10;}&#10;&#10;func (u *userService) GetUserByID(id int64) (*response.UserResponse, error) {&#10;&#9;u.logger.Info(&quot;Get user by ID:&quot;, id)&#10;&#10;&#9;user, err := u.userRepository.FindUserByID(id)&#10;&#9;if err != nil {&#10;&#9;&#9;u.logger.Error(&quot;Error fetching user by ID:&quot;, err)&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;u.logger.Info(&quot;Get user successfully&quot;)&#10;&#9;return createUserResponse(user), nil&#10;}&#10;&#10;func (u *userService) GetUsers() (*[]response.UserResponse, error) {&#10;&#9;u.logger.Info(&quot;Get all users&quot;)&#10;&#10;&#9;users, err := u.userRepository.FindUsers()&#10;&#9;if err != nil {&#10;&#9;&#9;u.logger.Error(&quot;Error fetching users:&quot;, err)&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;u.logger.Info(&quot;Get all users successfully&quot;)&#10;&#9;var userResponses []response.UserResponse&#10;&#9;for _, user := range *users {&#10;&#9;&#9;userResponses = append(userResponses, *createUserResponse(&amp;user))&#10;&#9;}&#10;&#9;return &amp;userResponses, nil&#10;}&#10;&#10;func (u *userService) CreateUser(data *request.CreateUserRequest) (*response.UserResponse, error) {&#10;&#9;u.logger.Info(&quot;Creating new user with email:&quot;, data.Email)&#10;&#10;&#9;hashedPassword, err := bcrypt.GenerateFromPassword([]byte(data.Password), bcrypt.DefaultCost)&#10;&#9;if err != nil {&#10;&#9;&#9;u.logger.Error(&quot;Error hashing password:&quot;, err)&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;data.Password = string(hashedPassword)&#10;&#9;user := u.createUserEntity(data)&#10;&#9;if err := u.userRepository.CreateUser(user); err != nil {&#10;&#9;&#9;u.logger.Error(&quot;Error creating user:&quot;, err)&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;if err := u.setUserRoleToUser(user); err != nil {&#10;&#9;&#9;u.logger.Error(&quot;Error setting user role:&quot;, err)&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;// Create a cart for the new user&#10;&#9;ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)&#10;&#9;defer cancel()&#10;&#10;&#9;if err := u.cartClient.CreateCart(ctx, user.ID); err != nil {&#10;&#9;&#9;u.logger.Error(&quot;Error creating cart for user:&quot;, err)&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;u.logger.Info(&quot;Successfully created user with ID:&quot;, user.ID)&#10;&#9;return createUserResponse(user), nil&#10;}&#10;&#10;func (u *userService) UpdateUserProfile(id int64, data *request.UpdateUserProfileRequest) (*response.UserResponse, error) {&#10;&#9;user, err := u.userRepository.FindUserByID(id)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;u.logger.Info(&quot;Updating user profile with ID:&quot;, id)&#10;&#10;&#9;updateUserEntity(user, data)&#10;&#9;if err := u.userRepository.UpdateUserProfile(user); err != nil {&#10;&#9;&#9;u.logger.Error(&quot;Error updating user profile:&quot;, err)&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;u.logger.Info(&quot;Successfully updated user profile with ID:&quot;, id)&#10;&#9;return createUserResponse(user), nil&#10;}&#10;&#10;func (u *userService) UpdateUserPassword(id int64, data *request.UpdateUserPasswordRequest) (*response.UserResponse, error) {&#10;&#9;u.logger.Info(&quot;Find user by ID:&quot;, id)&#10;&#10;&#9;user, err := u.userRepository.FindUserByID(id)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;u.logger.Info(&quot;Updating user password for ID:&quot;, id)&#10;&#10;&#9;if err := bcrypt.CompareHashAndPassword([]byte(user.Password), []byte(data.OldPassword)); err != nil {&#10;&#9;&#9;u.logger.Error(&quot;Old password does not match for user ID:&quot;, id)&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;hashedPassword, err := bcrypt.GenerateFromPassword([]byte(data.NewPassword), bcrypt.DefaultCost)&#10;&#9;if err != nil {&#10;&#9;&#9;u.logger.Error(&quot;Error hashing new password:&quot;, err)&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;user.Password = string(hashedPassword)&#10;&#9;if err := u.userRepository.UpdateUserPassword(user); err != nil {&#10;&#9;&#9;u.logger.Error(&quot;Error updating user password:&quot;, err)&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#9;u.logger.Info(&quot;Successfully updated user password for ID:&quot;, id)&#10;&#9;return createUserResponse(user), nil&#10;}&#10;&#10;func (u *userService) UpdateToMerchantAccount(userID int64) error {&#10;&#9;u.logger.Info(&quot;Updating user to merchant account with ID:&quot;, userID)&#10;&#10;&#9;// TODO - Implement logic to update user to merchant account&#10;&#10;&#9;user, err := u.userRepository.FindUserByID(userID)&#10;&#9;if err != nil {&#10;&#9;&#9;u.logger.Error(&quot;Error finding user by ID:&quot;, userID, &quot;Error:&quot;, err)&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;if user.Status != string(constants.UserStatusActive) {&#10;&#9;&#9;u.logger.Error(&quot;User is not active, cannot update to merchant account:&quot;, userID)&#10;&#9;&#9;return errors.ErrUserNotActive{}&#10;&#9;}&#10;&#10;&#9;role, err := u.authRepository.FindRoleByName(string(constants.RoleMerchant))&#10;&#9;if err != nil {&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;userRoles := createUserRoleEntity(user, role)&#10;&#9;if err := u.authRepository.AddRoleToUser(userRoles); err != nil {&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;return nil&#10;}&#10;&#10;func (u *userService) DeleteUser(id int64) error {&#10;&#9;u.logger.Info(&quot;Deleting user with ID:&quot;, id)&#10;&#10;&#9;err := u.userRepository.DeleteUser(id)&#10;&#9;if err != nil {&#10;&#9;&#9;u.logger.Error(&quot;Error deleting user with ID:&quot;, id, &quot;Error:&quot;, err)&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;u.logger.Info(&quot;Successfully deleted user with ID:&quot;, id)&#10;&#9;return nil&#10;}&#10;&#10;func (u *userService) createUserEntity(user *request.CreateUserRequest) *entity.User {&#10;&#9;return &amp;entity.User{&#10;&#9;&#9;Email:        user.Email,&#10;&#9;&#9;Password:     user.Password,&#10;&#9;&#9;ProviderID:   user.ProviderID,&#10;&#9;&#9;ProviderName: user.ProviderName,&#10;&#9;&#9;LastName:     user.LastName,&#10;&#9;&#9;FirstName:    user.FirstName,&#10;&#9;&#9;Avatar:       user.Avatar,&#10;&#9;&#9;Gender:       user.Gender,&#10;&#9;&#9;PhoneNumber:  user.PhoneNumber,&#10;&#9;&#9;DateOfBirth:  user.DateOfBirth,&#10;&#9;&#9;Status:       user.Status,&#10;&#9;}&#10;}&#10;&#10;func createUserRoleEntity(user *entity.User, role *entity.Role) *entity.UserRoles {&#10;&#9;return &amp;entity.UserRoles{&#10;&#9;&#9;UserID: user.ID,&#10;&#9;&#9;RoleID: role.ID,&#10;&#9;}&#10;}&#10;&#10;func updateUserEntity(user *entity.User, data *request.UpdateUserProfileRequest) {&#10;&#9;if data.Email != nil {&#10;&#9;&#9;user.Email = *data.Email&#10;&#9;}&#10;&#9;if data.LastName != nil {&#10;&#9;&#9;user.LastName = *data.LastName&#10;&#9;}&#10;&#9;if data.FirstName != nil {&#10;&#9;&#9;user.FirstName = *data.FirstName&#10;&#9;}&#10;&#9;if data.Avatar != nil {&#10;&#9;&#9;user.Avatar = *data.Avatar&#10;&#9;}&#10;&#9;if data.Gender != nil {&#10;&#9;&#9;user.Gender = *data.Gender&#10;&#9;}&#10;&#9;if data.PhoneNumber != nil {&#10;&#9;&#9;user.PhoneNumber = *data.PhoneNumber&#10;&#9;}&#10;&#9;if data.DateOfBirth != nil {&#10;&#9;&#9;user.DateOfBirth = *data.DateOfBirth&#10;&#9;}&#10;}&#10;&#10;func createUserResponse(user *entity.User) *response.UserResponse {&#10;&#9;return &amp;response.UserResponse{&#10;&#9;&#9;ID:          user.ID,&#10;&#9;&#9;Email:       user.Email,&#10;&#9;&#9;LastName:    user.LastName,&#10;&#9;&#9;FirstName:   user.FirstName,&#10;&#9;&#9;Avatar:      user.Avatar,&#10;&#9;&#9;Gender:      user.Gender,&#10;&#9;&#9;PhoneNumber: user.PhoneNumber,&#10;&#9;&#9;DateOfBirth: user.DateOfBirth,&#10;&#9;&#9;Status:      user.Status,&#10;&#9;}&#10;}&#10;&#10;func (u *userService) setUserRoleToUser(user *entity.User) error {&#10;&#9;role, err := u.authRepository.FindRoleByName(string(constants.RoleUser))&#10;&#9;if err != nil {&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;userRoles := createUserRoleEntity(user, role)&#10;&#10;&#9;if err := u.authRepository.AddRoleToUser(userRoles); err != nil {&#10;&#9;&#9;u.logger.Error(&quot;Error assigning role to user:&quot;, err)&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;u.logger.Info(&quot;Successfully assigned role to user with ID:&quot;, user.ID)&#10;&#9;return nil&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/internal/services/product/internal/infra/repository/postgres/product_repository.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/internal/services/product/internal/infra/repository/postgres/product_repository.go" />
              <option name="originalContent" value="package postgres&#10;&#10;import (&#10;&#9;&quot;strings&quot;&#10;&#10;&#9;&quot;github.com/hthinh24/go-store/internal/pkg/logger&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/services/product/internal/dto/repository&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/services/product/internal/entity&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/services/product/internal/errors&quot;&#10;&#9;&quot;gorm.io/gorm&quot;&#10;)&#10;&#10;type productRepository struct {&#10;&#9;logger logger.Logger&#10;&#9;db     *gorm.DB&#10;}&#10;&#10;func NewProductRepository(logger logger.Logger, db *gorm.DB) *productRepository {&#10;&#9;return &amp;productRepository{&#10;&#9;&#9;logger: logger,&#10;&#9;&#9;db:     db,&#10;&#9;}&#10;}&#10;&#10;func (p *productRepository) BeginTx() error {&#10;&#9;p.logger.Info(&quot;Beginning transaction&quot;)&#10;&#9;tx := p.db.Begin()&#10;&#9;if tx.Error != nil {&#10;&#9;&#9;p.logger.Error(&quot;Failed to begin transaction:&quot;, tx.Error)&#10;&#9;&#9;return tx.Error&#10;&#9;}&#10;&#9;p.db = tx&#10;&#9;return nil&#10;}&#10;&#10;func (p *productRepository) CommitTx() error {&#10;&#9;p.logger.Info(&quot;Committing transaction&quot;)&#10;&#9;if err := p.db.Commit().Error; err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Failed to commit transaction:&quot;, err)&#10;&#10;&#9;&#9;// Rollback the transaction if commit fails&#10;&#9;&#9;if rbErr := p.db.Rollback().Error; rbErr != nil {&#10;&#9;&#9;&#9;p.logger.Error(&quot;Failed to rollback transaction after commit failure:&quot;, rbErr)&#10;&#9;&#9;&#9;return rbErr&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;return nil&#10;}&#10;&#10;func (p *productRepository) FindProductByID(id int64) (*entity.Product, error) {&#10;&#9;p.logger.Info(&quot;Finding product by ID:&quot;, id)&#10;&#10;&#9;var product entity.Product&#10;&#9;if err := p.db.Where(&quot;id = ?&quot;, id).First(&amp;product).Error; err != nil {&#10;&#9;&#9;return nil, errors.ErrProductNotFound{}&#10;&#9;}&#10;&#10;&#9;return &amp;product, nil&#10;}&#10;&#10;func (p *productRepository) FindProductAttributesInfoByProductID(productID int64) (*[]entity.ProductAttributeInfo, error) {&#10;&#9;p.logger.Info(&quot;Finding product attributes info by product ID:&quot;, productID)&#10;&#10;&#9;var productAttributesInfo []entity.ProductAttributeInfo&#10;&#9;if err := p.db.Where(&quot;product_id = ?&quot;, productID).Find(&amp;productAttributesInfo).Error; err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Failed to find product attributes info by product ID:&quot;, productID, &quot;Error:&quot;, err)&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;p.logger.Info(&quot;Found product attributes info:&quot;, productAttributesInfo)&#10;&#9;return &amp;productAttributesInfo, nil&#10;}&#10;&#10;func (p *productRepository) FindProductOptionsInfoByProductID(productID int64) (*[]entity.ProductOptionInfo, error) {&#10;&#9;p.logger.Info(&quot;Finding product options info by product ID:&quot;, productID)&#10;&#10;&#9;var productOptionsInfo []entity.ProductOptionInfo&#10;&#9;if err := p.db.Where(&quot;product_id = ?&quot;, productID).Find(&amp;productOptionsInfo).Error; err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Failed to find product options info by product ID:&quot;, productID, &quot;Error:&quot;, err)&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;p.logger.Info(&quot;Found product options info:&quot;, productOptionsInfo)&#10;&#9;return &amp;productOptionsInfo, nil&#10;}&#10;&#10;func (p *productRepository) FindProductSKUsByProductID(id int64) (*[]repository.ProductSKUDetail, error) {&#10;&#9;p.logger.Info(&quot;Finding product SKUs by product ID:&quot;, id)&#10;&#10;&#9;var productSKUsWithInventory []repository.ProductSKUDetail&#10;&#9;if err := p.db.&#10;&#9;&#9;Table(entity.ProductSKU{}.TableName()+&quot; AS ps&quot;).&#10;&#9;&#9;Select(&quot;ps.id, ps.sku, ps.sku_signature, ps.extra_price,&quot;+&#10;&#9;&#9;&#9;&quot;ps.sale_type&quot;, &quot;ps.sale_value&quot;, &quot;ps.sale_start_date&quot;, &quot;ps.sale_end_date&quot;).&#10;&#9;&#9;Joins(&quot;JOIN product_inventory AS pi ON ps.id = pi.product_sku_id&quot;).&#10;&#9;&#9;Where(&quot;ps.product_id = ?&quot;, id).&#10;&#9;&#9;Find(&amp;productSKUsWithInventory).Error; err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Failed to find product SKUs by product ID:&quot;, id, &quot;Error:&quot;, err)&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;return &amp;productSKUsWithInventory, nil&#10;}&#10;&#10;func (p *productRepository) FindProductAttributesByIDs(productAttributeIDs []int64) (*[]entity.ProductAttribute, error) {&#10;&#9;p.logger.Info(&quot;Finding product attributes by IDs:&quot;, productAttributeIDs)&#10;&#10;&#9;var productAttributes []entity.ProductAttribute&#10;&#9;if err := p.db.Where(&quot;id IN ?&quot;, productAttributeIDs).Find(&amp;productAttributes).Error; err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Failed to find product attributes by IDs:&quot;, productAttributeIDs, &quot;Error:&quot;, err)&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;p.logger.Info(&quot;Found product attributes:&quot;, productAttributes)&#10;&#9;return &amp;productAttributes, nil&#10;}&#10;&#10;func (p *productRepository) FindProductOptionsByIDs(productOptionIDs []int64) (*[]entity.ProductOption, error) {&#10;&#9;p.logger.Info(&quot;Finding product options by IDs:&quot;, productOptionIDs)&#10;&#10;&#9;var productOptions []entity.ProductOption&#10;&#9;if err := p.db.Where(&quot;id IN ?&quot;, productOptionIDs).Find(&amp;productOptions).Error; err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Failed to find product options by IDs:&quot;, productOptionIDs, &quot;Error:&quot;, err)&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;p.logger.Info(&quot;Found product options:&quot;, productOptions)&#10;&#9;return &amp;productOptions, nil&#10;}&#10;&#10;func (p *productRepository) CreateProduct(product *entity.Product) error {&#10;&#9;p.logger.Info(&quot;Creating product:&quot;, product)&#10;&#10;&#9;if err := p.db.Create(product).Error; err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Failed to create product:&quot;, product, &quot;Error:&quot;, err)&#10;&#10;&#9;&#9;// Check for specific database constraint violations&#10;&#9;&#9;errMsg := strings.ToLower(err.Error())&#10;&#10;&#9;&#9;// Check for duplicate slug constraint&#10;&#9;&#9;if strings.Contains(errMsg, &quot;duplicate&quot;) &amp;&amp; strings.Contains(errMsg, &quot;slug&quot;) {&#10;&#9;&#9;&#9;return errors.ErrProductAlreadyExists{Slug: product.Slug}&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// Check for duplicate name constraint&#10;&#9;&#9;if strings.Contains(errMsg, &quot;duplicate&quot;) &amp;&amp; strings.Contains(errMsg, &quot;name&quot;) {&#10;&#9;&#9;&#9;return errors.ErrProductAlreadyExists{Name: product.Name}&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// Check for foreign key violations&#10;&#9;&#9;if strings.Contains(errMsg, &quot;foreign key&quot;) {&#10;&#9;&#9;&#9;if strings.Contains(errMsg, &quot;category&quot;) {&#10;&#9;&#9;&#9;&#9;return errors.ErrCategoryNotFound{ID: product.CategoryID}&#10;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;if strings.Contains(errMsg, &quot;brand&quot;) {&#10;&#9;&#9;&#9;&#9;return errors.ErrBrandNotFound{ID: product.BrandID}&#10;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;if strings.Contains(errMsg, &quot;user&quot;) {&#10;&#9;&#9;&#9;&#9;return errors.ErrUserNotFound{ID: product.UserID}&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// Check for check constraint violations&#10;&#9;&#9;if strings.Contains(errMsg, &quot;check&quot;) || strings.Contains(errMsg, &quot;constraint&quot;) {&#10;&#9;&#9;&#9;if strings.Contains(errMsg, &quot;price&quot;) {&#10;&#9;&#9;&#9;&#9;return errors.ErrInvalidProductData{Field: &quot;price&quot;, Message: &quot;price must be greater than 0&quot;}&#10;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;if strings.Contains(errMsg, &quot;status&quot;) {&#10;&#9;&#9;&#9;&#9;return errors.ErrInvalidProductData{Field: &quot;status&quot;, Message: &quot;invalid status value&quot;}&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// Generic database transaction error&#10;&#9;&#9;return errors.ErrDatabaseTransaction{Operation: &quot;create product&quot;}&#10;&#9;}&#10;&#10;&#9;p.logger.Info(&quot;Product created successfully:&quot;, product.ID)&#10;&#9;return nil&#10;}&#10;&#10;func (p *productRepository) CreateProductAttributeInfo(productAttributeInfos *[]entity.ProductAttributeInfo) error {&#10;&#9;p.logger.Info(&quot;Creating product attribute infos:&quot;, productAttributeInfos)&#10;&#10;&#9;if err := p.db.Create(productAttributeInfos).Error; err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Failed to create product attribute infos:&quot;, productAttributeInfos, &quot;Error:&quot;, err)&#10;&#10;&#9;&#9;errMsg := strings.ToLower(err.Error())&#10;&#10;&#9;&#9;// Check for foreign key violations&#10;&#9;&#9;if strings.Contains(errMsg, &quot;foreign key&quot;) {&#10;&#9;&#9;&#9;if strings.Contains(errMsg, &quot;product_attribute&quot;) {&#10;&#9;&#9;&#9;&#9;return errors.ErrAttributeNotFound{ID: 0} // We'd need to parse which specific ID failed&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#10;&#9;&#9;return errors.ErrDatabaseTransaction{Operation: &quot;create product attribute info&quot;}&#10;&#9;}&#10;&#10;&#9;p.logger.Info(&quot;Product attribute infos created successfully&quot;)&#10;&#9;return nil&#10;}&#10;&#10;func (p *productRepository) CreateProductOptionInfo(productOptionInfos *[]entity.ProductOptionInfo) error {&#10;&#9;p.logger.Info(&quot;Creating product option infos:&quot;, productOptionInfos)&#10;&#10;&#9;if err := p.db.Create(productOptionInfos).Error; err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Failed to create product option infos:&quot;, productOptionInfos, &quot;Error:&quot;, err)&#10;&#10;&#9;&#9;errMsg := strings.ToLower(err.Error())&#10;&#10;&#9;&#9;// Check for foreign key violations&#10;&#9;&#9;if strings.Contains(errMsg, &quot;foreign key&quot;) {&#10;&#9;&#9;&#9;if strings.Contains(errMsg, &quot;product_option&quot;) {&#10;&#9;&#9;&#9;&#9;return errors.ErrOptionNotFound{ID: 0} // We'd need to parse which specific ID failed&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#10;&#9;&#9;return errors.ErrDatabaseTransaction{Operation: &quot;create product option info&quot;}&#10;&#9;}&#10;&#10;&#9;p.logger.Info(&quot;Product option infos created successfully&quot;)&#10;&#9;return nil&#10;}&#10;&#10;func (p *productRepository) CreateProductAttributeValuesIfNotExist(productAttributeValues *[]entity.ProductAttributeValue) error {&#10;&#9;p.logger.Info(&quot;Creating product attribute values&quot;)&#10;&#10;&#9;for _, value := range *productAttributeValues {&#10;&#9;&#9;if err := p.db.Where(&quot;value = ?&quot;, value.Value).FirstOrCreate(&amp;value).Error; err != nil {&#10;&#9;&#9;&#9;p.logger.Error(&quot;Failed to create or find product attribute value:&quot;, value, &quot;Error:&quot;, err)&#10;&#9;&#9;&#9;return err&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;p.logger.Info(&quot;Product attribute values created successfully&quot;)&#10;&#9;return nil&#10;}&#10;&#10;func (p *productRepository) CreateProductProductAttributeValues(i *[]entity.ProductProductAttributeValue) error {&#10;&#9;p.logger.Info(&quot;Creating product product attribute values:&quot;, i)&#10;&#10;&#9;if err := p.db.Create(i).Error; err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Failed to create product product attribute values:&quot;, i, &quot;Error:&quot;, err)&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;p.logger.Info(&quot;Product product attribute values created successfully&quot;)&#10;&#9;return nil&#10;}&#10;&#10;func (p *productRepository) CreateProductSKUs(productSKUs *[]entity.ProductSKU) error {&#10;&#9;p.logger.Info(&quot;Creating product SKUs:&quot;, productSKUs)&#10;&#10;&#9;if err := p.db.Create(productSKUs).Error; err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Failed to create product SKUs:&quot;, productSKUs, &quot;Error:&quot;, err)&#10;&#10;&#9;&#9;errMsg := strings.ToLower(err.Error())&#10;&#10;&#9;&#9;// Check for duplicate SKU constraint&#10;&#9;&#9;if strings.Contains(errMsg, &quot;duplicate&quot;) &amp;&amp; strings.Contains(errMsg, &quot;sku&quot;) {&#10;&#9;&#9;&#9;// Extract SKU from productSKUs if possible&#10;&#9;&#9;&#9;if len(*productSKUs) &gt; 0 {&#10;&#9;&#9;&#9;&#9;return errors.ErrSKUAlreadyExists{SKU: (*productSKUs)[0].SKU}&#10;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;return errors.ErrSKUAlreadyExists{SKU: &quot;unknown&quot;}&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// Check for invalid price&#10;&#9;&#9;if strings.Contains(errMsg, &quot;check&quot;) &amp;&amp; strings.Contains(errMsg, &quot;price&quot;) {&#10;&#9;&#9;&#9;return errors.ErrInvalidSKUData{SKU: &quot;unknown&quot;, Message: &quot;price must be greater than or equal to 0&quot;}&#10;&#9;&#9;}&#10;&#10;&#9;&#9;return errors.ErrDatabaseTransaction{Operation: &quot;create product SKUs&quot;}&#10;&#9;}&#10;&#10;&#9;p.logger.Info(&quot;Product SKUs created successfully&quot;)&#10;&#9;return nil&#10;}&#10;&#10;func (p *productRepository) CreateProductInventories(inventories *[]entity.ProductInventory) error {&#10;&#9;p.logger.Info(&quot;Creating product inventories:&quot;, inventories)&#10;&#10;&#9;if err := p.db.Create(inventories).Error; err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Failed to create product inventories:&quot;, inventories, &quot;Error:&quot;, err)&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;p.logger.Info(&quot;Product inventories created successfully&quot;)&#10;&#9;return nil&#10;}&#10;&#10;func (p *productRepository) CreateProductOptionCombinations(productOptionCombinations *[]entity.ProductOptionCombination) error {&#10;&#9;p.logger.Info(&quot;Creating product option combinations:&quot;, productOptionCombinations)&#10;&#10;&#9;if err := p.db.Create(productOptionCombinations).Error; err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Failed to create product option combinations:&quot;, productOptionCombinations, &quot;Error:&quot;, err)&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;p.logger.Info(&quot;Product option combinations created successfully&quot;)&#10;&#9;return nil&#10;}&#10;&#10;func (p *productRepository) CreateProductOptionValuesIfNotExist(productOptionValues *[]entity.ProductOptionValue) error {&#10;&#9;p.logger.Info(&quot;Creating product option values if not exist:&quot;, productOptionValues)&#10;&#10;&#9;for _, value := range *productOptionValues {&#10;&#9;&#9;if err := p.db.Where(&quot;value = ?&quot;, value.Value).FirstOrCreate(&amp;value).Error; err != nil {&#10;&#9;&#9;&#9;p.logger.Error(&quot;Failed to create or find product option value:&quot;, value, &quot;Error:&quot;, err)&#10;&#9;&#9;&#9;return err&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;p.logger.Info(&quot;Product option values created or found successfully&quot;)&#10;&#9;return nil&#10;}&#10;&#10;func (p *productRepository) DeleteProduct(id int64) error {&#10;&#9;p.logger.Info(&quot;Deleting product with ID:&quot;, id)&#10;&#10;&#9;if err := p.db.Where(&quot;id = ?&quot;, id).Delete(&amp;entity.Product{}).Error; err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Failed to delete product with ID:&quot;, id, &quot;Error:&quot;, err)&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;p.logger.Info(&quot;Product deleted successfully:&quot;, id)&#10;&#9;return nil&#10;}&#10;" />
              <option name="updatedContent" value="package postgres&#10;&#10;import (&#10;&#9;&quot;errors&quot;&#10;&#9;&quot;strings&quot;&#10;&#10;&#9;&quot;github.com/hthinh24/go-store/internal/pkg/logger&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/services/product&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/services/product/internal/dto/repository&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/services/product/internal/entity&quot;&#10;&#9;productErrors &quot;github.com/hthinh24/go-store/services/product/internal/errors&quot;&#10;&#9;&quot;gorm.io/gorm&quot;&#10;)&#10;&#10;type productRepository struct {&#10;&#9;logger        logger.Logger&#10;&#9;db            *gorm.DB&#10;&#9;isTransaction bool&#10;}&#10;&#10;func NewProductRepository(logger logger.Logger, db *gorm.DB) *productRepository {&#10;&#9;return &amp;productRepository{&#10;&#9;&#9;logger:        logger,&#10;&#9;&#9;db:            db,&#10;&#9;&#9;isTransaction: false,&#10;&#9;}&#10;}&#10;&#10;// Transaction methods&#10;func (p *productRepository) WithTransaction() (product.ProductRepository, error) {&#10;&#9;if p.isTransaction {&#10;&#9;&#9;return nil, errors.New(&quot;repository is already in transaction mode&quot;)&#10;&#9;}&#10;&#10;&#9;p.logger.Info(&quot;Creating transactional repository&quot;)&#10;&#10;&#9;tx := p.db.Begin()&#10;&#9;if tx.Error != nil {&#10;&#9;&#9;p.logger.Error(&quot;Failed to begin transaction:&quot;, tx.Error)&#10;&#9;&#9;return nil, tx.Error&#10;&#9;}&#10;&#10;&#9;return &amp;productRepository{&#10;&#9;&#9;logger:        p.logger,&#10;&#9;&#9;db:            tx,&#10;&#9;&#9;isTransaction: true,&#10;&#9;}, nil&#10;}&#10;&#10;func (p *productRepository) Commit() error {&#10;&#9;if !p.isTransaction {&#10;&#9;&#9;return errors.New(&quot;repository is not in transaction mode&quot;)&#10;&#9;}&#10;&#10;&#9;p.logger.Info(&quot;Committing transaction&quot;)&#10;&#10;&#9;if err := p.db.Commit().Error; err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Failed to commit transaction:&quot;, err)&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;p.logger.Info(&quot;Transaction committed successfully&quot;)&#10;&#9;return nil&#10;}&#10;&#10;func (p *productRepository) Rollback() error {&#10;&#9;if !p.isTransaction {&#10;&#9;&#9;return errors.New(&quot;repository is not in transaction mode&quot;)&#10;&#9;}&#10;&#10;&#9;p.logger.Info(&quot;Rolling back transaction&quot;)&#10;&#10;&#9;if err := p.db.Rollback().Error; err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Failed to rollback transaction:&quot;, err)&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;p.logger.Info(&quot;Transaction rolled back successfully&quot;)&#10;&#9;return nil&#10;}&#10;&#10;func (p *productRepository) IsInTransaction() bool {&#10;&#9;return p.isTransaction&#10;}&#10;&#10;func (p *productRepository) FindProductByID(id int64) (*entity.Product, error) {&#10;&#9;p.logger.Info(&quot;Finding product by ID:&quot;, id)&#10;&#10;&#9;var product entity.Product&#10;&#9;if err := p.db.Where(&quot;id = ?&quot;, id).First(&amp;product).Error; err != nil {&#10;&#9;&#9;return nil, productErrors.ErrProductNotFound{}&#10;&#9;}&#10;&#10;&#9;return &amp;product, nil&#10;}&#10;&#10;func (p *productRepository) FindProductAttributesInfoByProductID(productID int64) (*[]entity.ProductAttributeInfo, error) {&#10;&#9;p.logger.Info(&quot;Finding product attributes info by product ID:&quot;, productID)&#10;&#10;&#9;var productAttributesInfo []entity.ProductAttributeInfo&#10;&#9;if err := p.db.Where(&quot;product_id = ?&quot;, productID).Find(&amp;productAttributesInfo).Error; err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Failed to find product attributes info by product ID:&quot;, productID, &quot;Error:&quot;, err)&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;p.logger.Info(&quot;Found product attributes info:&quot;, productAttributesInfo)&#10;&#9;return &amp;productAttributesInfo, nil&#10;}&#10;&#10;func (p *productRepository) FindProductOptionsInfoByProductID(productID int64) (*[]entity.ProductOptionInfo, error) {&#10;&#9;p.logger.Info(&quot;Finding product options info by product ID:&quot;, productID)&#10;&#10;&#9;var productOptionsInfo []entity.ProductOptionInfo&#10;&#9;if err := p.db.Where(&quot;product_id = ?&quot;, productID).Find(&amp;productOptionsInfo).Error; err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Failed to find product options info by product ID:&quot;, productID, &quot;Error:&quot;, err)&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;p.logger.Info(&quot;Found product options info:&quot;, productOptionsInfo)&#10;&#9;return &amp;productOptionsInfo, nil&#10;}&#10;&#10;func (p *productRepository) FindProductSKUsByProductID(id int64) (*[]repository.ProductSKUDetail, error) {&#10;&#9;p.logger.Info(&quot;Finding product SKUs by product ID:&quot;, id)&#10;&#10;&#9;var productSKUsWithInventory []repository.ProductSKUDetail&#10;&#9;if err := p.db.&#10;&#9;&#9;Table(entity.ProductSKU{}.TableName()+&quot; AS ps&quot;).&#10;&#9;&#9;Select(&quot;ps.id, ps.sku, ps.sku_signature, ps.extra_price,&quot;+&#10;&#9;&#9;&#9;&quot;ps.sale_type&quot;, &quot;ps.sale_value&quot;, &quot;ps.sale_start_date&quot;, &quot;ps.sale_end_date&quot;).&#10;&#9;&#9;Joins(&quot;JOIN product_inventory AS pi ON ps.id = pi.product_sku_id&quot;).&#10;&#9;&#9;Where(&quot;ps.product_id = ?&quot;, id).&#10;&#9;&#9;Find(&amp;productSKUsWithInventory).Error; err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Failed to find product SKUs by product ID:&quot;, id, &quot;Error:&quot;, err)&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;return &amp;productSKUsWithInventory, nil&#10;}&#10;&#10;func (p *productRepository) FindProductAttributesByIDs(productAttributeIDs []int64) (*[]entity.ProductAttribute, error) {&#10;&#9;p.logger.Info(&quot;Finding product attributes by IDs:&quot;, productAttributeIDs)&#10;&#10;&#9;var productAttributes []entity.ProductAttribute&#10;&#9;if err := p.db.Where(&quot;id IN ?&quot;, productAttributeIDs).Find(&amp;productAttributes).Error; err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Failed to find product attributes by IDs:&quot;, productAttributeIDs, &quot;Error:&quot;, err)&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;p.logger.Info(&quot;Found product attributes:&quot;, productAttributes)&#10;&#9;return &amp;productAttributes, nil&#10;}&#10;&#10;func (p *productRepository) FindProductOptionsByIDs(productOptionIDs []int64) (*[]entity.ProductOption, error) {&#10;&#9;p.logger.Info(&quot;Finding product options by IDs:&quot;, productOptionIDs)&#10;&#10;&#9;var productOptions []entity.ProductOption&#10;&#9;if err := p.db.Where(&quot;id IN ?&quot;, productOptionIDs).Find(&amp;productOptions).Error; err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Failed to find product options by IDs:&quot;, productOptionIDs, &quot;Error:&quot;, err)&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;p.logger.Info(&quot;Found product options:&quot;, productOptions)&#10;&#9;return &amp;productOptions, nil&#10;}&#10;&#10;func (p *productRepository) CreateProduct(product *entity.Product) error {&#10;&#9;p.logger.Info(&quot;Creating product:&quot;, product)&#10;&#10;&#9;if err := p.db.Create(product).Error; err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Failed to create product:&quot;, product, &quot;Error:&quot;, err)&#10;&#10;&#9;&#9;// Check for specific database constraint violations&#10;&#9;&#9;errMsg := strings.ToLower(err.Error())&#10;&#10;&#9;&#9;// Check for duplicate slug constraint&#10;&#9;&#9;if strings.Contains(errMsg, &quot;duplicate&quot;) &amp;&amp; strings.Contains(errMsg, &quot;slug&quot;) {&#10;&#9;&#9;&#9;return productErrors.ErrProductAlreadyExists{Slug: product.Slug}&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// Check for duplicate name constraint&#10;&#9;&#9;if strings.Contains(errMsg, &quot;duplicate&quot;) &amp;&amp; strings.Contains(errMsg, &quot;name&quot;) {&#10;&#9;&#9;&#9;return productErrors.ErrProductAlreadyExists{Name: product.Name}&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// Check for foreign key violations&#10;&#9;&#9;if strings.Contains(errMsg, &quot;foreign key&quot;) {&#10;&#9;&#9;&#9;if strings.Contains(errMsg, &quot;category&quot;) {&#10;&#9;&#9;&#9;&#9;return productErrors.ErrCategoryNotFound{ID: product.CategoryID}&#10;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;if strings.Contains(errMsg, &quot;brand&quot;) {&#10;&#9;&#9;&#9;&#9;return productErrors.ErrBrandNotFound{ID: product.BrandID}&#10;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;if strings.Contains(errMsg, &quot;user&quot;) {&#10;&#9;&#9;&#9;&#9;return productErrors.ErrUserNotFound{ID: product.UserID}&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// Check for check constraint violations&#10;&#9;&#9;if strings.Contains(errMsg, &quot;check&quot;) || strings.Contains(errMsg, &quot;constraint&quot;) {&#10;&#9;&#9;&#9;if strings.Contains(errMsg, &quot;price&quot;) {&#10;&#9;&#9;&#9;&#9;return productErrors.ErrInvalidProductData{Field: &quot;price&quot;, Message: &quot;price must be greater than 0&quot;}&#10;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;if strings.Contains(errMsg, &quot;status&quot;) {&#10;&#9;&#9;&#9;&#9;return productErrors.ErrInvalidProductData{Field: &quot;status&quot;, Message: &quot;invalid status value&quot;}&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// Generic database transaction error&#10;&#9;&#9;return productErrors.ErrDatabaseTransaction{Operation: &quot;create product&quot;}&#10;&#9;}&#10;&#10;&#9;p.logger.Info(&quot;Product created successfully:&quot;, product.ID)&#10;&#9;return nil&#10;}&#10;&#10;func (p *productRepository) CreateProductAttributeInfo(productAttributeInfos *[]entity.ProductAttributeInfo) error {&#10;&#9;p.logger.Info(&quot;Creating product attribute infos:&quot;, productAttributeInfos)&#10;&#10;&#9;if err := p.db.Create(productAttributeInfos).Error; err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Failed to create product attribute infos:&quot;, productAttributeInfos, &quot;Error:&quot;, err)&#10;&#10;&#9;&#9;errMsg := strings.ToLower(err.Error())&#10;&#10;&#9;&#9;// Check for foreign key violations&#10;&#9;&#9;if strings.Contains(errMsg, &quot;foreign key&quot;) {&#10;&#9;&#9;&#9;if strings.Contains(errMsg, &quot;product_attribute&quot;) {&#10;&#9;&#9;&#9;&#9;return productErrors.ErrAttributeNotFound{ID: 0} // We'd need to parse which specific ID failed&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#10;&#9;&#9;return productErrors.ErrDatabaseTransaction{Operation: &quot;create product attribute info&quot;}&#10;&#9;}&#10;&#10;&#9;p.logger.Info(&quot;Product attribute infos created successfully&quot;)&#10;&#9;return nil&#10;}&#10;&#10;func (p *productRepository) CreateProductOptionInfo(productOptionInfos *[]entity.ProductOptionInfo) error {&#10;&#9;p.logger.Info(&quot;Creating product option infos:&quot;, productOptionInfos)&#10;&#10;&#9;if err := p.db.Create(productOptionInfos).Error; err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Failed to create product option infos:&quot;, productOptionInfos, &quot;Error:&quot;, err)&#10;&#10;&#9;&#9;errMsg := strings.ToLower(err.Error())&#10;&#10;&#9;&#9;// Check for foreign key violations&#10;&#9;&#9;if strings.Contains(errMsg, &quot;foreign key&quot;) {&#10;&#9;&#9;&#9;if strings.Contains(errMsg, &quot;product_option&quot;) {&#10;&#9;&#9;&#9;&#9;return productErrors.ErrOptionNotFound{ID: 0} // We'd need to parse which specific ID failed&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#10;&#9;&#9;return productErrors.ErrDatabaseTransaction{Operation: &quot;create product option info&quot;}&#10;&#9;}&#10;&#10;&#9;p.logger.Info(&quot;Product option infos created successfully&quot;)&#10;&#9;return nil&#10;}&#10;&#10;func (p *productRepository) CreateProductAttributeValuesIfNotExist(productAttributeValues *[]entity.ProductAttributeValue) error {&#10;&#9;p.logger.Info(&quot;Creating product attribute values&quot;)&#10;&#10;&#9;for _, value := range *productAttributeValues {&#10;&#9;&#9;if err := p.db.Where(&quot;value = ?&quot;, value.Value).FirstOrCreate(&amp;value).Error; err != nil {&#10;&#9;&#9;&#9;p.logger.Error(&quot;Failed to create or find product attribute value:&quot;, value, &quot;Error:&quot;, err)&#10;&#9;&#9;&#9;return err&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;p.logger.Info(&quot;Product attribute values created successfully&quot;)&#10;&#9;return nil&#10;}&#10;&#10;func (p *productRepository) CreateProductProductAttributeValues(i *[]entity.ProductProductAttributeValue) error {&#10;&#9;p.logger.Info(&quot;Creating product product attribute values:&quot;, i)&#10;&#10;&#9;if err := p.db.Create(i).Error; err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Failed to create product product attribute values:&quot;, i, &quot;Error:&quot;, err)&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;p.logger.Info(&quot;Product product attribute values created successfully&quot;)&#10;&#9;return nil&#10;}&#10;&#10;func (p *productRepository) CreateProductSKUs(productSKUs *[]entity.ProductSKU) error {&#10;&#9;p.logger.Info(&quot;Creating product SKUs:&quot;, productSKUs)&#10;&#10;&#9;if err := p.db.Create(productSKUs).Error; err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Failed to create product SKUs:&quot;, productSKUs, &quot;Error:&quot;, err)&#10;&#10;&#9;&#9;errMsg := strings.ToLower(err.Error())&#10;&#10;&#9;&#9;// Check for duplicate SKU constraint&#10;&#9;&#9;if strings.Contains(errMsg, &quot;duplicate&quot;) &amp;&amp; strings.Contains(errMsg, &quot;sku&quot;) {&#10;&#9;&#9;&#9;// Extract SKU from productSKUs if possible&#10;&#9;&#9;&#9;if len(*productSKUs) &gt; 0 {&#10;&#9;&#9;&#9;&#9;return productErrors.ErrSKUAlreadyExists{SKU: (*productSKUs)[0].SKU}&#10;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;return productErrors.ErrSKUAlreadyExists{SKU: &quot;unknown&quot;}&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// Check for invalid price&#10;&#9;&#9;if strings.Contains(errMsg, &quot;check&quot;) &amp;&amp; strings.Contains(errMsg, &quot;price&quot;) {&#10;&#9;&#9;&#9;return productErrors.ErrInvalidSKUData{SKU: &quot;unknown&quot;, Message: &quot;price must be greater than or equal to 0&quot;}&#10;&#9;&#9;}&#10;&#10;&#9;&#9;return productErrors.ErrDatabaseTransaction{Operation: &quot;create product SKUs&quot;}&#10;&#9;}&#10;&#10;&#9;p.logger.Info(&quot;Product SKUs created successfully&quot;)&#10;&#9;return nil&#10;}&#10;&#10;func (p *productRepository) CreateProductInventories(inventories *[]entity.ProductInventory) error {&#10;&#9;p.logger.Info(&quot;Creating product inventories:&quot;, inventories)&#10;&#10;&#9;if err := p.db.Create(inventories).Error; err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Failed to create product inventories:&quot;, inventories, &quot;Error:&quot;, err)&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;p.logger.Info(&quot;Product inventories created successfully&quot;)&#10;&#9;return nil&#10;}&#10;&#10;func (p *productRepository) CreateProductOptionCombinations(productOptionCombinations *[]entity.ProductOptionCombination) error {&#10;&#9;p.logger.Info(&quot;Creating product option combinations:&quot;, productOptionCombinations)&#10;&#10;&#9;if err := p.db.Create(productOptionCombinations).Error; err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Failed to create product option combinations:&quot;, productOptionCombinations, &quot;Error:&quot;, err)&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;p.logger.Info(&quot;Product option combinations created successfully&quot;)&#10;&#9;return nil&#10;}&#10;&#10;func (p *productRepository) CreateProductOptionValuesIfNotExist(productOptionValues *[]entity.ProductOptionValue) error {&#10;&#9;p.logger.Info(&quot;Creating product option values if not exist:&quot;, productOptionValues)&#10;&#10;&#9;for _, value := range *productOptionValues {&#10;&#9;&#9;if err := p.db.Where(&quot;value = ?&quot;, value.Value).FirstOrCreate(&amp;value).Error; err != nil {&#10;&#9;&#9;&#9;p.logger.Error(&quot;Failed to create or find product option value:&quot;, value, &quot;Error:&quot;, err)&#10;&#9;&#9;&#9;return err&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;p.logger.Info(&quot;Product option values created or found successfully&quot;)&#10;&#9;return nil&#10;}&#10;&#10;func (p *productRepository) DeleteProduct(id int64) error {&#10;&#9;p.logger.Info(&quot;Deleting product with ID:&quot;, id)&#10;&#10;&#9;if err := p.db.Where(&quot;id = ?&quot;, id).Delete(&amp;entity.Product{}).Error; err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Failed to delete product with ID:&quot;, id, &quot;Error:&quot;, err)&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;p.logger.Info(&quot;Product deleted successfully:&quot;, id)&#10;&#9;return nil&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/internal/services/product/internal/service/product_service.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/internal/services/product/internal/service/product_service.go" />
              <option name="originalContent" value="package service&#10;&#10;import (&#10;&#9;&quot;github.com/hthinh24/go-store/internal/pkg/logger&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/services/product&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/services/product/internal/constants&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/services/product/internal/dto/repository&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/services/product/internal/dto/request&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/services/product/internal/dto/response&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/services/product/internal/entity&quot;&#10;&#9;&quot;strings&quot;&#10;)&#10;&#10;type productService struct {&#10;&#9;logger            logger.Logger&#10;&#9;productRepository product.ProductRepository&#10;}&#10;&#10;// NewProductService creates a new instance of ProductService&#10;func NewProductService(logger logger.Logger, productRepository product.ProductRepository) product.ProductService {&#10;&#9;return &amp;productService{&#10;&#9;&#9;logger:            logger,&#10;&#9;&#9;productRepository: productRepository,&#10;&#9;}&#10;}&#10;&#10;func (p *productService) GetProductByID(id int64) (*response.ProductResponse, error) {&#10;&#9;p.logger.Info(&quot;Get product with ID: &quot;, id)&#10;&#10;&#9;productEntity, err := p.productRepository.FindProductByID(id)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;p.logger.Info(&quot;Product retrieved successfully, ID: &quot;, productEntity.ID)&#10;&#9;return p.createProductResponse(productEntity), nil&#10;}&#10;&#10;func (p *productService) GetProductDetailByID(id int64) (*response.ProductDetailResponse, error) {&#10;&#9;p.logger.Info(&quot;Get product with ID: &quot;, id)&#10;&#10;&#9;productEntity, err := p.productRepository.FindProductByID(id)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;p.logger.Info(&quot;Product retrieved successfully, ID: &quot;, productEntity.ID)&#10;&#9;return p.createProductDetailResponse(productEntity), nil&#10;}&#10;&#10;func (p *productService) CreateProduct(data *request.CreateProductRequest) (*response.ProductDetailResponse, error) {&#10;&#9;p.logger.Info(&quot;Creating product with name&quot;, data.Name)&#10;&#10;&#9;// Create Product Entity from request data&#10;&#9;productEntity := p.createProductEntity(data)&#10;&#10;&#9;// Begin a transaction&#10;&#9;if err := p.productRepository.BeginTx(); err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;// 1. Create &amp; Insert the base product entity&#10;&#9;if err := p.processCreateProduct(productEntity); err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;// 2. Create &amp; Insert product attribute info&#10;&#9;if err := p.processCreateProductAttributeInfo(productEntity.ID, data.ProductAttributes); err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;// 3. Create &amp; Insert product option info&#10;&#9;if err := p.processCreateProductOptionInfo(productEntity.ID, data.OptionValues); err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;// 4. Create &amp; Insert product attribute values&#10;&#9;if err := p.processCreateProductAttributes(data.ProductAttributes); err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;// 5. Create &amp; Insert product SKUs&#10;&#9;if err := p.processCreateProductSKUs(productEntity.ID, productEntity.Name, &amp;data.ProductSKUs); err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;// 6. Create &amp; Insert product option combinations&#10;&#9;if err := p.processCreateProductOptionCombinations(productEntity.ID, data.OptionValues); err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;// Commit the transaction&#10;&#9;if err := p.productRepository.CommitTx(); err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Error committing transaction, rolling back&quot;, err)&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;p.logger.Info(&quot;Product created successfully, ID: &quot;, productEntity.ID)&#10;&#9;return p.createProductDetailResponse(productEntity), nil&#10;}&#10;&#10;func (p *productService) DeleteProduct(id int64) error {&#10;&#9;p.logger.Info(&quot;Deleting product with ID: &quot;, id)&#10;&#10;&#9;err := p.productRepository.DeleteProduct(id)&#10;&#9;if err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Error deleting product&quot;, err)&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;p.logger.Info(&quot;Product deleted successfully, ID: &quot;, id)&#10;&#9;return nil&#10;}&#10;&#10;func (p *productService) processCreateProduct(product *entity.Product) error {&#10;&#9;if err := p.productRepository.CreateProduct(product); err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Error saving product to repository, error: &quot;, err)&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;return nil&#10;}&#10;&#10;func (p *productService) processCreateProductAttributeInfo(productID int64, attributeMap map[int64][]string) error {&#10;&#9;var attributeIDs []int64&#10;&#9;var productAttributeInfoEntities []entity.ProductAttributeInfo&#10;&#9;for attributeID, _ := range attributeMap {&#10;&#9;&#9;attributeIDs = append(attributeIDs, attributeID)&#10;&#9;}&#10;&#10;&#9;// 1. Find product attributes by IDs&#10;&#9;productAttributes, err := p.productRepository.FindProductAttributesByIDs(attributeIDs)&#10;&#9;if err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Error finding product attributes by IDs, error: &quot;, err)&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;// 2. Create product attribute info entities from the attribute map&#10;&#9;for _, attribute := range *productAttributes {&#10;&#9;&#9;if values, ok := attributeMap[attribute.ID]; ok {&#10;&#9;&#9;&#9;for _, value := range values {&#10;&#9;&#9;&#9;&#9;productAttributeInfoEntity := p.createProductAttributeInfoEntity(productID, attribute.Name, value)&#10;&#9;&#9;&#9;&#9;productAttributeInfoEntities = append(productAttributeInfoEntities, *productAttributeInfoEntity)&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;// 3. Save product attribute info entities to the repository&#10;&#9;if err := p.productRepository.CreateProductAttributeInfo(&amp;productAttributeInfoEntities); err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Error saving product attribute info to repository, error: &quot;, err)&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;return nil&#10;}&#10;&#10;func (p *productService) processCreateProductOptionInfo(productID int64, optionMap map[int64][]string) error {&#10;&#9;var productOptionIDs []int64&#10;&#9;var productOptionInfoEntities []entity.ProductOptionInfo&#10;&#10;&#9;for productOptionID, _ := range optionMap {&#10;&#9;&#9;productOptionIDs = append(productOptionIDs, productOptionID)&#10;&#9;}&#10;&#10;&#9;// 1. Find product options by IDs&#10;&#9;productOptions, err := p.productRepository.FindProductOptionsByIDs(productOptionIDs)&#10;&#9;if err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Error finding product options by IDs, error: &quot;, err)&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;// 2. Create product option info entities from the option map&#10;&#9;for _, option := range *productOptions {&#10;&#9;&#9;if values, ok := optionMap[option.ID]; ok {&#10;&#9;&#9;&#9;for _, value := range values {&#10;&#9;&#9;&#9;&#9;productOptionInfoEntity := p.createProductOptionInfoEntity(productID, option.Name, value)&#10;&#9;&#9;&#9;&#9;productOptionInfoEntities = append(productOptionInfoEntities, *productOptionInfoEntity)&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;// 3. Save product option info entities to the repository&#10;&#9;if err := p.productRepository.CreateProductOptionInfo(&amp;productOptionInfoEntities); err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Error saving product option info to repository, error: &quot;, err)&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;return nil&#10;}&#10;&#10;func (p *productService) processCreateProductAttributes(attributeValues map[int64][]string) error {&#10;&#9;// 1. Create product attribute values entities from the attribute values map&#10;&#9;var productAttributeValueEntities []entity.ProductAttributeValue&#10;&#9;for attributeID, values := range attributeValues {&#10;&#9;&#9;for _, value := range values {&#10;&#9;&#9;&#9;productAttributeValueEntity := p.createProductAttributeValueEntity(attributeID, value)&#10;&#9;&#9;&#9;productAttributeValueEntities = append(productAttributeValueEntities, *productAttributeValueEntity)&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;// 2. Save product attribute values to the repository&#10;&#9;err := p.productRepository.CreateProductAttributeValuesIfNotExist(&amp;productAttributeValueEntities)&#10;&#9;if err != nil {&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;return nil&#10;}&#10;&#10;func (p *productService) processCreateProductSKUs(productID int64,&#10;&#9;productName string,&#10;&#9;productSKUData *[]request.CreateProductSKURequest) error {&#10;&#9;// 1. Create product SKU entities from the product SKU data&#10;&#9;var productSKUEntities []entity.ProductSKU&#10;&#9;for _, sku := range *productSKUData {&#10;&#9;&#9;productSKUEntity := p.createProductSKUEntity(productID, productName, &amp;sku)&#10;&#9;&#9;productSKUEntities = append(productSKUEntities, *productSKUEntity)&#10;&#9;}&#10;&#10;&#9;// 2. Save product SKUs to the repository&#10;&#9;if err := p.productRepository.CreateProductSKUs(&amp;productSKUEntities); err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Error saving product SKUs to repository, error: &quot;, err)&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;// 3. Create product inventory entities based on product SKUs and stock data&#10;&#9;var productInventoryEntities []entity.ProductInventory&#10;&#9;for i, productSKUEntity := range productSKUEntities {&#10;&#9;&#9;productInventory := p.createProductInventoryEntity(&amp;productSKUEntity, (*productSKUData)[i].Stock)&#10;&#9;&#9;productInventoryEntities = append(productInventoryEntities, *productInventory)&#10;&#9;}&#10;&#10;&#9;// 4. Save product inventory entities to repository&#10;&#9;if err := p.productRepository.CreateProductInventories(&amp;productInventoryEntities); err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Error saving product inventory to repository, error: &quot;, err)&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;return nil&#10;}&#10;&#10;func (p *productService) processCreateProductOptionCombinations(id int64, optionValues map[int64][]string) error {&#10;&#9;var productOptionCombinationEntities []entity.ProductOptionCombination&#10;&#10;&#9;// 1. Create product option combination entities from the option values map&#10;&#9;displayOrder := int32(1)&#10;&#9;for option, _ := range optionValues {&#10;&#9;&#9;productOptionCombinationEntity := p.createProductOptionCombinationEntity(id, option, int32(displayOrder))&#10;&#9;&#9;productOptionCombinationEntities = append(productOptionCombinationEntities, *productOptionCombinationEntity)&#10;&#9;&#9;displayOrder++&#10;&#9;}&#10;&#9;// 2. Save product option combinations to the repository&#10;&#9;if err := p.productRepository.CreateProductOptionCombinations(&amp;productOptionCombinationEntities); err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Error saving product option combinations to repository, error: &quot;, err)&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;// 3. Create product option value entities from the option values map&#10;&#9;var productOptionValueEntities []entity.ProductOptionValue&#10;&#9;for optionID, values := range optionValues {&#10;&#9;&#9;for _, value := range values {&#10;&#9;&#9;&#9;productOptionValueEntity := p.createProductOptionValueEntity(optionID, value)&#10;&#9;&#9;&#9;productOptionValueEntities = append(productOptionValueEntities, *productOptionValueEntity)&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;// 4. Create product option values in the repository if they do not already exist&#10;&#9;if err := p.productRepository.CreateProductOptionValuesIfNotExist(&amp;productOptionValueEntities); err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Error saving product option values to repository, error: &quot;, err)&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;return nil&#10;}&#10;&#10;func (p *productService) createProductEntity(data *request.CreateProductRequest) *entity.Product {&#10;&#9;return &amp;entity.Product{&#10;&#9;&#9;Name:             data.Name,&#10;&#9;&#9;Description:      data.Description,&#10;&#9;&#9;ShortDescription: data.ShortDescription,&#10;&#9;&#9;ImageURL:         data.ImageURL,&#10;&#9;&#9;Slug:             data.Slug,&#10;&#9;&#9;BasePrice:        data.BasePrice,&#10;&#9;&#9;SalePrice:        data.SalePrice,&#10;&#9;&#9;IsFeatured:       data.IsFeatured,&#10;&#9;&#9;SaleStartDate:    data.SaleStartDate,&#10;&#9;&#9;SaleEndDate:      data.SaleEndDate,&#10;&#9;&#9;Status:           data.Status,&#10;&#9;&#9;BrandID:          data.BrandID,&#10;&#9;&#9;CategoryID:       data.CategoryID,&#10;&#9;&#9;UserID:           data.UserID,&#10;&#9;}&#10;}&#10;&#10;func (p *productService) createProductAttributeInfoEntity(productID int64, attributeName string, attributeValue string) *entity.ProductAttributeInfo {&#10;&#9;return &amp;entity.ProductAttributeInfo{&#10;&#9;&#9;AttributeName:  attributeName,&#10;&#9;&#9;AttributeValue: attributeValue,&#10;&#9;&#9;ProductID:      productID,&#10;&#9;}&#10;}&#10;&#10;func (p *productService) createProductOptionInfoEntity(productID int64, optionName string, optionValue string) *entity.ProductOptionInfo {&#10;&#9;return &amp;entity.ProductOptionInfo{&#10;&#9;&#9;OptionName:  optionName,&#10;&#9;&#9;OptionValue: optionValue,&#10;&#9;&#9;ProductID:   productID,&#10;&#9;}&#10;}&#10;&#10;func (p *productService) createProductAttributeValueEntity(productAttributeID int64, value string) *entity.ProductAttributeValue {&#10;&#9;return &amp;entity.ProductAttributeValue{&#10;&#9;&#9;ProductAttributeID: productAttributeID,&#10;&#9;&#9;Value:              value,&#10;&#9;}&#10;}&#10;&#10;func (p *productService) createProductSKUEntity(productID int64, productName string, data *request.CreateProductSKURequest) *entity.ProductSKU {&#10;&#9;return &amp;entity.ProductSKU{&#10;&#9;&#9;SKU:           data.SKU,&#10;&#9;&#9;SKUSignature:  p.generateSKUSignature(productName, data.SKU),&#10;&#9;&#9;ExtraPrice:    data.ExtraPrice,&#10;&#9;&#9;SaleType:      data.SaleType,&#10;&#9;&#9;SaleValue:     data.SaleValue,&#10;&#9;&#9;SaleStartDate: data.SaleStartDate,&#10;&#9;&#9;SaleEndDate:   data.SaleEndDate,&#10;&#9;&#9;Status:        string(constants.ProductStatusActive),&#10;&#9;&#9;ProductID:     productID,&#10;&#9;}&#10;}&#10;&#10;func (p *productService) createProductInventoryEntity(productSKU *entity.ProductSKU, stock int32) *entity.ProductInventory {&#10;&#9;return &amp;entity.ProductInventory{&#10;&#9;&#9;ProductID:      productSKU.ProductID,&#10;&#9;&#9;ProductSKUID:   productSKU.ID,&#10;&#9;&#9;AvailableStock: stock,&#10;&#9;&#9;ReservedStock:  0,&#10;&#9;&#9;DamagedStock:   0,&#10;&#9;}&#10;}&#10;&#10;func (p *productService) createProductOptionCombinationEntity(productID int64, productOptionID int64, displayOrder int32) *entity.ProductOptionCombination {&#10;&#9;return &amp;entity.ProductOptionCombination{&#10;&#9;&#9;ProductID:       productID,&#10;&#9;&#9;ProductOptionID: productOptionID,&#10;&#9;&#9;DisplayOrder:    displayOrder,&#10;&#9;}&#10;}&#10;&#10;func (p *productService) createProductOptionValueEntity(id int64, value string) *entity.ProductOptionValue {&#10;&#9;return &amp;entity.ProductOptionValue{&#10;&#9;&#9;ProductOptionID: id,&#10;&#9;&#9;Value:           value,&#10;&#9;}&#10;}&#10;&#10;func (p *productService) createProductResponse(product *entity.Product) *response.ProductResponse {&#10;&#9;return &amp;response.ProductResponse{&#10;&#9;&#9;ID:               product.ID,&#10;&#9;&#9;Name:             product.Name,&#10;&#9;&#9;ShortDescription: product.ShortDescription,&#10;&#9;&#9;ImageURL:         product.ImageURL,&#10;&#9;&#9;BasePrice:        product.BasePrice,&#10;&#9;&#9;SalePrice:        product.SalePrice,&#10;&#9;&#9;IsFeatured:       product.IsFeatured,&#10;&#9;&#9;SaleStartDate:    product.SaleStartDate,&#10;&#9;&#9;SaleEndDate:      product.SaleEndDate,&#10;&#9;&#9;Status:           product.Status,&#10;&#9;&#9;BrandID:          product.BrandID,&#10;&#9;&#9;CategoryID:       product.CategoryID,&#10;&#9;&#9;UserID:           product.UserID,&#10;&#9;}&#10;}&#10;&#10;func (p *productService) createProductDetailResponse(product *entity.Product) *response.ProductDetailResponse {&#10;&#9;// 1. Fetch product attributes and options&#10;&#9;productAttributes, err := p.productRepository.FindProductAttributesInfoByProductID(product.ID)&#10;&#9;if err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Error fetching product attributes for product ID&quot;, product.ID, &quot;Error:&quot;, err)&#10;&#9;&#9;return nil&#10;&#9;}&#10;&#9;productOptions, err := p.productRepository.FindProductOptionsInfoByProductID(product.ID)&#10;&#9;if err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Error fetching product options for product ID&quot;, product.ID, &quot;Error:&quot;, err)&#10;&#9;&#9;return nil&#10;&#9;}&#10;&#10;&#9;// 3. Fetch product SKUs&#10;&#9;productSKUWithInventories, err := p.productRepository.FindProductSKUsByProductID(product.ID)&#10;&#9;if productSKUWithInventories == nil {&#10;&#9;&#9;p.logger.Error(&quot;No product SKUs found for product ID&quot;, product.ID)&#10;&#9;&#9;return nil&#10;&#9;}&#10;&#10;&#9;// 2. Create response objects for attributes and options&#10;&#9;var attributeValues []*response.ProductWithAttributeValuesResponse&#10;&#9;var optionValues []*response.ProductWithOptionValuesResponse&#10;&#9;for _, attribute := range *productAttributes {&#10;&#9;&#9;attributeValues = append(attributeValues, p.createProductWithAttributeValuesResponse(&amp;attribute))&#10;&#9;}&#10;&#9;for _, option := range *productOptions {&#10;&#9;&#9;optionValues = append(optionValues, p.createProductWithOptionValuesResponse(&amp;option))&#10;&#9;}&#10;&#10;&#9;var productSKUResponses []*response.ProductSKUDetailResponse&#10;&#9;for _, sku := range *productSKUWithInventories {&#10;&#9;&#9;productSKUResponse := p.createProductSKUWithInventoryResponse(product.BasePrice, &amp;sku)&#10;&#9;&#9;productSKUResponses = append(productSKUResponses, productSKUResponse)&#10;&#9;}&#10;&#10;&#9;return &amp;response.ProductDetailResponse{&#10;&#9;&#9;ID:               product.ID,&#10;&#9;&#9;Name:             product.Name,&#10;&#9;&#9;Description:      product.Description,&#10;&#9;&#9;ShortDescription: product.ShortDescription,&#10;&#9;&#9;ImageURL:         product.ImageURL,&#10;&#9;&#9;Slug:             product.Slug,&#10;&#9;&#9;BasePrice:        product.BasePrice,&#10;&#9;&#9;SalePrice:        product.SalePrice,&#10;&#9;&#9;IsFeatured:       product.IsFeatured,&#10;&#9;&#9;SaleStartDate:    product.SaleStartDate,&#10;&#9;&#9;SaleEndDate:      product.SaleEndDate,&#10;&#9;&#9;Status:           product.Status,&#10;&#9;&#9;BrandID:          product.BrandID,&#10;&#9;&#9;CategoryID:       product.CategoryID,&#10;&#9;&#9;UserID:           product.UserID,&#10;&#9;&#9;Version:          product.Version,&#10;&#9;&#9;AttributeValues:  &amp;attributeValues,&#10;&#9;&#9;ProductSKUs:      &amp;productSKUResponses,&#10;&#9;&#9;OptionValues:     &amp;optionValues,&#10;&#9;}&#10;&#10;}&#10;&#10;func (p *productService) createProductWithAttributeValuesResponse(attribute *entity.ProductAttributeInfo) *response.ProductWithAttributeValuesResponse {&#10;&#9;return &amp;response.ProductWithAttributeValuesResponse{&#10;&#9;&#9;ID:              attribute.ID,&#10;&#9;&#9;AttributeName:   attribute.AttributeName,&#10;&#9;&#9;AttributeValues: attribute.AttributeValue,&#10;&#9;}&#10;}&#10;&#10;func (p *productService) createProductWithOptionValuesResponse(option *entity.ProductOptionInfo) *response.ProductWithOptionValuesResponse {&#10;&#9;return &amp;response.ProductWithOptionValuesResponse{&#10;&#9;&#9;ID:           option.ID,&#10;&#9;&#9;OptionNames:  option.OptionName,&#10;&#9;&#9;OptionValues: option.OptionValue,&#10;&#9;}&#10;}&#10;&#10;func (p *productService) createProductSKUWithInventoryResponse(&#10;&#9;productPrice float64,&#10;&#9;productSKUWithInventory *repository.ProductSKUDetail,&#10;) *response.ProductSKUDetailResponse {&#10;&#9;productSKUPrice := p.calculateProductSKUPrice(productPrice, productSKUWithInventory.ExtraPrice)&#10;&#9;return &amp;response.ProductSKUDetailResponse{&#10;&#9;&#9;ID:            productSKUWithInventory.ID,&#10;&#9;&#9;SKU:           productSKUWithInventory.SKU,&#10;&#9;&#9;SKUSignature:  productSKUWithInventory.SKUSignature,&#10;&#9;&#9;Price:         productSKUPrice,&#10;&#9;&#9;SalePrice:     p.calculateProductSKUSalePrice(productSKUPrice, productSKUWithInventory.SaleType, productSKUWithInventory.SaleValue),&#10;&#9;&#9;SaleStartDate: productSKUWithInventory.SaleStartDate,&#10;&#9;&#9;SaleEndDate:   productSKUWithInventory.SaleEndDate,&#10;&#9;&#9;Stock:         productSKUWithInventory.Stock,&#10;&#9;&#9;Status:        productSKUWithInventory.Status,&#10;&#9;&#9;ProductID:     productSKUWithInventory.ProductID,&#10;&#9;}&#10;}&#10;&#10;func (p *productService) generateSKUSignature(name string, sku string) string {&#10;&#9;skuSignature := strings.ToLower(name + &quot;-&quot; + sku)&#10;&#9;skuSignature = strings.ReplaceAll(sku, &quot; &quot;, &quot;-&quot;)&#10;&#10;&#9;return skuSignature&#10;}&#10;&#10;func (p *productService) calculateProductSKUPrice(productPrice float64, extraPrice float64) float64 {&#10;&#9;if extraPrice &lt; 0 {&#10;&#9;&#9;return productPrice&#10;&#9;}&#10;&#10;&#9;finalPrice := productPrice + productPrice*extraPrice&#10;&#9;return finalPrice&#10;}&#10;&#10;func (p *productService) calculateProductSKUSalePrice(productSKUPrice float64, saleType *string, saleValue *float64) *float64 {&#10;&#9;if saleType == nil || saleValue == nil {&#10;&#9;&#9;return nil&#10;&#9;}&#10;&#10;&#9;if *saleType == constants.SaleTypePercentage {&#10;&#9;&#9;// Calculate sale price as a percentage discount&#10;&#9;&#9;finalPrice := productSKUPrice - (productSKUPrice * *saleValue)&#10;&#9;&#9;return &amp;finalPrice&#10;&#9;} else if *saleType == constants.SaleTypeFixed {&#10;&#9;&#9;finalPrice := productSKUPrice - *saleValue&#10;&#9;&#9;if finalPrice &lt; 0 {&#10;&#9;&#9;&#9;finalPrice = 0&#10;&#9;&#9;}&#10;&#9;&#9;return &amp;finalPrice&#10;&#9;}&#10;&#10;&#9;return nil&#10;}&#10;&#10;// CreateProductWithoutSKU Help to create a product without SKU (for case app only have backend API)&#10;func (p *productService) CreateProductWithoutSKU(data *request.CreateProductWithoutSKURequest) (*response.ProductDetailResponse, error) {&#10;&#9;p.logger.Info(&quot;Creating product without SKU with name: &quot;, data.Name)&#10;&#10;&#9;// Generate all SKU combinations automatically from option values&#10;&#9;productSKUs, err := p.generateAllSKUCombinations(data.Name, data.OptionValues)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;// Create the full CreateProductRequest with generated SKUs&#10;&#9;createProductRequest := &amp;request.CreateProductRequest{&#10;&#9;&#9;Name:              data.Name,&#10;&#9;&#9;Description:       data.Description,&#10;&#9;&#9;ShortDescription:  data.ShortDescription,&#10;&#9;&#9;ImageURL:          data.ImageURL,&#10;&#9;&#9;Slug:              data.Slug,&#10;&#9;&#9;BasePrice:         data.BasePrice,&#10;&#9;&#9;SalePrice:         data.SalePrice,&#10;&#9;&#9;IsFeatured:        data.IsFeatured,&#10;&#9;&#9;SaleStartDate:     data.SaleStartDate,&#10;&#9;&#9;SaleEndDate:       data.SaleEndDate,&#10;&#9;&#9;Status:            string(constants.ProductStatusActive),&#10;&#9;&#9;BrandID:           data.BrandID,&#10;&#9;&#9;CategoryID:        data.CategoryID,&#10;&#9;&#9;UserID:            data.UserID,&#10;&#9;&#9;ProductAttributes: data.ProductAttributes,&#10;&#9;&#9;OptionValues:      data.OptionValues,&#10;&#9;&#9;ProductSKUs:       *productSKUs,&#10;&#9;}&#10;&#10;&#9;// Call the existing CreateProduct function&#10;&#9;return p.CreateProduct(createProductRequest)&#10;}&#10;&#10;// generateAllSKUCombinations generates all possible SKU combinations from option values&#10;func (p *productService) generateAllSKUCombinations(productName string, optionValues map[int64][]string) (*[]request.CreateProductSKURequest, error) {&#10;&#9;// Clean up option values - remove empty options&#10;&#9;cleanedOptions := make(map[int64][]string)&#10;&#9;optionIDs := make([]int64, 0)&#10;&#10;&#9;for optionID, values := range optionValues {&#10;&#9;&#9;if len(values) &gt; 0 {&#10;&#9;&#9;&#9;cleanedOptions[optionID] = values&#10;&#9;&#9;&#9;optionIDs = append(optionIDs, optionID)&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;// If no options, create a single default SKU&#10;&#9;if len(cleanedOptions) == 0 {&#10;&#9;&#9;defaultSKU := []request.CreateProductSKURequest{&#10;&#9;&#9;&#9;{&#10;&#9;&#9;&#9;&#9;SKU:        productName + &quot;_default&quot;,&#10;&#9;&#9;&#9;&#9;ExtraPrice: 0,&#10;&#9;&#9;&#9;&#9;Stock:      100,&#10;&#9;&#9;&#9;},&#10;&#9;&#9;}&#10;&#9;&#9;return &amp;defaultSKU, nil&#10;&#9;}&#10;&#10;&#9;// Generate all combinations using cartesian product&#10;&#9;combinations := p.generateCartesianProduct(cleanedOptions, optionIDs)&#10;&#10;&#9;// Create SKU requests from combinations&#10;&#9;var productSKUs []request.CreateProductSKURequest&#10;&#9;for _, combination := range combinations {&#10;&#9;&#9;sku := p.buildSKUFromCombination(productName, combination, optionIDs)&#10;&#9;&#9;price := constants.DefaultPrice&#10;&#9;&#9;stock := constants.DefaultStock&#10;&#10;&#9;&#9;productSKUs = append(productSKUs, request.CreateProductSKURequest{&#10;&#9;&#9;&#9;SKU:        sku,&#10;&#9;&#9;&#9;ExtraPrice: price,&#10;&#9;&#9;&#9;Stock:      int32(stock),&#10;&#9;&#9;})&#10;&#9;}&#10;&#10;&#9;return &amp;productSKUs, nil&#10;}&#10;&#10;// generateCartesianProduct generates all possible combinations of option values&#10;func (p *productService) generateCartesianProduct(optionValues map[int64][]string, optionIDs []int64) []map[int64]string {&#10;&#9;if len(optionIDs) == 0 {&#10;&#9;&#9;return []map[int64]string{}&#10;&#9;}&#10;&#10;&#9;// Start with the first option&#10;&#9;var result []map[int64]string&#10;&#9;firstOptionID := optionIDs[0]&#10;&#9;firstValues := optionValues[firstOptionID]&#10;&#10;&#9;for _, value := range firstValues {&#10;&#9;&#9;combination := make(map[int64]string)&#10;&#9;&#9;combination[firstOptionID] = value&#10;&#9;&#9;result = append(result, combination)&#10;&#9;}&#10;&#10;&#9;// Add remaining options one by one&#10;&#9;for i := 1; i &lt; len(optionIDs); i++ {&#10;&#9;&#9;optionID := optionIDs[i]&#10;&#9;&#9;values := optionValues[optionID]&#10;&#10;&#9;&#9;var newResult []map[int64]string&#10;&#9;&#9;for _, existingCombination := range result {&#10;&#9;&#9;&#9;for _, value := range values {&#10;&#9;&#9;&#9;&#9;newCombination := make(map[int64]string)&#10;&#9;&#9;&#9;&#9;// Copy existing combination&#10;&#9;&#9;&#9;&#9;for k, v := range existingCombination {&#10;&#9;&#9;&#9;&#9;&#9;newCombination[k] = v&#10;&#9;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;&#9;// Add new option value&#10;&#9;&#9;&#9;&#9;newCombination[optionID] = value&#10;&#9;&#9;&#9;&#9;newResult = append(newResult, newCombination)&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#9;&#9;result = newResult&#10;&#9;}&#10;&#10;&#9;return result&#10;}&#10;&#10;// buildSKUFromCombination builds SKU string from option combination&#10;func (p *productService) buildSKUFromCombination(productName string, combination map[int64]string, optionIDs []int64) string {&#10;&#9;skuParts := []string{productName}&#10;&#10;&#9;// Add option values in consistent order&#10;&#9;for _, optionID := range optionIDs {&#10;&#9;&#9;if value, exists := combination[optionID]; exists {&#10;&#9;&#9;&#9;// Clean up value for SKU (remove spaces, special chars)&#10;&#9;&#9;&#9;cleanValue := strings.ReplaceAll(value, &quot; &quot;, &quot;&quot;)&#10;&#9;&#9;&#9;skuParts = append(skuParts, cleanValue)&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;return strings.Join(skuParts, &quot;_&quot;)&#10;}&#10;" />
              <option name="updatedContent" value="package service&#10;&#10;import (&#10;&#9;&quot;github.com/hthinh24/go-store/internal/pkg/logger&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/services/product&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/services/product/internal/constants&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/services/product/internal/dto/repository&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/services/product/internal/dto/request&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/services/product/internal/dto/response&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/services/product/internal/entity&quot;&#10;&#9;&quot;strings&quot;&#10;)&#10;&#10;type productService struct {&#10;&#9;logger            logger.Logger&#10;&#9;productRepository product.ProductRepository&#10;}&#10;&#10;// NewProductService creates a new instance of ProductService&#10;func NewProductService(logger logger.Logger, productRepository product.ProductRepository) product.ProductService {&#10;&#9;return &amp;productService{&#10;&#9;&#9;logger:            logger,&#10;&#9;&#9;productRepository: productRepository,&#10;&#9;}&#10;}&#10;&#10;func (p *productService) GetProductByID(id int64) (*response.ProductResponse, error) {&#10;&#9;p.logger.Info(&quot;Get product with ID: &quot;, id)&#10;&#10;&#9;productEntity, err := p.productRepository.FindProductByID(id)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;p.logger.Info(&quot;Product retrieved successfully, ID: &quot;, productEntity.ID)&#10;&#9;return p.createProductResponse(productEntity), nil&#10;}&#10;&#10;func (p *productService) GetProductDetailByID(id int64) (*response.ProductDetailResponse, error) {&#10;&#9;p.logger.Info(&quot;Get product with ID: &quot;, id)&#10;&#10;&#9;productEntity, err := p.productRepository.FindProductByID(id)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;p.logger.Info(&quot;Product retrieved successfully, ID: &quot;, productEntity.ID)&#10;&#9;return p.createProductDetailResponse(productEntity), nil&#10;}&#10;&#10;func (p *productService) CreateProduct(data *request.CreateProductRequest) (*response.ProductDetailResponse, error) {&#10;&#9;p.logger.Info(&quot;Creating product with name&quot;, data.Name)&#10;&#10;&#9;// Create Product Entity from request data&#10;&#9;productEntity := p.createProductEntity(data)&#10;&#10;&#9;// Create transactional repository&#10;&#9;txRepo, err := p.productRepository.WithTransaction()&#10;&#9;if err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Failed to create transaction:&quot;, err)&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;// Ensure rollback on error or panic&#10;&#9;defer func() {&#10;&#9;&#9;if r := recover(); r != nil {&#10;&#9;&#9;&#9;txRepo.Rollback()&#10;&#9;&#9;&#9;panic(r)&#10;&#9;&#9;}&#10;&#9;}()&#10;&#10;&#9;// 1. Create &amp; Insert the base product entity&#10;&#9;if err := txRepo.CreateProduct(productEntity); err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Error creating product:&quot;, err)&#10;&#9;&#9;txRepo.Rollback()&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;// 2. Create &amp; Insert product attribute info&#10;&#9;if err := p.processCreateProductAttributeInfoWithTx(txRepo, productEntity.ID, data.ProductAttributes); err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Error creating product attribute info:&quot;, err)&#10;&#9;&#9;txRepo.Rollback()&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;// 3. Create &amp; Insert product option info&#10;&#9;if err := p.processCreateProductOptionInfoWithTx(txRepo, productEntity.ID, data.OptionValues); err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Error creating product option info:&quot;, err)&#10;&#9;&#9;txRepo.Rollback()&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;// 4. Create &amp; Insert product attribute values&#10;&#9;if err := p.processCreateProductAttributesWithTx(txRepo, data.ProductAttributes); err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Error creating product attributes:&quot;, err)&#10;&#9;&#9;txRepo.Rollback()&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;// 5. Create &amp; Insert product SKUs&#10;&#9;if err := p.processCreateProductSKUsWithTx(txRepo, productEntity.ID, productEntity.Name, &amp;data.ProductSKUs); err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Error creating product SKUs:&quot;, err)&#10;&#9;&#9;txRepo.Rollback()&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;// 6. Create &amp; Insert product option combinations&#10;&#9;if err := p.processCreateProductOptionCombinationsWithTx(txRepo, productEntity.ID, data.OptionValues); err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Error creating product option combinations:&quot;, err)&#10;&#9;&#9;txRepo.Rollback()&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;// Commit the transaction&#10;&#9;if err := txRepo.Commit(); err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Failed to commit transaction:&quot;, err)&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;p.logger.Info(&quot;Product created successfully, ID: &quot;, productEntity.ID)&#10;&#9;return p.createProductDetailResponse(productEntity), nil&#10;}&#10;&#10;// Transaction-aware helper methods&#10;func (p *productService) processCreateProductAttributeInfoWithTx(txRepo product.ProductRepository, productID int64, attributeMap map[int64][]string) error {&#10;&#9;var attributeIDs []int64&#10;&#9;var productAttributeInfoEntities []entity.ProductAttributeInfo&#10;&#9;&#10;&#9;for attributeID, _ := range attributeMap {&#10;&#9;&#9;attributeIDs = append(attributeIDs, attributeID)&#10;&#9;}&#10;&#10;&#9;// 1. Find product attributes by IDs&#10;&#9;productAttributes, err := txRepo.FindProductAttributesByIDs(attributeIDs)&#10;&#9;if err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Error finding product attributes by IDs, error: &quot;, err)&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;// 2. Create product attribute info entities from the attribute map&#10;&#9;for _, attribute := range *productAttributes {&#10;&#9;&#9;if values, ok := attributeMap[attribute.ID]; ok {&#10;&#9;&#9;&#9;for _, value := range values {&#10;&#9;&#9;&#9;&#9;productAttributeInfoEntity := p.createProductAttributeInfoEntity(productID, attribute.Name, value)&#10;&#9;&#9;&#9;&#9;productAttributeInfoEntities = append(productAttributeInfoEntities, *productAttributeInfoEntity)&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;// 3. Save product attribute info entities to the repository&#10;&#9;if err := txRepo.CreateProductAttributeInfo(&amp;productAttributeInfoEntities); err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Error saving product attribute info to repository, error: &quot;, err)&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;return nil&#10;}&#10;&#10;func (p *productService) processCreateProductOptionInfoWithTx(txRepo product.ProductRepository, productID int64, optionMap map[int64][]string) error {&#10;&#9;var productOptionIDs []int64&#10;&#9;var productOptionInfoEntities []entity.ProductOptionInfo&#10;&#10;&#9;for productOptionID, _ := range optionMap {&#10;&#9;&#9;productOptionIDs = append(productOptionIDs, productOptionID)&#10;&#9;}&#10;&#10;&#9;// 1. Find product options by IDs&#10;&#9;productOptions, err := txRepo.FindProductOptionsByIDs(productOptionIDs)&#10;&#9;if err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Error finding product options by IDs, error: &quot;, err)&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;// 2. Create product option info entities from the option map&#10;&#9;for _, option := range *productOptions {&#10;&#9;&#9;if values, ok := optionMap[option.ID]; ok {&#10;&#9;&#9;&#9;for _, value := range values {&#10;&#9;&#9;&#9;&#9;productOptionInfoEntity := p.createProductOptionInfoEntity(productID, option.Name, value)&#10;&#9;&#9;&#9;&#9;productOptionInfoEntities = append(productOptionInfoEntities, *productOptionInfoEntity)&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;// 3. Save product option info entities to the repository&#10;&#9;if err := txRepo.CreateProductOptionInfo(&amp;productOptionInfoEntities); err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Error saving product option info to repository, error: &quot;, err)&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;return nil&#10;}&#10;&#10;func (p *productService) processCreateProductAttributesWithTx(txRepo product.ProductRepository, attributeValues map[int64][]string) error {&#10;&#9;// 1. Create product attribute values entities from the attribute values map&#10;&#9;var productAttributeValueEntities []entity.ProductAttributeValue&#10;&#9;for attributeID, values := range attributeValues {&#10;&#9;&#9;for _, value := range values {&#10;&#9;&#9;&#9;productAttributeValueEntity := p.createProductAttributeValueEntity(attributeID, value)&#10;&#9;&#9;&#9;productAttributeValueEntities = append(productAttributeValueEntities, *productAttributeValueEntity)&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;// 2. Save product attribute values to the repository&#10;&#9;err := txRepo.CreateProductAttributeValuesIfNotExist(&amp;productAttributeValueEntities)&#10;&#9;if err != nil {&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;return nil&#10;}&#10;&#10;func (p *productService) processCreateProductSKUsWithTx(txRepo product.ProductRepository, productID int64, productName string, productSKUData *[]request.CreateProductSKURequest) error {&#10;&#9;// 1. Create product SKU entities from the product SKU data&#10;&#9;var productSKUEntities []entity.ProductSKU&#10;&#9;for _, sku := range *productSKUData {&#10;&#9;&#9;productSKUEntity := p.createProductSKUEntity(productID, productName, &amp;sku)&#10;&#9;&#9;productSKUEntities = append(productSKUEntities, *productSKUEntity)&#10;&#9;}&#10;&#10;&#9;// 2. Save product SKUs to the repository&#10;&#9;if err := txRepo.CreateProductSKUs(&amp;productSKUEntities); err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Error saving product SKUs to repository, error: &quot;, err)&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;// 3. Create product inventory entities based on product SKUs and stock data&#10;&#9;var productInventoryEntities []entity.ProductInventory&#10;&#9;for i, productSKUEntity := range productSKUEntities {&#10;&#9;&#9;productInventory := p.createProductInventoryEntity(&amp;productSKUEntity, (*productSKUData)[i].Stock)&#10;&#9;&#9;productInventoryEntities = append(productInventoryEntities, *productInventory)&#10;&#9;}&#10;&#10;&#9;// 4. Save product inventory entities to repository&#10;&#9;if err := txRepo.CreateProductInventories(&amp;productInventoryEntities); err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Error saving product inventory to repository, error: &quot;, err)&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;return nil&#10;}&#10;&#10;func (p *productService) processCreateProductOptionCombinationsWithTx(txRepo product.ProductRepository, id int64, optionValues map[int64][]string) error {&#10;&#9;var productOptionCombinationEntities []entity.ProductOptionCombination&#10;&#10;&#9;// 1. Create product option combination entities from the option values map&#10;&#9;displayOrder := int32(1)&#10;&#9;for option, _ := range optionValues {&#10;&#9;&#9;productOptionCombinationEntity := p.createProductOptionCombinationEntity(id, option, int32(displayOrder))&#10;&#9;&#9;productOptionCombinationEntities = append(productOptionCombinationEntities, *productOptionCombinationEntity)&#10;&#9;&#9;displayOrder++&#10;&#9;}&#10;&#9;&#10;&#9;// 2. Save product option combinations to the repository&#10;&#9;if err := txRepo.CreateProductOptionCombinations(&amp;productOptionCombinationEntities); err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Error saving product option combinations to repository, error: &quot;, err)&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;// 3. Create product option value entities from the option values map&#10;&#9;var productOptionValueEntities []entity.ProductOptionValue&#10;&#9;for optionID, values := range optionValues {&#10;&#9;&#9;for _, value := range values {&#10;&#9;&#9;&#9;productOptionValueEntity := p.createProductOptionValueEntity(optionID, value)&#10;&#9;&#9;&#9;productOptionValueEntities = append(productOptionValueEntities, *productOptionValueEntity)&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;// 4. Create product option values in the repository if they do not already exist&#10;&#9;if err := txRepo.CreateProductOptionValuesIfNotExist(&amp;productOptionValueEntities); err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Error saving product option values to repository, error: &quot;, err)&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;return nil&#10;}&#10;&#10;func (p *productService) createProductEntity(data *request.CreateProductRequest) *entity.Product {&#10;&#9;return &amp;entity.Product{&#10;&#9;&#9;Name:             data.Name,&#10;&#9;&#9;Description:      data.Description,&#10;&#9;&#9;ShortDescription: data.ShortDescription,&#10;&#9;&#9;ImageURL:         data.ImageURL,&#10;&#9;&#9;Slug:             data.Slug,&#10;&#9;&#9;BasePrice:        data.BasePrice,&#10;&#9;&#9;SalePrice:        data.SalePrice,&#10;&#9;&#9;IsFeatured:       data.IsFeatured,&#10;&#9;&#9;SaleStartDate:    data.SaleStartDate,&#10;&#9;&#9;SaleEndDate:      data.SaleEndDate,&#10;&#9;&#9;Status:           data.Status,&#10;&#9;&#9;BrandID:          data.BrandID,&#10;&#9;&#9;CategoryID:       data.CategoryID,&#10;&#9;&#9;UserID:           data.UserID,&#10;&#9;}&#10;}&#10;&#10;func (p *productService) createProductAttributeInfoEntity(productID int64, attributeName string, attributeValue string) *entity.ProductAttributeInfo {&#10;&#9;return &amp;entity.ProductAttributeInfo{&#10;&#9;&#9;AttributeName:  attributeName,&#10;&#9;&#9;AttributeValue: attributeValue,&#10;&#9;&#9;ProductID:      productID,&#10;&#9;}&#10;}&#10;&#10;func (p *productService) createProductOptionInfoEntity(productID int64, optionName string, optionValue string) *entity.ProductOptionInfo {&#10;&#9;return &amp;entity.ProductOptionInfo{&#10;&#9;&#9;OptionName:  optionName,&#10;&#9;&#9;OptionValue: optionValue,&#10;&#9;&#9;ProductID:   productID,&#10;&#9;}&#10;}&#10;&#10;func (p *productService) createProductAttributeValueEntity(productAttributeID int64, value string) *entity.ProductAttributeValue {&#10;&#9;return &amp;entity.ProductAttributeValue{&#10;&#9;&#9;ProductAttributeID: productAttributeID,&#10;&#9;&#9;Value:              value,&#10;&#9;}&#10;}&#10;&#10;func (p *productService) createProductSKUEntity(productID int64, productName string, data *request.CreateProductSKURequest) *entity.ProductSKU {&#10;&#9;return &amp;entity.ProductSKU{&#10;&#9;&#9;SKU:           data.SKU,&#10;&#9;&#9;SKUSignature:  p.generateSKUSignature(productName, data.SKU),&#10;&#9;&#9;ExtraPrice:    data.ExtraPrice,&#10;&#9;&#9;SaleType:      data.SaleType,&#10;&#9;&#9;SaleValue:     data.SaleValue,&#10;&#9;&#9;SaleStartDate: data.SaleStartDate,&#10;&#9;&#9;SaleEndDate:   data.SaleEndDate,&#10;&#9;&#9;Status:        string(constants.ProductStatusActive),&#10;&#9;&#9;ProductID:     productID,&#10;&#9;}&#10;}&#10;&#10;func (p *productService) createProductInventoryEntity(productSKU *entity.ProductSKU, stock int32) *entity.ProductInventory {&#10;&#9;return &amp;entity.ProductInventory{&#10;&#9;&#9;ProductID:      productSKU.ProductID,&#10;&#9;&#9;ProductSKUID:   productSKU.ID,&#10;&#9;&#9;AvailableStock: stock,&#10;&#9;&#9;ReservedStock:  0,&#10;&#9;&#9;DamagedStock:   0,&#10;&#9;}&#10;}&#10;&#10;func (p *productService) createProductOptionCombinationEntity(productID int64, productOptionID int64, displayOrder int32) *entity.ProductOptionCombination {&#10;&#9;return &amp;entity.ProductOptionCombination{&#10;&#9;&#9;ProductID:       productID,&#10;&#9;&#9;ProductOptionID: productOptionID,&#10;&#9;&#9;DisplayOrder:    displayOrder,&#10;&#9;}&#10;}&#10;&#10;func (p *productService) createProductOptionValueEntity(id int64, value string) *entity.ProductOptionValue {&#10;&#9;return &amp;entity.ProductOptionValue{&#10;&#9;&#9;ProductOptionID: id,&#10;&#9;&#9;Value:           value,&#10;&#9;}&#10;}&#10;&#10;func (p *productService) createProductResponse(product *entity.Product) *response.ProductResponse {&#10;&#9;return &amp;response.ProductResponse{&#10;&#9;&#9;ID:               product.ID,&#10;&#9;&#9;Name:             product.Name,&#10;&#9;&#9;ShortDescription: product.ShortDescription,&#10;&#9;&#9;ImageURL:         product.ImageURL,&#10;&#9;&#9;BasePrice:        product.BasePrice,&#10;&#9;&#9;SalePrice:        product.SalePrice,&#10;&#9;&#9;IsFeatured:       product.IsFeatured,&#10;&#9;&#9;SaleStartDate:    product.SaleStartDate,&#10;&#9;&#9;SaleEndDate:      product.SaleEndDate,&#10;&#9;&#9;Status:           product.Status,&#10;&#9;&#9;BrandID:          product.BrandID,&#10;&#9;&#9;CategoryID:       product.CategoryID,&#10;&#9;&#9;UserID:           product.UserID,&#10;&#9;}&#10;}&#10;&#10;func (p *productService) createProductDetailResponse(product *entity.Product) *response.ProductDetailResponse {&#10;&#9;// 1. Fetch product attributes and options&#10;&#9;productAttributes, err := p.productRepository.FindProductAttributesInfoByProductID(product.ID)&#10;&#9;if err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Error fetching product attributes for product ID&quot;, product.ID, &quot;Error:&quot;, err)&#10;&#9;&#9;return nil&#10;&#9;}&#10;&#9;productOptions, err := p.productRepository.FindProductOptionsInfoByProductID(product.ID)&#10;&#9;if err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Error fetching product options for product ID&quot;, product.ID, &quot;Error:&quot;, err)&#10;&#9;&#9;return nil&#10;&#9;}&#10;&#10;&#9;// 3. Fetch product SKUs&#10;&#9;productSKUWithInventories, err := p.productRepository.FindProductSKUsByProductID(product.ID)&#10;&#9;if productSKUWithInventories == nil {&#10;&#9;&#9;p.logger.Error(&quot;No product SKUs found for product ID&quot;, product.ID)&#10;&#9;&#9;return nil&#10;&#9;}&#10;&#10;&#9;// 2. Create response objects for attributes and options&#10;&#9;var attributeValues []*response.ProductWithAttributeValuesResponse&#10;&#9;var optionValues []*response.ProductWithOptionValuesResponse&#10;&#9;for _, attribute := range *productAttributes {&#10;&#9;&#9;attributeValues = append(attributeValues, p.createProductWithAttributeValuesResponse(&amp;attribute))&#10;&#9;}&#10;&#9;for _, option := range *productOptions {&#10;&#9;&#9;optionValues = append(optionValues, p.createProductWithOptionValuesResponse(&amp;option))&#10;&#9;}&#10;&#10;&#9;var productSKUResponses []*response.ProductSKUDetailResponse&#10;&#9;for _, sku := range *productSKUWithInventories {&#10;&#9;&#9;productSKUResponse := p.createProductSKUWithInventoryResponse(product.BasePrice, &amp;sku)&#10;&#9;&#9;productSKUResponses = append(productSKUResponses, productSKUResponse)&#10;&#9;}&#10;&#10;&#9;return &amp;response.ProductDetailResponse{&#10;&#9;&#9;ID:               product.ID,&#10;&#9;&#9;Name:             product.Name,&#10;&#9;&#9;Description:      product.Description,&#10;&#9;&#9;ShortDescription: product.ShortDescription,&#10;&#9;&#9;ImageURL:         product.ImageURL,&#10;&#9;&#9;Slug:             product.Slug,&#10;&#9;&#9;BasePrice:        product.BasePrice,&#10;&#9;&#9;SalePrice:        product.SalePrice,&#10;&#9;&#9;IsFeatured:       product.IsFeatured,&#10;&#9;&#9;SaleStartDate:    product.SaleStartDate,&#10;&#9;&#9;SaleEndDate:      product.SaleEndDate,&#10;&#9;&#9;Status:           product.Status,&#10;&#9;&#9;BrandID:          product.BrandID,&#10;&#9;&#9;CategoryID:       product.CategoryID,&#10;&#9;&#9;UserID:           product.UserID,&#10;&#9;&#9;Version:          product.Version,&#10;&#9;&#9;AttributeValues:  &amp;attributeValues,&#10;&#9;&#9;ProductSKUs:      &amp;productSKUResponses,&#10;&#9;&#9;OptionValues:     &amp;optionValues,&#10;&#9;}&#10;&#10;}&#10;&#10;func (p *productService) createProductWithAttributeValuesResponse(attribute *entity.ProductAttributeInfo) *response.ProductWithAttributeValuesResponse {&#10;&#9;return &amp;response.ProductWithAttributeValuesResponse{&#10;&#9;&#9;ID:              attribute.ID,&#10;&#9;&#9;AttributeName:   attribute.AttributeName,&#10;&#9;&#9;AttributeValues: attribute.AttributeValue,&#10;&#9;}&#10;}&#10;&#10;func (p *productService) createProductWithOptionValuesResponse(option *entity.ProductOptionInfo) *response.ProductWithOptionValuesResponse {&#10;&#9;return &amp;response.ProductWithOptionValuesResponse{&#10;&#9;&#9;ID:           option.ID,&#10;&#9;&#9;OptionNames:  option.OptionName,&#10;&#9;&#9;OptionValues: option.OptionValue,&#10;&#9;}&#10;}&#10;&#10;func (p *productService) createProductSKUWithInventoryResponse(&#10;&#9;productPrice float64,&#10;&#9;productSKUWithInventory *repository.ProductSKUDetail,&#10;) *response.ProductSKUDetailResponse {&#10;&#9;productSKUPrice := p.calculateProductSKUPrice(productPrice, productSKUWithInventory.ExtraPrice)&#10;&#9;return &amp;response.ProductSKUDetailResponse{&#10;&#9;&#9;ID:            productSKUWithInventory.ID,&#10;&#9;&#9;SKU:           productSKUWithInventory.SKU,&#10;&#9;&#9;SKUSignature:  productSKUWithInventory.SKUSignature,&#10;&#9;&#9;Price:         productSKUPrice,&#10;&#9;&#9;SalePrice:     p.calculateProductSKUSalePrice(productSKUPrice, productSKUWithInventory.SaleType, productSKUWithInventory.SaleValue),&#10;&#9;&#9;SaleStartDate: productSKUWithInventory.SaleStartDate,&#10;&#9;&#9;SaleEndDate:   productSKUWithInventory.SaleEndDate,&#10;&#9;&#9;Stock:         productSKUWithInventory.Stock,&#10;&#9;&#9;Status:        productSKUWithInventory.Status,&#10;&#9;&#9;ProductID:     productSKUWithInventory.ProductID,&#10;&#9;}&#10;}&#10;&#10;func (p *productService) generateSKUSignature(name string, sku string) string {&#10;&#9;skuSignature := strings.ToLower(name + &quot;-&quot; + sku)&#10;&#9;skuSignature = strings.ReplaceAll(sku, &quot; &quot;, &quot;-&quot;)&#10;&#10;&#9;return skuSignature&#10;}&#10;&#10;func (p *productService) calculateProductSKUPrice(productPrice float64, extraPrice float64) float64 {&#10;&#9;if extraPrice &lt; 0 {&#10;&#9;&#9;return productPrice&#10;&#9;}&#10;&#10;&#9;finalPrice := productPrice + productPrice*extraPrice&#10;&#9;return finalPrice&#10;}&#10;&#10;func (p *productService) calculateProductSKUSalePrice(productSKUPrice float64, saleType *string, saleValue *float64) *float64 {&#10;&#9;if saleType == nil || saleValue == nil {&#10;&#9;&#9;return nil&#10;&#9;}&#10;&#10;&#9;if *saleType == constants.SaleTypePercentage {&#10;&#9;&#9;// Calculate sale price as a percentage discount&#10;&#9;&#9;finalPrice := productSKUPrice - (productSKUPrice * *saleValue)&#10;&#9;&#9;return &amp;finalPrice&#10;&#9;} else if *saleType == constants.SaleTypeFixed {&#10;&#9;&#9;finalPrice := productSKUPrice - *saleValue&#10;&#9;&#9;if finalPrice &lt; 0 {&#10;&#9;&#9;&#9;finalPrice = 0&#10;&#9;&#9;}&#10;&#9;&#9;return &amp;finalPrice&#10;&#9;}&#10;&#10;&#9;return nil&#10;}&#10;&#10;// CreateProductWithoutSKU Help to create a product without SKU (for case app only have backend API)&#10;func (p *productService) CreateProductWithoutSKU(data *request.CreateProductWithoutSKURequest) (*response.ProductDetailResponse, error) {&#10;&#9;p.logger.Info(&quot;Creating product without SKU with name: &quot;, data.Name)&#10;&#10;&#9;// Generate all SKU combinations automatically from option values&#10;&#9;productSKUs, err := p.generateAllSKUCombinations(data.Name, data.OptionValues)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;// Create the full CreateProductRequest with generated SKUs&#10;&#9;createProductRequest := &amp;request.CreateProductRequest{&#10;&#9;&#9;Name:              data.Name,&#10;&#9;&#9;Description:       data.Description,&#10;&#9;&#9;ShortDescription:  data.ShortDescription,&#10;&#9;&#9;ImageURL:          data.ImageURL,&#10;&#9;&#9;Slug:              data.Slug,&#10;&#9;&#9;BasePrice:         data.BasePrice,&#10;&#9;&#9;SalePrice:         data.SalePrice,&#10;&#9;&#9;IsFeatured:        data.IsFeatured,&#10;&#9;&#9;SaleStartDate:     data.SaleStartDate,&#10;&#9;&#9;SaleEndDate:       data.SaleEndDate,&#10;&#9;&#9;Status:            string(constants.ProductStatusActive),&#10;&#9;&#9;BrandID:           data.BrandID,&#10;&#9;&#9;CategoryID:        data.CategoryID,&#10;&#9;&#9;UserID:            data.UserID,&#10;&#9;&#9;ProductAttributes: data.ProductAttributes,&#10;&#9;&#9;OptionValues:      data.OptionValues,&#10;&#9;&#9;ProductSKUs:       *productSKUs,&#10;&#9;}&#10;&#10;&#9;// Call the existing CreateProduct function&#10;&#9;return p.CreateProduct(createProductRequest)&#10;}&#10;&#10;// generateAllSKUCombinations generates all possible SKU combinations from option values&#10;func (p *productService) generateAllSKUCombinations(productName string, optionValues map[int64][]string) (*[]request.CreateProductSKURequest, error) {&#10;&#9;// Clean up option values - remove empty options&#10;&#9;cleanedOptions := make(map[int64][]string)&#10;&#9;optionIDs := make([]int64, 0)&#10;&#10;&#9;for optionID, values := range optionValues {&#10;&#9;&#9;if len(values) &gt; 0 {&#10;&#9;&#9;&#9;cleanedOptions[optionID] = values&#10;&#9;&#9;&#9;optionIDs = append(optionIDs, optionID)&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;// If no options, create a single default SKU&#10;&#9;if len(cleanedOptions) == 0 {&#10;&#9;&#9;defaultSKU := []request.CreateProductSKURequest{&#10;&#9;&#9;&#9;{&#10;&#9;&#9;&#9;&#9;SKU:        productName + &quot;_default&quot;,&#10;&#9;&#9;&#9;&#9;ExtraPrice: 0,&#10;&#9;&#9;&#9;&#9;Stock:      100,&#10;&#9;&#9;&#9;},&#10;&#9;&#9;}&#10;&#9;&#9;return &amp;defaultSKU, nil&#10;&#9;}&#10;&#10;&#9;// Generate all combinations using cartesian product&#10;&#9;combinations := p.generateCartesianProduct(cleanedOptions, optionIDs)&#10;&#10;&#9;// Create SKU requests from combinations&#10;&#9;var productSKUs []request.CreateProductSKURequest&#10;&#9;for _, combination := range combinations {&#10;&#9;&#9;sku := p.buildSKUFromCombination(productName, combination, optionIDs)&#10;&#9;&#9;price := constants.DefaultPrice&#10;&#9;&#9;stock := constants.DefaultStock&#10;&#10;&#9;&#9;productSKUs = append(productSKUs, request.CreateProductSKURequest{&#10;&#9;&#9;&#9;SKU:        sku,&#10;&#9;&#9;&#9;ExtraPrice: price,&#10;&#9;&#9;&#9;Stock:      int32(stock),&#10;&#9;&#9;})&#10;&#9;}&#10;&#10;&#9;return &amp;productSKUs, nil&#10;}&#10;&#10;// generateCartesianProduct generates all possible combinations of option values&#10;func (p *productService) generateCartesianProduct(optionValues map[int64][]string, optionIDs []int64) []map[int64]string {&#10;&#9;if len(optionIDs) == 0 {&#10;&#9;&#9;return []map[int64]string{}&#10;&#9;}&#10;&#10;&#9;// Start with the first option&#10;&#9;var result []map[int64]string&#10;&#9;firstOptionID := optionIDs[0]&#10;&#9;firstValues := optionValues[firstOptionID]&#10;&#10;&#9;for _, value := range firstValues {&#10;&#9;&#9;combination := make(map[int64]string)&#10;&#9;&#9;combination[firstOptionID] = value&#10;&#9;&#9;result = append(result, combination)&#10;&#9;}&#10;&#10;&#9;// Add remaining options one by one&#10;&#9;for i := 1; i &lt; len(optionIDs); i++ {&#10;&#9;&#9;optionID := optionIDs[i]&#10;&#9;&#9;values := optionValues[optionID]&#10;&#10;&#9;&#9;var newResult []map[int64]string&#10;&#9;&#9;for _, existingCombination := range result {&#10;&#9;&#9;&#9;for _, value := range values {&#10;&#9;&#9;&#9;&#9;newCombination := make(map[int64]string)&#10;&#9;&#9;&#9;&#9;// Copy existing combination&#10;&#9;&#9;&#9;&#9;for k, v := range existingCombination {&#10;&#9;&#9;&#9;&#9;&#9;newCombination[k] = v&#10;&#9;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;&#9;// Add new option value&#10;&#9;&#9;&#9;&#9;newCombination[optionID] = value&#10;&#9;&#9;&#9;&#9;newResult = append(newResult, newCombination)&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#9;&#9;result = newResult&#10;&#9;}&#10;&#10;&#9;return result&#10;}&#10;&#10;// buildSKUFromCombination builds SKU string from option combination&#10;func (p *productService) buildSKUFromCombination(productName string, combination map[int64]string, optionIDs []int64) string {&#10;&#9;skuParts := []string{productName}&#10;&#10;&#9;// Add option values in consistent order&#10;&#9;for _, optionID := range optionIDs {&#10;&#9;&#9;if value, exists := combination[optionID]; exists {&#10;&#9;&#9;&#9;// Clean up value for SKU (remove spaces, special chars)&#10;&#9;&#9;&#9;cleanValue := strings.ReplaceAll(value, &quot; &quot;, &quot;&quot;)&#10;&#9;&#9;&#9;skuParts = append(skuParts, cleanValue)&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;return strings.Join(skuParts, &quot;_&quot;)&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/internal/services/product/product_repository.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/internal/services/product/product_repository.go" />
              <option name="originalContent" value="package product&#10;&#10;import (&#10;&#9;&quot;github.com/hthinh24/go-store/services/product/internal/dto/repository&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/services/product/internal/entity&quot;&#10;)&#10;&#10;type ProductRepository interface {&#10;&#9;BeginTx() error&#10;&#9;CommitTx() error&#10;&#10;&#9;FindProductByID(id int64) (*entity.Product, error)&#10;&#9;FindProductAttributesInfoByProductID(productID int64) (*[]entity.ProductAttributeInfo, error)&#10;&#9;FindProductOptionsInfoByProductID(productID int64) (*[]entity.ProductOptionInfo, error)&#10;&#9;FindProductSKUsByProductID(id int64) (*[]repository.ProductSKUDetail, error)&#10;&#10;&#9;FindProductAttributesByIDs(productAttributeIDs []int64) (*[]entity.ProductAttribute, error)&#10;&#9;FindProductOptionsByIDs(productOptionIDs []int64) (*[]entity.ProductOption, error)&#10;&#10;&#9;CreateProduct(product *entity.Product) error&#10;&#9;CreateProductAttributeInfo(productAttributeInfos *[]entity.ProductAttributeInfo) error&#10;&#9;CreateProductOptionInfo(productOptionInfos *[]entity.ProductOptionInfo) error&#10;&#9;CreateProductAttributeValuesIfNotExist(*[]entity.ProductAttributeValue) error&#10;&#9;CreateProductProductAttributeValues(*[]entity.ProductProductAttributeValue) error&#10;&#9;CreateProductSKUs(productSKUs *[]entity.ProductSKU) error&#10;&#9;CreateProductInventories(inventories *[]entity.ProductInventory) error&#10;&#9;CreateProductOptionCombinations(productOptionCombinations *[]entity.ProductOptionCombination) error&#10;&#9;CreateProductOptionValuesIfNotExist(productOptionValues *[]entity.ProductOptionValue) error&#10;&#10;&#9;DeleteProduct(id int64) error&#10;}&#10;" />
              <option name="updatedContent" value="package product&#10;&#10;import (&#10;&#9;&quot;github.com/hthinh24/go-store/services/product/internal/dto/repository&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/services/product/internal/entity&quot;&#10;)&#10;&#10;type ProductRepository interface {&#10;&#9;// Transaction methods&#10;&#9;WithTransaction() (ProductRepository, error)&#10;&#9;Commit() error&#10;&#9;Rollback() error&#10;&#9;IsInTransaction() bool&#10;&#10;&#9;FindProductByID(id int64) (*entity.Product, error)&#10;&#9;FindProductAttributesInfoByProductID(productID int64) (*[]entity.ProductAttributeInfo, error)&#10;&#9;FindProductOptionsInfoByProductID(productID int64) (*[]entity.ProductOptionInfo, error)&#10;&#9;FindProductSKUsByProductID(id int64) (*[]repository.ProductSKUDetail, error)&#10;&#10;&#9;FindProductAttributesByIDs(productAttributeIDs []int64) (*[]entity.ProductAttribute, error)&#10;&#9;FindProductOptionsByIDs(productOptionIDs []int64) (*[]entity.ProductOption, error)&#10;&#10;&#9;CreateProduct(product *entity.Product) error&#10;&#9;CreateProductAttributeInfo(productAttributeInfos *[]entity.ProductAttributeInfo) error&#10;&#9;CreateProductOptionInfo(productOptionInfos *[]entity.ProductOptionInfo) error&#10;&#9;CreateProductAttributeValuesIfNotExist(*[]entity.ProductAttributeValue) error&#10;&#9;CreateProductProductAttributeValues(*[]entity.ProductProductAttributeValue) error&#10;&#9;CreateProductSKUs(productSKUs *[]entity.ProductSKU) error&#10;&#9;CreateProductInventories(inventories *[]entity.ProductInventory) error&#10;&#9;CreateProductOptionCombinations(productOptionCombinations *[]entity.ProductOptionCombination) error&#10;&#9;CreateProductOptionValuesIfNotExist(productOptionValues *[]entity.ProductOptionValue) error&#10;&#10;&#9;DeleteProduct(id int64) error&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>