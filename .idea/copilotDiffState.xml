<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/internal/pkg/auth/auth_middleware.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/internal/pkg/auth/auth_middleware.go" />
              <option name="updatedContent" value="package auth&#10;&#10;import (&#10;&#9;&quot;net/http&quot;&#10;&#9;&quot;strings&quot;&#10;&#9;&quot;time&quot;&#10;&#10;&#9;&quot;github.com/gin-gonic/gin&quot;&#10;&#9;&quot;github.com/golang-jwt/jwt/v4&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/internal/pkg/logger&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/internal/pkg/rest&quot;&#10;)&#10;&#10;type SharedAuthMiddleware struct {&#10;&#9;logger    logger.Logger&#10;&#9;jwtSecret string&#10;}&#10;&#10;type JWTClaims struct {&#10;&#9;UserID           int64     `json:&quot;user_id&quot;`&#10;&#9;Email            string    `json:&quot;email&quot;`&#10;&#9;Roles            []string  `json:&quot;roles&quot;`&#10;&#9;Permissions      []string  `json:&quot;permissions&quot;`&#10;&#9;RefreshExpiresAt time.Time `json:&quot;refresh_expires_at&quot;`&#10;&#9;jwt.RegisteredClaims&#10;}&#10;&#10;func NewSharedAuthMiddleware(logger logger.Logger, jwtSecret string) *SharedAuthMiddleware {&#10;&#9;return &amp;SharedAuthMiddleware{&#10;&#9;&#9;logger:    logger,&#10;&#9;&#9;jwtSecret: jwtSecret,&#10;&#9;}&#10;}&#10;&#10;// AuthRequired validates JWT token and sets user info in context&#10;func (m *SharedAuthMiddleware) AuthRequired() gin.HandlerFunc {&#10;&#9;return func(c *gin.Context) {&#10;&#9;&#9;authHeader := c.GetHeader(&quot;Authorization&quot;)&#10;&#9;&#9;if authHeader == &quot;&quot; {&#10;&#9;&#9;&#9;c.JSON(http.StatusUnauthorized, rest.ErrorResponse{&#10;&#9;&#9;&#9;&#9;ApiError: rest.UnauthorizedError,&#10;&#9;&#9;&#9;&#9;Message:  &quot;Authorization header required&quot;,&#10;&#9;&#9;&#9;})&#10;&#9;&#9;&#9;c.Abort()&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#10;&#9;&#9;tokenString := strings.TrimPrefix(authHeader, &quot;Bearer &quot;)&#10;&#9;&#9;if tokenString == authHeader {&#10;&#9;&#9;&#9;c.JSON(http.StatusUnauthorized, rest.ErrorResponse{&#10;&#9;&#9;&#9;&#9;ApiError: rest.UnauthorizedError,&#10;&#9;&#9;&#9;&#9;Message:  &quot;Bearer token required&quot;,&#10;&#9;&#9;&#9;})&#10;&#9;&#9;&#9;c.Abort()&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#10;&#9;&#9;claims, err := m.validateToken(tokenString)&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;m.logger.Error(&quot;Failed to validate JWT token&quot;, &quot;error&quot;, err)&#10;&#9;&#9;&#9;c.JSON(http.StatusUnauthorized, rest.ErrorResponse{&#10;&#9;&#9;&#9;&#9;ApiError: rest.UnauthorizedError,&#10;&#9;&#9;&#9;&#9;Message:  &quot;Invalid token&quot;,&#10;&#9;&#9;&#9;})&#10;&#9;&#9;&#9;c.Abort()&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// Set user info in context for all services to use&#10;&#9;&#9;c.Set(&quot;user_id&quot;, claims.UserID)&#10;&#9;&#9;c.Set(&quot;email&quot;, claims.Email)&#10;&#9;&#9;c.Set(&quot;roles&quot;, claims.Roles)&#10;&#9;&#9;c.Set(&quot;permissions&quot;, claims.Permissions)&#10;&#10;&#9;&#9;c.Next()&#10;&#9;}&#10;}&#10;&#10;// RequirePermissions checks if user has ALL specified permissions&#10;func (m *SharedAuthMiddleware) RequirePermissions(requiredPermissions ...string) gin.HandlerFunc {&#10;&#9;return func(c *gin.Context) {&#10;&#9;&#9;permissions, exists := c.Get(&quot;permissions&quot;)&#10;&#9;&#9;if !exists {&#10;&#9;&#9;&#9;c.JSON(http.StatusUnauthorized, rest.ErrorResponse{&#10;&#9;&#9;&#9;&#9;ApiError: rest.UnauthorizedError,&#10;&#9;&#9;&#9;&#9;Message:  &quot;User not authenticated&quot;,&#10;&#9;&#9;&#9;})&#10;&#9;&#9;&#9;c.Abort()&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#10;&#9;&#9;userPermissions := permissions.([]string)&#10;&#9;&#9;userPermMap := make(map[string]bool)&#10;&#9;&#9;for _, perm := range userPermissions {&#10;&#9;&#9;&#9;userPermMap[perm] = true&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// Check if user has all required permissions&#10;&#9;&#9;for _, requiredPerm := range requiredPermissions {&#10;&#9;&#9;&#9;if !userPermMap[requiredPerm] {&#10;&#9;&#9;&#9;&#9;m.logger.Warn(&quot;Access denied - missing permission&quot;, &#10;&#9;&#9;&#9;&#9;&#9;&quot;user_id&quot;, c.Get(&quot;user_id&quot;), &#10;&#9;&#9;&#9;&#9;&#9;&quot;required_permission&quot;, requiredPerm)&#10;&#9;&#9;&#9;&#9;c.JSON(http.StatusForbidden, rest.ErrorResponse{&#10;&#9;&#9;&#9;&#9;&#9;ApiError: rest.ForbiddenError,&#10;&#9;&#9;&#9;&#9;&#9;Message:  &quot;Insufficient permissions&quot;,&#10;&#9;&#9;&#9;&#9;})&#10;&#9;&#9;&#9;&#9;c.Abort()&#10;&#9;&#9;&#9;&#9;return&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#10;&#9;&#9;c.Next()&#10;&#9;}&#10;}&#10;&#10;// RequireAnyPermission checks if user has ANY of the specified permissions&#10;func (m *SharedAuthMiddleware) RequireAnyPermission(permissions ...string) gin.HandlerFunc {&#10;&#9;return func(c *gin.Context) {&#10;&#9;&#9;userPermissions, exists := c.Get(&quot;permissions&quot;)&#10;&#9;&#9;if !exists {&#10;&#9;&#9;&#9;c.JSON(http.StatusUnauthorized, rest.ErrorResponse{&#10;&#9;&#9;&#9;&#9;ApiError: rest.UnauthorizedError,&#10;&#9;&#9;&#9;&#9;Message:  &quot;User not authenticated&quot;,&#10;&#9;&#9;&#9;})&#10;&#9;&#9;&#9;c.Abort()&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#10;&#9;&#9;userPerms := userPermissions.([]string)&#10;&#9;&#9;for _, userPerm := range userPerms {&#10;&#9;&#9;&#9;for _, requiredPerm := range permissions {&#10;&#9;&#9;&#9;&#9;if userPerm == requiredPerm {&#10;&#9;&#9;&#9;&#9;&#9;c.Next()&#10;&#9;&#9;&#9;&#9;&#9;return&#10;&#9;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#10;&#9;&#9;c.JSON(http.StatusForbidden, rest.ErrorResponse{&#10;&#9;&#9;&#9;ApiError: rest.ForbiddenError,&#10;&#9;&#9;&#9;Message:  &quot;Insufficient permissions&quot;,&#10;&#9;&#9;})&#10;&#9;&#9;c.Abort()&#10;&#9;}&#10;}&#10;&#10;// RequireRole checks if user has specific role&#10;func (m *SharedAuthMiddleware) RequireRole(role string) gin.HandlerFunc {&#10;&#9;return func(c *gin.Context) {&#10;&#9;&#9;roles, exists := c.Get(&quot;roles&quot;)&#10;&#9;&#9;if !exists {&#10;&#9;&#9;&#9;c.JSON(http.StatusUnauthorized, rest.ErrorResponse{&#10;&#9;&#9;&#9;&#9;ApiError: rest.UnauthorizedError,&#10;&#9;&#9;&#9;&#9;Message:  &quot;User not authenticated&quot;,&#10;&#9;&#9;&#9;})&#10;&#9;&#9;&#9;c.Abort()&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#10;&#9;&#9;userRoles := roles.([]string)&#10;&#9;&#9;for _, userRole := range userRoles {&#10;&#9;&#9;&#9;if userRole == role {&#10;&#9;&#9;&#9;&#9;c.Next()&#10;&#9;&#9;&#9;&#9;return&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#10;&#9;&#9;c.JSON(http.StatusForbidden, rest.ErrorResponse{&#10;&#9;&#9;&#9;ApiError: rest.ForbiddenError,&#10;&#9;&#9;&#9;Message:  &quot;Insufficient role permissions&quot;,&#10;&#9;&#9;})&#10;&#9;&#9;c.Abort()&#10;&#9;}&#10;}&#10;&#10;func (m *SharedAuthMiddleware) validateToken(tokenString string) (*JWTClaims, error) {&#10;&#9;token, err := jwt.ParseWithClaims(tokenString, &amp;JWTClaims{}, func(token *jwt.Token) (interface{}, error) {&#10;&#9;&#9;return []byte(m.jwtSecret), nil&#10;&#9;})&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;claims, ok := token.Claims.(*JWTClaims)&#10;&#9;if !ok {&#10;&#9;&#9;return nil, jwt.ErrTokenMalformed&#10;&#9;}&#10;&#10;&#9;now := time.Now()&#10;&#10;&#9;// Check if refresh token is expired (hard expiration)&#10;&#9;if !claims.RefreshExpiresAt.IsZero() &amp;&amp; now.After(claims.RefreshExpiresAt) {&#10;&#9;&#9;m.logger.Warn(&quot;Refresh token has expired&quot;, &quot;user_id&quot;, claims.UserID)&#10;&#9;&#9;return nil, jwt.NewValidationError(&quot;refresh token expired&quot;, jwt.ValidationErrorExpired)&#10;&#9;}&#10;&#10;&#9;// Check if access token is expired&#10;&#9;if claims.ExpiresAt != nil &amp;&amp; now.After(claims.ExpiresAt.Time) {&#10;&#9;&#9;m.logger.Info(&quot;Access token expired&quot;, &quot;user_id&quot;, claims.UserID)&#10;&#9;&#9;return nil, jwt.NewValidationError(&quot;access token expired&quot;, jwt.ValidationErrorExpired)&#10;&#9;}&#10;&#10;&#9;// Check not before&#10;&#9;if claims.NotBefore != nil &amp;&amp; now.Before(claims.NotBefore.Time) {&#10;&#9;&#9;return nil, jwt.NewValidationError(&quot;token used before valid&quot;, jwt.ValidationErrorNotValidYet)&#10;&#9;}&#10;&#10;&#9;// Check issued at&#10;&#9;if claims.IssuedAt != nil &amp;&amp; now.Before(claims.IssuedAt.Time) {&#10;&#9;&#9;return nil, jwt.NewValidationError(&quot;token issued in the future&quot;, jwt.ValidationErrorIssuedAt)&#10;&#9;}&#10;&#10;&#9;return claims, nil&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/internal/pkg/gateway/api_gateway.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/internal/pkg/gateway/api_gateway.go" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/internal/services/cart/internal/controller/cart_controller.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/internal/services/cart/internal/controller/cart_controller.go" />
              <option name="originalContent" value="package controller&#10;&#10;import (&#10;&#9;&quot;errors&quot;&#10;&#9;&quot;github.com/gin-gonic/gin&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/internal/pkg/logger&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/internal/pkg/rest&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/services/cart/internal&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/services/cart/internal/dto/request&quot;&#10;&#9;customErr &quot;github.com/hthinh24/go-store/services/cart/internal/errors&quot;&#10;&#9;&quot;net/http&quot;&#10;&#9;&quot;strconv&quot;&#10;)&#10;&#10;type CartController struct {&#10;&#9;logger      logger.Logger&#10;&#9;cartService internal.CartService&#10;}&#10;&#10;func NewCartController(logger logger.Logger, cartService internal.CartService) *CartController {&#10;&#9;return &amp;CartController{&#10;&#9;&#9;logger:      logger,&#10;&#9;&#9;cartService: cartService,&#10;&#9;}&#10;}&#10;&#10;func (c *CartController) GetCartItemsByUserID() func(c *gin.Context) {&#10;&#9;return func(ctx *gin.Context) {&#10;&#9;&#9;userID, err := c.getUserIDFromContext(ctx)&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;ctx.JSON(http.StatusUnauthorized, rest.NewErrorResponse(rest.UnauthorizedError, &quot;User not authenticated&quot;))&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#10;&#9;&#9;cartItems, err := c.cartService.FindCartItemsByCartID(userID)&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;c.handleCartError(ctx, err)&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#10;&#9;&#9;ctx.JSON(http.StatusOK, rest.NewAPIResponse(http.StatusOK, &quot;Get cart items by user id successfully&quot;, cartItems))&#10;&#9;}&#10;}&#10;&#10;func (c *CartController) AddItemToCart() func(c *gin.Context) {&#10;&#9;return func(ctx *gin.Context) {&#10;&#9;&#9;var item request.AddItemRequest&#10;&#9;&#9;if err := ctx.ShouldBindJSON(&amp;item); err != nil {&#10;&#9;&#9;&#9;ctx.JSON(http.StatusBadRequest, rest.NewErrorResponse(rest.BadRequestError, &quot;Invalid input&quot;))&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#10;&#9;&#9;userID, err := c.getUserIDFromContext(ctx)&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;ctx.JSON(http.StatusUnauthorized, rest.NewErrorResponse(rest.UnauthorizedError, err.Error()))&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#10;&#9;&#9;if err := c.cartService.AddItemToCart(userID, &amp;item); err != nil {&#10;&#9;&#9;&#9;c.handleCartError(ctx, err)&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#10;&#9;&#9;ctx.JSON(http.StatusCreated, rest.NewAPIResponse(http.StatusCreated, &quot;Item added to cart successfully&quot;, nil))&#10;&#9;}&#10;}&#10;&#10;func (c *CartController) UpdateItemQuantity() func(c *gin.Context) {&#10;&#9;return func(ctx *gin.Context) {&#10;&#9;&#9;var item request.UpdateItemQuantityRequest&#10;&#9;&#9;if err := ctx.ShouldBindJSON(&amp;item); err != nil {&#10;&#9;&#9;&#9;ctx.JSON(http.StatusBadRequest, rest.NewErrorResponse(rest.BadRequestError, &quot;Invalid input&quot;))&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#10;&#9;&#9;userID, err := c.getUserIDFromContext(ctx)&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;ctx.JSON(http.StatusUnauthorized, rest.NewErrorResponse(rest.UnauthorizedError, err.Error()))&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#10;&#9;&#9;if err := c.cartService.UpdateItemQuantity(userID, item.ItemID, item.Quantity); err != nil {&#10;&#9;&#9;&#9;c.handleCartError(ctx, err)&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#10;&#9;&#9;ctx.JSON(http.StatusOK, rest.NewAPIResponse(http.StatusOK, &quot;Item quantity updated successfully&quot;, nil))&#10;&#9;}&#10;}&#10;&#10;func (c *CartController) RemoveItemFromCart() func(c *gin.Context) {&#10;&#9;return func(ctx *gin.Context) {&#10;&#9;&#9;itemID := ctx.Param(&quot;item_id&quot;)&#10;&#9;&#9;itemIDInt, err := strconv.Atoi(itemID)&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;ctx.JSON(http.StatusBadRequest, rest.NewErrorResponse(rest.BadRequestError, &quot;Invalid item ID format&quot;))&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#10;&#9;&#9;userID, err := c.getUserIDFromContext(ctx)&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;ctx.JSON(http.StatusUnauthorized, rest.NewErrorResponse(rest.UnauthorizedError, err.Error()))&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#10;&#9;&#9;if err := c.cartService.RemoveItemFromCart(userID, int64(itemIDInt)); err != nil {&#10;&#9;&#9;&#9;c.handleCartError(ctx, err)&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#10;&#9;&#9;ctx.JSON(http.StatusOK, rest.NewAPIResponse(http.StatusOK, &quot;Item removed from cart successfully&quot;, nil))&#10;&#9;}&#10;}&#10;&#10;func (c *CartController) getUserIDFromContext(ctx *gin.Context) (int64, error) {&#10;&#9;userID, exists := ctx.Get(&quot;user_id&quot;)&#10;&#9;if !exists {&#10;&#9;&#9;return 0, errors.New(&quot;user ID not found in context&quot;)&#10;&#9;}&#10;&#10;&#9;userIDInt64, ok := userID.(int64)&#10;&#9;if !ok {&#10;&#9;&#9;return 0, errors.New(&quot;invalid user ID type&quot;)&#10;&#9;}&#10;&#10;&#9;return userIDInt64, nil&#10;}&#10;&#10;func (c *CartController) handleCartError(ctx *gin.Context, err error) {&#10;&#9;switch {&#10;&#9;case errors.Is(err, customErr.ErrCartNotFound):&#10;&#9;&#9;ctx.JSON(http.StatusNotFound, rest.NewErrorResponse(rest.NotFoundError, err.Error()))&#10;&#9;case errors.Is(err, customErr.ErrCartItemNotFound):&#10;&#9;&#9;ctx.JSON(http.StatusNotFound, rest.NewErrorResponse(rest.NotFoundError, err.Error()))&#10;&#9;case errors.Is(err, customErr.ErrCartItemAlreadyExists):&#10;&#9;&#9;ctx.JSON(http.StatusConflict, rest.NewErrorResponse(rest.ConflictError, err.Error()))&#10;&#9;default:&#10;&#9;&#9;ctx.JSON(http.StatusInternalServerError, rest.NewErrorResponse(rest.InternalServerErrorError, &quot;An unexpected error occurred&quot;))&#10;&#9;}&#10;}&#10;" />
              <option name="updatedContent" value="package controller&#13;&#10;&#13;&#10;import (&#13;&#10;&#9;&quot;errors&quot;&#13;&#10;&#9;&quot;github.com/gin-gonic/gin&quot;&#13;&#10;&#9;&quot;github.com/hthinh24/go-store/internal/pkg/logger&quot;&#13;&#10;&#9;&quot;github.com/hthinh24/go-store/internal/pkg/rest&quot;&#13;&#10;&#9;&quot;github.com/hthinh24/go-store/services/cart/internal&quot;&#13;&#10;&#9;&quot;github.com/hthinh24/go-store/services/cart/internal/dto/request&quot;&#13;&#10;&#9;customErr &quot;github.com/hthinh24/go-store/services/cart/internal/errors&quot;&#13;&#10;&#9;&quot;net/http&quot;&#13;&#10;&#9;&quot;strconv&quot;&#13;&#10;)&#13;&#10;&#13;&#10;type CartController struct {&#13;&#10;&#9;logger      logger.Logger&#13;&#10;&#9;cartService internal.CartService&#13;&#10;}&#13;&#10;&#13;&#10;func NewCartController(logger logger.Logger, cartService internal.CartService) *CartController {&#13;&#10;&#9;return &amp;CartController{&#13;&#10;&#9;&#9;logger:      logger,&#13;&#10;&#9;&#9;cartService: cartService,&#13;&#10;&#9;}&#13;&#10;}&#13;&#10;&#13;&#10;func (c *CartController) CreateCart() func(c *gin.Context) {&#13;&#10;&#9;return func(ctx *gin.Context) {&#13;&#10;&#9;&#9;var createCartRequest request.CreateCartRequest&#13;&#10;&#9;&#9;if err := ctx.ShouldBindJSON(&amp;createCartRequest); err != nil {&#13;&#10;&#9;&#9;&#9;c.logger.Error(&quot;Invalid create cart request&quot;, &quot;error&quot;, err)&#13;&#10;&#9;&#9;&#9;ctx.JSON(http.StatusBadRequest, rest.NewErrorResponse(rest.BadRequestError, &quot;Invalid input&quot;))&#13;&#10;&#9;&#9;&#9;return&#13;&#10;&#9;&#9;}&#13;&#10;&#13;&#10;&#9;&#9;cart, err := c.cartService.CreateCart(&amp;createCartRequest)&#13;&#10;&#9;&#9;if err != nil {&#13;&#10;&#9;&#9;&#9;c.handleCartError(ctx, err)&#13;&#10;&#9;&#9;&#9;return&#13;&#10;&#9;&#9;}&#13;&#10;&#13;&#10;&#9;&#9;ctx.JSON(http.StatusCreated, rest.NewAPIResponse(http.StatusCreated, &quot;Cart created successfully&quot;, cart))&#13;&#10;&#9;}&#13;&#10;}&#13;&#10;&#13;&#10;func (c *CartController) GetCartItemsByUserID() func(c *gin.Context) {&#13;&#10;&#9;return func(ctx *gin.Context) {&#13;&#10;&#9;&#9;userID, err := c.getUserIDFromContext(ctx)&#13;&#10;&#9;&#9;if err != nil {&#13;&#10;&#9;&#9;&#9;ctx.JSON(http.StatusUnauthorized, rest.NewErrorResponse(rest.UnauthorizedError, &quot;User not authenticated&quot;))&#13;&#10;&#9;&#9;&#9;return&#13;&#10;&#9;&#9;}&#13;&#10;&#13;&#10;&#9;&#9;cartItems, err := c.cartService.FindCartItemsByCartID(userID)&#13;&#10;&#9;&#9;if err != nil {&#13;&#10;&#9;&#9;&#9;c.handleCartError(ctx, err)&#13;&#10;&#9;&#9;&#9;return&#13;&#10;&#9;&#9;}&#13;&#10;&#13;&#10;&#9;&#9;ctx.JSON(http.StatusOK, rest.NewAPIResponse(http.StatusOK, &quot;Get cart items by user id successfully&quot;, cartItems))&#13;&#10;&#9;}&#13;&#10;}&#13;&#10;&#13;&#10;func (c *CartController) AddItemToCart() func(c *gin.Context) {&#13;&#10;&#9;return func(ctx *gin.Context) {&#13;&#10;&#9;&#9;var item request.AddItemRequest&#13;&#10;&#9;&#9;if err := ctx.ShouldBindJSON(&amp;item); err != nil {&#13;&#10;&#9;&#9;&#9;ctx.JSON(http.StatusBadRequest, rest.NewErrorResponse(rest.BadRequestError, &quot;Invalid input&quot;))&#13;&#10;&#9;&#9;&#9;return&#13;&#10;&#9;&#9;}&#13;&#10;&#13;&#10;&#9;&#9;userID, err := c.getUserIDFromContext(ctx)&#13;&#10;&#9;&#9;if err != nil {&#13;&#10;&#9;&#9;&#9;ctx.JSON(http.StatusUnauthorized, rest.NewErrorResponse(rest.UnauthorizedError, err.Error()))&#13;&#10;&#9;&#9;&#9;return&#13;&#10;&#9;&#9;}&#13;&#10;&#13;&#10;&#9;&#9;if err := c.cartService.AddItemToCart(userID, &amp;item); err != nil {&#13;&#10;&#9;&#9;&#9;c.handleCartError(ctx, err)&#13;&#10;&#9;&#9;&#9;return&#13;&#10;&#9;&#9;}&#13;&#10;&#13;&#10;&#9;&#9;ctx.JSON(http.StatusCreated, rest.NewAPIResponse(http.StatusCreated, &quot;Item added to cart successfully&quot;, nil))&#13;&#10;&#9;}&#13;&#10;}&#13;&#10;&#13;&#10;func (c *CartController) UpdateItemQuantity() func(c *gin.Context) {&#13;&#10;&#9;return func(ctx *gin.Context) {&#13;&#10;&#9;&#9;var item request.UpdateItemQuantityRequest&#13;&#10;&#9;&#9;if err := ctx.ShouldBindJSON(&amp;item); err != nil {&#13;&#10;&#9;&#9;&#9;ctx.JSON(http.StatusBadRequest, rest.NewErrorResponse(rest.BadRequestError, &quot;Invalid input&quot;))&#13;&#10;&#9;&#9;&#9;return&#13;&#10;&#9;&#9;}&#13;&#10;&#13;&#10;&#9;&#9;userID, err := c.getUserIDFromContext(ctx)&#13;&#10;&#9;&#9;if err != nil {&#13;&#10;&#9;&#9;&#9;ctx.JSON(http.StatusUnauthorized, rest.NewErrorResponse(rest.UnauthorizedError, err.Error()))&#13;&#10;&#9;&#9;&#9;return&#13;&#10;&#9;&#9;}&#13;&#10;&#13;&#10;&#9;&#9;if err := c.cartService.UpdateItemQuantity(userID, item.ItemID, item.Quantity); err != nil {&#13;&#10;&#9;&#9;&#9;c.handleCartError(ctx, err)&#13;&#10;&#9;&#9;&#9;return&#13;&#10;&#9;&#9;}&#13;&#10;&#13;&#10;&#9;&#9;ctx.JSON(http.StatusOK, rest.NewAPIResponse(http.StatusOK, &quot;Item quantity updated successfully&quot;, nil))&#13;&#10;&#9;}&#13;&#10;}&#13;&#10;&#13;&#10;func (c *CartController) RemoveItemFromCart() func(c *gin.Context) {&#13;&#10;&#9;return func(ctx *gin.Context) {&#13;&#10;&#9;&#9;itemID := ctx.Param(&quot;item_id&quot;)&#13;&#10;&#9;&#9;itemIDInt, err := strconv.Atoi(itemID)&#13;&#10;&#9;&#9;if err != nil {&#13;&#10;&#9;&#9;&#9;ctx.JSON(http.StatusBadRequest, rest.NewErrorResponse(rest.BadRequestError, &quot;Invalid item ID format&quot;))&#13;&#10;&#9;&#9;&#9;return&#13;&#10;&#9;&#9;}&#13;&#10;&#13;&#10;&#9;&#9;userID, err := c.getUserIDFromContext(ctx)&#13;&#10;&#9;&#9;if err != nil {&#13;&#10;&#9;&#9;&#9;ctx.JSON(http.StatusUnauthorized, rest.NewErrorResponse(rest.UnauthorizedError, err.Error()))&#13;&#10;&#9;&#9;&#9;return&#13;&#10;&#9;&#9;}&#13;&#10;&#13;&#10;&#9;&#9;if err := c.cartService.RemoveItemFromCart(userID, int64(itemIDInt)); err != nil {&#13;&#10;&#9;&#9;&#9;c.handleCartError(ctx, err)&#13;&#10;&#9;&#9;&#9;return&#13;&#10;&#9;&#9;}&#13;&#10;&#13;&#10;&#9;&#9;ctx.JSON(http.StatusOK, rest.NewAPIResponse(http.StatusOK, &quot;Item removed from cart successfully&quot;, nil))&#13;&#10;&#9;}&#13;&#10;}&#13;&#10;&#13;&#10;func (c *CartController) getUserIDFromContext(ctx *gin.Context) (int64, error) {&#13;&#10;&#9;userID, exists := ctx.Get(&quot;user_id&quot;)&#13;&#10;&#9;if !exists {&#13;&#10;&#9;&#9;return 0, errors.New(&quot;user ID not found in context&quot;)&#13;&#10;&#9;}&#13;&#10;&#13;&#10;&#9;userIDInt64, ok := userID.(int64)&#13;&#10;&#9;if !ok {&#13;&#10;&#9;&#9;return 0, errors.New(&quot;invalid user ID type&quot;)&#13;&#10;&#9;}&#13;&#10;&#13;&#10;&#9;return userIDInt64, nil&#13;&#10;}&#13;&#10;&#13;&#10;func (c *CartController) handleCartError(ctx *gin.Context, err error) {&#13;&#10;&#9;switch {&#13;&#10;&#9;case errors.Is(err, customErr.ErrCartNotFound):&#13;&#10;&#9;&#9;ctx.JSON(http.StatusNotFound, rest.NewErrorResponse(rest.NotFoundError, err.Error()))&#13;&#10;&#9;case errors.Is(err, customErr.ErrCartItemNotFound):&#13;&#10;&#9;&#9;ctx.JSON(http.StatusNotFound, rest.NewErrorResponse(rest.NotFoundError, err.Error()))&#13;&#10;&#9;case errors.Is(err, customErr.ErrCartItemAlreadyExists):&#13;&#10;&#9;&#9;ctx.JSON(http.StatusConflict, rest.NewErrorResponse(rest.ConflictError, err.Error()))&#13;&#10;&#9;default:&#13;&#10;&#9;&#9;ctx.JSON(http.StatusInternalServerError, rest.NewErrorResponse(rest.InternalServerErrorError, &quot;An unexpected error occurred&quot;))&#13;&#10;&#9;}&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/internal/services/identity/internal/client/cart_client.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/internal/services/identity/internal/client/cart_client.go" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/internal/services/identity/internal/config/config.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/internal/services/identity/internal/config/config.go" />
              <option name="originalContent" value="package config&#10;&#10;import (&#10;&#9;&quot;fmt&quot;&#10;&#9;&quot;os&quot;&#10;&#9;&quot;time&quot;&#10;&#10;&#9;&quot;github.com/joho/godotenv&quot;&#10;)&#10;&#10;type AppConfig struct {&#10;&#9;// Database Configuration&#10;&#9;DBHost     string&#10;&#9;DBPort     string&#10;&#9;DBUser     string&#10;&#9;DBPassword string&#10;&#9;DBName     string&#10;&#9;DBSSLMode  string&#10;&#10;&#9;// JWT Configuration&#10;&#9;JWTSecret           string&#10;&#9;JWTExpiresIn        time.Duration&#10;&#9;JWTRefreshExpiresIn time.Duration&#10;&#10;&#9;// Server Configuration&#10;&#9;ServerPort string&#10;&#9;ServerHost string&#10;&#10;&#9;// Log Configuration&#10;&#9;LogLevel string&#10;&#10;&#9;// Redis Configuration&#10;&#9;RedisHost     string&#10;&#9;RedisPort     string&#10;&#9;RedisPassword string&#10;&#10;&#9;// Environment&#10;&#9;Environment string&#10;}&#10;&#10;func LoadConfig(filename string) (*AppConfig, error) {&#10;&#9;// Load .env file in development&#10;&#9;if os.Getenv(&quot;ENV&quot;) != &quot;production&quot; {&#10;&#9;&#9;err := godotenv.Load(filename)&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;// Don't fail if .env file doesn't exist&#10;&#9;&#9;&#9;fmt.Println(&quot;Warning: .env file not found, using system environment variables&quot;)&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;config := &amp;AppConfig{&#10;&#9;&#9;DBHost:     getEnv(&quot;DB_HOST&quot;, &quot;localhost&quot;),&#10;&#9;&#9;DBPort:     getEnv(&quot;DB_PORT&quot;, &quot;5432&quot;),&#10;&#9;&#9;DBUser:     getEnv(&quot;DB_USER&quot;, &quot;postgres&quot;),&#10;&#9;&#9;DBPassword: getEnv(&quot;DB_PASSWORD&quot;, &quot;&quot;),&#10;&#9;&#9;DBName:     getEnv(&quot;DB_NAME&quot;, &quot;go_store_identity&quot;),&#10;&#9;&#9;DBSSLMode:  getEnv(&quot;DB_SSL_MODE&quot;, &quot;disable&quot;),&#10;&#10;&#9;&#9;JWTSecret:           getEnv(&quot;JWT_SECRET&quot;, &quot;&quot;),&#10;&#9;&#9;JWTExpiresIn:        time.Hour * 24,      // Default to 24 hours&#10;&#9;&#9;JWTRefreshExpiresIn: time.Hour * 24 * 30, // Default to 30 days&#10;&#10;&#9;&#9;ServerPort: getEnv(&quot;SERVER_PORT&quot;, &quot;8080&quot;),&#10;&#9;&#9;ServerHost: getEnv(&quot;SERVER_HOST&quot;, &quot;localhost&quot;),&#10;&#10;&#9;&#9;LogLevel: getEnv(&quot;LOG_LEVEL&quot;, &quot;info&quot;),&#10;&#10;&#9;&#9;RedisHost:     getEnv(&quot;REDIS_HOST&quot;, &quot;localhost&quot;),&#10;&#9;&#9;RedisPort:     getEnv(&quot;REDIS_PORT&quot;, &quot;6379&quot;),&#10;&#9;&#9;RedisPassword: getEnv(&quot;REDIS_PASSWORD&quot;, &quot;&quot;),&#10;&#10;&#9;&#9;Environment: getEnv(&quot;ENV&quot;, &quot;development&quot;),&#10;&#9;}&#10;&#10;&#9;// Validate required fields&#10;&#9;if err := config.validate(); err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;return config, nil&#10;}&#10;&#10;func (c *AppConfig) validate() error {&#10;&#9;if c.JWTSecret == &quot;&quot; {&#10;&#9;&#9;return fmt.Errorf(&quot;JWT_SECRET is required&quot;)&#10;&#9;}&#10;&#10;&#9;if len(c.JWTSecret) &lt; 32 {&#10;&#9;&#9;return fmt.Errorf(&quot;JWT_SECRET must be at least 32 characters long&quot;)&#10;&#9;}&#10;&#10;&#9;if c.DBPassword == &quot;&quot; {&#10;&#9;&#9;return fmt.Errorf(&quot;DB_PASSWORD is required&quot;)&#10;&#9;}&#10;&#10;&#9;return nil&#10;}&#10;&#10;func (c *AppConfig) GetDatabaseURL() string {&#10;&#9;return fmt.Sprintf(&quot;host=%s user=%s password=%s dbname=%s port=%s sslmode=%s TimeZone=Asia/Shanghai&quot;,&#10;&#9;&#9;c.DBHost, c.DBUser, c.DBPassword, c.DBName, c.DBPort, c.DBSSLMode)&#10;}&#10;&#10;func (c *AppConfig) GetServerAddress() string {&#10;&#9;return fmt.Sprintf(&quot;%s:%s&quot;, c.ServerHost, c.ServerPort)&#10;}&#10;&#10;func (c *AppConfig) IsProduction() bool {&#10;&#9;return c.Environment == &quot;production&quot;&#10;}&#10;&#10;// getEnv gets environment variable with fallback&#10;func getEnv(key, fallback string) string {&#10;&#9;if value := os.Getenv(key); value != &quot;&quot; {&#10;&#9;&#9;return value&#10;&#9;}&#10;&#9;return fallback&#10;}&#10;" />
              <option name="updatedContent" value="package config&#13;&#10;&#13;&#10;import (&#13;&#10;&#9;&quot;fmt&quot;&#13;&#10;&#9;&quot;os&quot;&#13;&#10;&#9;&quot;time&quot;&#13;&#10;&#13;&#10;&#9;&quot;github.com/joho/godotenv&quot;&#13;&#10;)&#13;&#10;&#13;&#10;type AppConfig struct {&#13;&#10;&#9;// Database Configuration&#13;&#10;&#9;DBHost     string&#13;&#10;&#9;DBPort     string&#13;&#10;&#9;DBUser     string&#13;&#10;&#9;DBPassword string&#13;&#10;&#9;DBName     string&#13;&#10;&#9;DBSSLMode  string&#13;&#10;&#13;&#10;&#9;// JWT Configuration&#13;&#10;&#9;JWTSecret           string&#13;&#10;&#9;JWTExpiresIn        time.Duration&#13;&#10;&#9;JWTRefreshExpiresIn time.Duration&#13;&#10;&#13;&#10;&#9;// Server Configuration&#13;&#10;&#9;ServerPort string&#13;&#10;&#9;ServerHost string&#13;&#10;&#13;&#10;&#9;// Log Configuration&#13;&#10;&#9;LogLevel string&#13;&#10;&#13;&#10;&#9;// Redis Configuration&#13;&#10;&#9;RedisHost     string&#13;&#10;&#9;RedisPort     string&#13;&#10;&#9;RedisPassword string&#13;&#10;&#13;&#10;&#9;// External Services&#13;&#10;&#9;CartServiceURL string&#13;&#10;&#13;&#10;&#9;// Environment&#13;&#10;&#9;Environment string&#13;&#10;}&#13;&#10;&#13;&#10;func LoadConfig(filename string) (*AppConfig, error) {&#13;&#10;&#9;// Load .env file in development&#13;&#10;&#9;if os.Getenv(&quot;ENV&quot;) != &quot;production&quot; {&#13;&#10;&#9;&#9;err := godotenv.Load(filename)&#13;&#10;&#9;&#9;if err != nil {&#13;&#10;&#9;&#9;&#9;// Don't fail if .env file doesn't exist&#13;&#10;&#9;&#9;&#9;fmt.Println(&quot;Warning: .env file not found, using system environment variables&quot;)&#13;&#10;&#9;&#9;}&#13;&#10;&#9;}&#13;&#10;&#13;&#10;&#9;config := &amp;AppConfig{&#13;&#10;&#9;&#9;DBHost:     getEnv(&quot;DB_HOST&quot;, &quot;localhost&quot;),&#13;&#10;&#9;&#9;DBPort:     getEnv(&quot;DB_PORT&quot;, &quot;5432&quot;),&#13;&#10;&#9;&#9;DBUser:     getEnv(&quot;DB_USER&quot;, &quot;postgres&quot;),&#13;&#10;&#9;&#9;DBPassword: getEnv(&quot;DB_PASSWORD&quot;, &quot;&quot;),&#13;&#10;&#9;&#9;DBName:     getEnv(&quot;DB_NAME&quot;, &quot;go_store_identity&quot;),&#13;&#10;&#9;&#9;DBSSLMode:  getEnv(&quot;DB_SSL_MODE&quot;, &quot;disable&quot;),&#13;&#10;&#13;&#10;&#9;&#9;JWTSecret:           getEnv(&quot;JWT_SECRET&quot;, &quot;&quot;),&#13;&#10;&#9;&#9;JWTExpiresIn:        time.Hour * 24,      // Default to 24 hours&#13;&#10;&#9;&#9;JWTRefreshExpiresIn: time.Hour * 24 * 30, // Default to 30 days&#13;&#10;&#13;&#10;&#9;&#9;ServerPort: getEnv(&quot;SERVER_PORT&quot;, &quot;8080&quot;),&#13;&#10;&#9;&#9;ServerHost: getEnv(&quot;SERVER_HOST&quot;, &quot;localhost&quot;),&#13;&#10;&#13;&#10;&#9;&#9;LogLevel: getEnv(&quot;LOG_LEVEL&quot;, &quot;info&quot;),&#13;&#10;&#13;&#10;&#9;&#9;RedisHost:     getEnv(&quot;REDIS_HOST&quot;, &quot;localhost&quot;),&#13;&#10;&#9;&#9;RedisPort:     getEnv(&quot;REDIS_PORT&quot;, &quot;6379&quot;),&#13;&#10;&#9;&#9;RedisPassword: getEnv(&quot;REDIS_PASSWORD&quot;, &quot;&quot;),&#13;&#10;&#13;&#10;&#9;&#9;CartServiceURL: getEnv(&quot;CART_SERVICE_URL&quot;, &quot;&quot;),&#13;&#10;&#13;&#10;&#9;&#9;Environment: getEnv(&quot;ENV&quot;, &quot;development&quot;),&#13;&#10;&#9;}&#13;&#10;&#13;&#10;&#9;// Validate required fields&#13;&#10;&#9;if err := config.validate(); err != nil {&#13;&#10;&#9;&#9;return nil, err&#13;&#10;&#9;}&#13;&#10;&#13;&#10;&#9;return config, nil&#13;&#10;}&#13;&#10;&#13;&#10;func (c *AppConfig) validate() error {&#13;&#10;&#9;if c.JWTSecret == &quot;&quot; {&#13;&#10;&#9;&#9;return fmt.Errorf(&quot;JWT_SECRET is required&quot;)&#13;&#10;&#9;}&#13;&#10;&#13;&#10;&#9;if len(c.JWTSecret) &lt; 32 {&#13;&#10;&#9;&#9;return fmt.Errorf(&quot;JWT_SECRET must be at least 32 characters long&quot;)&#13;&#10;&#9;}&#13;&#10;&#13;&#10;&#9;if c.DBPassword == &quot;&quot; {&#13;&#10;&#9;&#9;return fmt.Errorf(&quot;DB_PASSWORD is required&quot;)&#13;&#10;&#9;}&#13;&#10;&#13;&#10;&#9;return nil&#13;&#10;}&#13;&#10;&#13;&#10;func (c *AppConfig) GetDatabaseURL() string {&#13;&#10;&#9;return fmt.Sprintf(&quot;host=%s user=%s password=%s dbname=%s port=%s sslmode=%s TimeZone=Asia/Shanghai&quot;,&#13;&#10;&#9;&#9;c.DBHost, c.DBUser, c.DBPassword, c.DBName, c.DBPort, c.DBSSLMode)&#13;&#10;}&#13;&#10;&#13;&#10;func (c *AppConfig) GetServerAddress() string {&#13;&#10;&#9;return fmt.Sprintf(&quot;%s:%s&quot;, c.ServerHost, c.ServerPort)&#13;&#10;}&#13;&#10;&#13;&#10;func (c *AppConfig) IsProduction() bool {&#13;&#10;&#9;return c.Environment == &quot;production&quot;&#13;&#10;}&#13;&#10;&#13;&#10;// getEnv gets environment variable with fallback&#13;&#10;func getEnv(key, fallback string) string {&#13;&#10;&#9;if value := os.Getenv(key); value != &quot;&quot; {&#13;&#10;&#9;&#9;return value&#13;&#10;&#9;}&#13;&#10;&#9;return fallback&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/internal/services/identity/internal/dto/request/refresh_token_request.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/internal/services/identity/internal/dto/request/refresh_token_request.go" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>