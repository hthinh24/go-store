<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/.gitignore">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/.gitignore" />
              <option name="originalContent" value="# env files&#10;*.env&#10;&#10;docs/" />
              <option name="updatedContent" value="# env files&#13;&#10;*.env&#13;&#10;&#13;&#10;# Binaries for programs and plugins&#13;&#10;*.exe&#13;&#10;*.exe~&#13;&#10;*.dll&#13;&#10;*.so&#13;&#10;*.dylib&#13;&#10;&#13;&#10;# Test binary, built with `go test -c`&#13;&#10;*.test&#13;&#10;&#13;&#10;# Output of the go coverage tool, specifically when used with LiteIDE&#13;&#10;*.out&#13;&#10;&#13;&#10;# Go workspace file&#13;&#10;go.work&#13;&#10;&#13;&#10;# IDE files (IntelliJ IDEA)&#13;&#10;.idea/&#13;&#10;*.iws&#13;&#10;*.iml&#13;&#10;*.ipr&#13;&#10;&#13;&#10;# VS Code&#13;&#10;.vscode/&#13;&#10;&#13;&#10;# Temporary files&#13;&#10;*.tmp&#13;&#10;*.temp&#13;&#10;*.log&#13;&#10;&#13;&#10;docs/" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/internal/pkg/auth/auth_middleware.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/internal/pkg/auth/auth_middleware.go" />
              <option name="updatedContent" value="package auth&#10;&#10;import (&#10;&#9;&quot;net/http&quot;&#10;&#9;&quot;strings&quot;&#10;&#9;&quot;time&quot;&#10;&#10;&#9;&quot;github.com/gin-gonic/gin&quot;&#10;&#9;&quot;github.com/golang-jwt/jwt/v4&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/internal/pkg/logger&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/internal/pkg/rest&quot;&#10;)&#10;&#10;type SharedAuthMiddleware struct {&#10;&#9;logger    logger.Logger&#10;&#9;jwtSecret string&#10;}&#10;&#10;type JWTClaims struct {&#10;&#9;UserID           int64     `json:&quot;user_id&quot;`&#10;&#9;Email            string    `json:&quot;email&quot;`&#10;&#9;Roles            []string  `json:&quot;roles&quot;`&#10;&#9;Permissions      []string  `json:&quot;permissions&quot;`&#10;&#9;RefreshExpiresAt time.Time `json:&quot;refresh_expires_at&quot;`&#10;&#9;jwt.RegisteredClaims&#10;}&#10;&#10;func NewSharedAuthMiddleware(logger logger.Logger, jwtSecret string) *SharedAuthMiddleware {&#10;&#9;return &amp;SharedAuthMiddleware{&#10;&#9;&#9;logger:    logger,&#10;&#9;&#9;jwtSecret: jwtSecret,&#10;&#9;}&#10;}&#10;&#10;// AuthRequired validates JWT token and sets user info in context&#10;func (m *SharedAuthMiddleware) AuthRequired() gin.HandlerFunc {&#10;&#9;return func(c *gin.Context) {&#10;&#9;&#9;authHeader := c.GetHeader(&quot;Authorization&quot;)&#10;&#9;&#9;if authHeader == &quot;&quot; {&#10;&#9;&#9;&#9;c.JSON(http.StatusUnauthorized, rest.ErrorResponse{&#10;&#9;&#9;&#9;&#9;ApiError: rest.UnauthorizedError,&#10;&#9;&#9;&#9;&#9;Message:  &quot;Authorization header required&quot;,&#10;&#9;&#9;&#9;})&#10;&#9;&#9;&#9;c.Abort()&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#10;&#9;&#9;tokenString := strings.TrimPrefix(authHeader, &quot;Bearer &quot;)&#10;&#9;&#9;if tokenString == authHeader {&#10;&#9;&#9;&#9;c.JSON(http.StatusUnauthorized, rest.ErrorResponse{&#10;&#9;&#9;&#9;&#9;ApiError: rest.UnauthorizedError,&#10;&#9;&#9;&#9;&#9;Message:  &quot;Bearer token required&quot;,&#10;&#9;&#9;&#9;})&#10;&#9;&#9;&#9;c.Abort()&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#10;&#9;&#9;claims, err := m.validateToken(tokenString)&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;m.logger.Error(&quot;Failed to validate JWT token&quot;, &quot;error&quot;, err)&#10;&#9;&#9;&#9;c.JSON(http.StatusUnauthorized, rest.ErrorResponse{&#10;&#9;&#9;&#9;&#9;ApiError: rest.UnauthorizedError,&#10;&#9;&#9;&#9;&#9;Message:  &quot;Invalid token&quot;,&#10;&#9;&#9;&#9;})&#10;&#9;&#9;&#9;c.Abort()&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// Set user info in context for all services to use&#10;&#9;&#9;c.Set(&quot;user_id&quot;, claims.UserID)&#10;&#9;&#9;c.Set(&quot;email&quot;, claims.Email)&#10;&#9;&#9;c.Set(&quot;roles&quot;, claims.Roles)&#10;&#9;&#9;c.Set(&quot;permissions&quot;, claims.Permissions)&#10;&#10;&#9;&#9;c.Next()&#10;&#9;}&#10;}&#10;&#10;// RequirePermissions checks if user has ALL specified permissions&#10;func (m *SharedAuthMiddleware) RequirePermissions(requiredPermissions ...string) gin.HandlerFunc {&#10;&#9;return func(c *gin.Context) {&#10;&#9;&#9;permissions, exists := c.Get(&quot;permissions&quot;)&#10;&#9;&#9;if !exists {&#10;&#9;&#9;&#9;c.JSON(http.StatusUnauthorized, rest.ErrorResponse{&#10;&#9;&#9;&#9;&#9;ApiError: rest.UnauthorizedError,&#10;&#9;&#9;&#9;&#9;Message:  &quot;User not authenticated&quot;,&#10;&#9;&#9;&#9;})&#10;&#9;&#9;&#9;c.Abort()&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#10;&#9;&#9;userPermissions := permissions.([]string)&#10;&#9;&#9;userPermMap := make(map[string]bool)&#10;&#9;&#9;for _, perm := range userPermissions {&#10;&#9;&#9;&#9;userPermMap[perm] = true&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// Check if user has all required permissions&#10;&#9;&#9;for _, requiredPerm := range requiredPermissions {&#10;&#9;&#9;&#9;if !userPermMap[requiredPerm] {&#10;&#9;&#9;&#9;&#9;m.logger.Warn(&quot;Access denied - missing permission&quot;, &#10;&#9;&#9;&#9;&#9;&#9;&quot;user_id&quot;, c.Get(&quot;user_id&quot;), &#10;&#9;&#9;&#9;&#9;&#9;&quot;required_permission&quot;, requiredPerm)&#10;&#9;&#9;&#9;&#9;c.JSON(http.StatusForbidden, rest.ErrorResponse{&#10;&#9;&#9;&#9;&#9;&#9;ApiError: rest.ForbiddenError,&#10;&#9;&#9;&#9;&#9;&#9;Message:  &quot;Insufficient permissions&quot;,&#10;&#9;&#9;&#9;&#9;})&#10;&#9;&#9;&#9;&#9;c.Abort()&#10;&#9;&#9;&#9;&#9;return&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#10;&#9;&#9;c.Next()&#10;&#9;}&#10;}&#10;&#10;// RequireAnyPermission checks if user has ANY of the specified permissions&#10;func (m *SharedAuthMiddleware) RequireAnyPermission(permissions ...string) gin.HandlerFunc {&#10;&#9;return func(c *gin.Context) {&#10;&#9;&#9;userPermissions, exists := c.Get(&quot;permissions&quot;)&#10;&#9;&#9;if !exists {&#10;&#9;&#9;&#9;c.JSON(http.StatusUnauthorized, rest.ErrorResponse{&#10;&#9;&#9;&#9;&#9;ApiError: rest.UnauthorizedError,&#10;&#9;&#9;&#9;&#9;Message:  &quot;User not authenticated&quot;,&#10;&#9;&#9;&#9;})&#10;&#9;&#9;&#9;c.Abort()&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#10;&#9;&#9;userPerms := userPermissions.([]string)&#10;&#9;&#9;for _, userPerm := range userPerms {&#10;&#9;&#9;&#9;for _, requiredPerm := range permissions {&#10;&#9;&#9;&#9;&#9;if userPerm == requiredPerm {&#10;&#9;&#9;&#9;&#9;&#9;c.Next()&#10;&#9;&#9;&#9;&#9;&#9;return&#10;&#9;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#10;&#9;&#9;c.JSON(http.StatusForbidden, rest.ErrorResponse{&#10;&#9;&#9;&#9;ApiError: rest.ForbiddenError,&#10;&#9;&#9;&#9;Message:  &quot;Insufficient permissions&quot;,&#10;&#9;&#9;})&#10;&#9;&#9;c.Abort()&#10;&#9;}&#10;}&#10;&#10;// RequireRole checks if user has specific role&#10;func (m *SharedAuthMiddleware) RequireRole(role string) gin.HandlerFunc {&#10;&#9;return func(c *gin.Context) {&#10;&#9;&#9;roles, exists := c.Get(&quot;roles&quot;)&#10;&#9;&#9;if !exists {&#10;&#9;&#9;&#9;c.JSON(http.StatusUnauthorized, rest.ErrorResponse{&#10;&#9;&#9;&#9;&#9;ApiError: rest.UnauthorizedError,&#10;&#9;&#9;&#9;&#9;Message:  &quot;User not authenticated&quot;,&#10;&#9;&#9;&#9;})&#10;&#9;&#9;&#9;c.Abort()&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#10;&#9;&#9;userRoles := roles.([]string)&#10;&#9;&#9;for _, userRole := range userRoles {&#10;&#9;&#9;&#9;if userRole == role {&#10;&#9;&#9;&#9;&#9;c.Next()&#10;&#9;&#9;&#9;&#9;return&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#10;&#9;&#9;c.JSON(http.StatusForbidden, rest.ErrorResponse{&#10;&#9;&#9;&#9;ApiError: rest.ForbiddenError,&#10;&#9;&#9;&#9;Message:  &quot;Insufficient role permissions&quot;,&#10;&#9;&#9;})&#10;&#9;&#9;c.Abort()&#10;&#9;}&#10;}&#10;&#10;func (m *SharedAuthMiddleware) validateToken(tokenString string) (*JWTClaims, error) {&#10;&#9;token, err := jwt.ParseWithClaims(tokenString, &amp;JWTClaims{}, func(token *jwt.Token) (interface{}, error) {&#10;&#9;&#9;return []byte(m.jwtSecret), nil&#10;&#9;})&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;claims, ok := token.Claims.(*JWTClaims)&#10;&#9;if !ok {&#10;&#9;&#9;return nil, jwt.ErrTokenMalformed&#10;&#9;}&#10;&#10;&#9;now := time.Now()&#10;&#10;&#9;// Check if refresh token is expired (hard expiration)&#10;&#9;if !claims.RefreshExpiresAt.IsZero() &amp;&amp; now.After(claims.RefreshExpiresAt) {&#10;&#9;&#9;m.logger.Warn(&quot;Refresh token has expired&quot;, &quot;user_id&quot;, claims.UserID)&#10;&#9;&#9;return nil, jwt.NewValidationError(&quot;refresh token expired&quot;, jwt.ValidationErrorExpired)&#10;&#9;}&#10;&#10;&#9;// Check if access token is expired&#10;&#9;if claims.ExpiresAt != nil &amp;&amp; now.After(claims.ExpiresAt.Time) {&#10;&#9;&#9;m.logger.Info(&quot;Access token expired&quot;, &quot;user_id&quot;, claims.UserID)&#10;&#9;&#9;return nil, jwt.NewValidationError(&quot;access token expired&quot;, jwt.ValidationErrorExpired)&#10;&#9;}&#10;&#10;&#9;// Check not before&#10;&#9;if claims.NotBefore != nil &amp;&amp; now.Before(claims.NotBefore.Time) {&#10;&#9;&#9;return nil, jwt.NewValidationError(&quot;token used before valid&quot;, jwt.ValidationErrorNotValidYet)&#10;&#9;}&#10;&#10;&#9;// Check issued at&#10;&#9;if claims.IssuedAt != nil &amp;&amp; now.Before(claims.IssuedAt.Time) {&#10;&#9;&#9;return nil, jwt.NewValidationError(&quot;token issued in the future&quot;, jwt.ValidationErrorIssuedAt)&#10;&#9;}&#10;&#10;&#9;return claims, nil&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/internal/pkg/config/pg/pg.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/internal/pkg/config/pg/pg.go" />
              <option name="updatedContent" value="package pg&#10;&#10;import &quot;fmt&quot;&#10;&#10;// PG holds PostgreSQL database configuration&#10;type PG struct {&#10;&#9;Host            string `mapstructure:&quot;host&quot; env:&quot;PG_HOST&quot;`&#10;&#9;Port            string `mapstructure:&quot;port&quot; env:&quot;PG_PORT&quot;`&#10;&#9;User            string `mapstructure:&quot;user&quot; env:&quot;PG_USER&quot;`&#10;&#9;Password        string `mapstructure:&quot;password&quot; env:&quot;PG_PASSWORD&quot;`&#10;&#9;Database        string `mapstructure:&quot;database&quot; env:&quot;PG_DATABASE&quot;`&#10;&#9;SSLMode         string `mapstructure:&quot;ssl_mode&quot; env:&quot;PG_SSL_MODE&quot;`&#10;&#9;MaxOpenConns    int    `mapstructure:&quot;max_open_conns&quot; env:&quot;PG_MAX_OPEN_CONNS&quot;`&#10;&#9;MaxIdleConns    int    `mapstructure:&quot;max_idle_conns&quot; env:&quot;PG_MAX_IDLE_CONNS&quot;`&#10;&#9;ConnMaxLifetime int    `mapstructure:&quot;conn_max_lifetime&quot; env:&quot;PG_CONN_MAX_LIFETIME&quot;`&#10;&#9;ConnMaxIdleTime int    `mapstructure:&quot;conn_max_idle_time&quot; env:&quot;PG_CONN_MAX_IDLE_TIME&quot;`&#10;}&#10;&#10;// GetDSN returns the PostgreSQL connection string&#10;func (p *PG) GetDSN() string {&#10;&#9;return fmt.Sprintf(&quot;host=%s port=%s user=%s password=%s dbname=%s sslmode=%s&quot;,&#10;&#9;&#9;p.Host, p.Port, p.User, p.Password, p.Database, p.SSLMode)&#10;}&#10;&#10;// IsValid checks if all required PostgreSQL fields are set&#10;func (p *PG) IsValid() bool {&#10;&#9;return p.Host != &quot;&quot; &amp;&amp; p.Port != &quot;&quot; &amp;&amp; p.User != &quot;&quot; &amp;&amp; p.Database != &quot;&quot;&#10;}&#10;&#10;// SetDefaults sets default values for PostgreSQL configuration&#10;func (p *PG) SetDefaults() {&#10;&#9;if p.Host == &quot;&quot; {&#10;&#9;&#9;p.Host = &quot;localhost&quot;&#10;&#9;}&#10;&#9;if p.Port == &quot;&quot; {&#10;&#9;&#9;p.Port = &quot;5432&quot;&#10;&#9;}&#10;&#9;if p.SSLMode == &quot;&quot; {&#10;&#9;&#9;p.SSLMode = &quot;disable&quot;&#10;&#9;}&#10;&#9;if p.MaxOpenConns == 0 {&#10;&#9;&#9;p.MaxOpenConns = 25&#10;&#9;}&#10;&#9;if p.MaxIdleConns == 0 {&#10;&#9;&#9;p.MaxIdleConns = 10&#10;&#9;}&#10;&#9;if p.ConnMaxLifetime == 0 {&#10;&#9;&#9;p.ConnMaxLifetime = 300 // 5 minutes in seconds&#10;&#9;}&#10;&#9;if p.ConnMaxIdleTime == 0 {&#10;&#9;&#9;p.ConnMaxIdleTime = 60 // 1 minute in seconds&#10;&#9;}&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/internal/pkg/config/services.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/internal/pkg/config/services.go" />
              <option name="originalContent" value="package config&#10;&#10;// Services holds URLs for inter-service communication&#10;type Services struct {&#10;&#9;UserServiceURL         string `mapstructure:&quot;user_service_url&quot; env:&quot;USER_SERVICE_URL&quot;`&#10;&#9;ProductServiceURL      string `mapstructure:&quot;product_service_url&quot; env:&quot;PRODUCT_SERVICE_URL&quot;`&#10;&#9;CartServiceURL         string `mapstructure:&quot;cart_service_url&quot; env:&quot;CART_SERVICE_URL&quot;`&#10;&#9;OrderServiceURL        string `mapstructure:&quot;order_service_url&quot; env:&quot;ORDER_SERVICE_URL&quot;`&#10;&#9;GatewayServiceURL      string `mapstructure:&quot;gateway_service_url&quot; env:&quot;GATEWAY_SERVICE_URL&quot;`&#10;&#9;NotificationServiceURL string `mapstructure:&quot;notification_service_url&quot; env:&quot;NOTIFICATION_SERVICE_URL&quot;`&#10;&#9;PaymentServiceURL      string `mapstructure:&quot;payment_service_url&quot; env:&quot;PAYMENT_SERVICE_URL&quot;`&#10;}&#10;&#10;// GetServiceURL returns the URL for a specific service&#10;func (s *Services) GetServiceURL(serviceName string) string {&#10;&#9;switch serviceName {&#10;&#9;case &quot;user&quot;, &quot;identity&quot;:&#10;&#9;&#9;return s.UserServiceURL&#10;&#9;case &quot;product&quot;:&#10;&#9;&#9;return s.ProductServiceURL&#10;&#9;case &quot;cart&quot;:&#10;&#9;&#9;return s.CartServiceURL&#10;&#9;case &quot;order&quot;:&#10;&#9;&#9;return s.OrderServiceURL&#10;&#9;case &quot;gateway&quot;:&#10;&#9;&#9;return s.GatewayServiceURL&#10;&#9;case &quot;notification&quot;:&#10;&#9;&#9;return s.NotificationServiceURL&#10;&#9;case &quot;payment&quot;:&#10;&#9;&#9;return s.PaymentServiceURL&#10;&#9;default:&#10;&#9;&#9;return &quot;&quot;&#10;&#9;}&#10;}&#10;&#10;// SetDefaults sets default service URLs based on standard ports&#10;func (s *Services) SetDefaults() {&#10;&#9;if s.UserServiceURL == &quot;&quot; {&#10;&#9;&#9;s.UserServiceURL = &quot;http://localhost:8080&quot;&#10;&#9;}&#10;&#9;if s.ProductServiceURL == &quot;&quot; {&#10;&#9;&#9;s.ProductServiceURL = &quot;http://localhost:8081&quot;&#10;&#9;}&#10;&#9;if s.CartServiceURL == &quot;&quot; {&#10;&#9;&#9;s.CartServiceURL = &quot;http://localhost:8082&quot;&#10;&#9;}&#10;&#9;if s.OrderServiceURL == &quot;&quot; {&#10;&#9;&#9;s.OrderServiceURL = &quot;http://localhost:8083&quot;&#10;&#9;}&#10;&#9;if s.GatewayServiceURL == &quot;&quot; {&#10;&#9;&#9;s.GatewayServiceURL = &quot;http://localhost:8000&quot;&#10;&#9;}&#10;}&#10;" />
              <option name="updatedContent" value="package config&#10;&#10;// Services holds URLs for inter-service communication&#10;type Services struct {&#10;&#9;IdentityServiceURL     string `mapstructure:&quot;identity_service_url&quot; env:&quot;IDENTITY_SERVICE_URL&quot;`&#10;&#9;ProductServiceURL      string `mapstructure:&quot;product_service_url&quot; env:&quot;PRODUCT_SERVICE_URL&quot;`&#10;&#9;CartServiceURL         string `mapstructure:&quot;cart_service_url&quot; env:&quot;CART_SERVICE_URL&quot;`&#10;&#9;OrderServiceURL        string `mapstructure:&quot;order_service_url&quot; env:&quot;ORDER_SERVICE_URL&quot;`&#10;&#9;GatewayServiceURL      string `mapstructure:&quot;gateway_service_url&quot; env:&quot;GATEWAY_SERVICE_URL&quot;`&#10;&#9;NotificationServiceURL string `mapstructure:&quot;notification_service_url&quot; env:&quot;NOTIFICATION_SERVICE_URL&quot;`&#10;&#9;PaymentServiceURL      string `mapstructure:&quot;payment_service_url&quot; env:&quot;PAYMENT_SERVICE_URL&quot;`&#10;}&#10;&#10;// GetServiceURL returns the URL for a specific service&#10;func (s *Services) GetServiceURL(serviceName string) string {&#10;&#9;switch serviceName {&#10;&#9;case &quot;user&quot;, &quot;identity&quot;:&#10;&#9;&#9;return s.IdentityServiceURL&#10;&#9;case &quot;product&quot;:&#10;&#9;&#9;return s.ProductServiceURL&#10;&#9;case &quot;cart&quot;:&#10;&#9;&#9;return s.CartServiceURL&#10;&#9;case &quot;order&quot;:&#10;&#9;&#9;return s.OrderServiceURL&#10;&#9;case &quot;gateway&quot;:&#10;&#9;&#9;return s.GatewayServiceURL&#10;&#9;case &quot;notification&quot;:&#10;&#9;&#9;return s.NotificationServiceURL&#10;&#9;case &quot;payment&quot;:&#10;&#9;&#9;return s.PaymentServiceURL&#10;&#9;default:&#10;&#9;&#9;return &quot;&quot;&#10;&#9;}&#10;}&#10;&#10;// SetDefaults sets default service URLs based on standard ports&#10;func (s *Services) SetDefaults() {&#10;&#9;if s.IdentityServiceURL == &quot;&quot; {&#10;&#9;&#9;s.IdentityServiceURL = &quot;http://localhost:8080&quot;&#10;&#9;}&#10;&#9;if s.ProductServiceURL == &quot;&quot; {&#10;&#9;&#9;s.ProductServiceURL = &quot;http://localhost:8081&quot;&#10;&#9;}&#10;&#9;if s.CartServiceURL == &quot;&quot; {&#10;&#9;&#9;s.CartServiceURL = &quot;http://localhost:8082&quot;&#10;&#9;}&#10;&#9;if s.OrderServiceURL == &quot;&quot; {&#10;&#9;&#9;s.OrderServiceURL = &quot;http://localhost:8083&quot;&#10;&#9;}&#10;&#9;if s.GatewayServiceURL == &quot;&quot; {&#10;&#9;&#9;s.GatewayServiceURL = &quot;http://localhost:8000&quot;&#10;&#9;}&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/internal/pkg/gateway/api_gateway.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/internal/pkg/gateway/api_gateway.go" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/internal/pkg/middleware/auth/auth_middleware.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/internal/pkg/middleware/auth/auth_middleware.go" />
              <option name="originalContent" value="package auth&#10;&#10;import (&#10;&#9;&quot;net/http&quot;&#10;&#9;&quot;strconv&quot;&#10;&#9;&quot;strings&quot;&#10;&#10;&#9;&quot;github.com/gin-gonic/gin&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/internal/pkg/logger&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/internal/pkg/rest&quot;&#10;)&#10;&#10;type SharedAuthMiddleware struct {&#10;&#9;logger logger.Logger&#10;}&#10;&#10;func NewSharedAuthMiddleware(logger logger.Logger) *SharedAuthMiddleware {&#10;&#9;return &amp;SharedAuthMiddleware{&#10;&#9;&#9;logger: logger,&#10;&#9;}&#10;}&#10;&#10;// AuthRequired checks if user is authenticated by validating headers set by gateway&#10;func (m *SharedAuthMiddleware) AuthRequired() gin.HandlerFunc {&#10;&#9;return func(c *gin.Context) {&#10;&#9;&#9;// Check if user_id header exists (set by gateway after JWT validation)&#10;&#9;&#9;userIDHeader := c.GetHeader(&quot;X-User-ID&quot;)&#10;&#9;&#9;if userIDHeader == &quot;&quot; {&#10;&#9;&#9;&#9;m.logger.Warn(&quot;User ID header missing&quot;, &quot;header&quot;, &quot;X-User-ID&quot;)&#10;&#9;&#9;&#9;c.JSON(http.StatusUnauthorized, rest.ErrorResponse{&#10;&#9;&#9;&#9;&#9;ApiError: rest.UnauthorizedError,&#10;&#9;&#9;&#9;&#9;Message:  &quot;User not authenticated&quot;,&#10;&#9;&#9;&#9;})&#10;&#9;&#9;&#9;c.Abort()&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// Parse user_id&#10;&#9;&#9;userID, err := strconv.ParseInt(userIDHeader, 10, 64)&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;m.logger.Error(&quot;Invalid user ID header, &quot;, &quot;user_id: &quot;, userIDHeader, &quot;, error: &quot;, err)&#10;&#9;&#9;&#9;c.JSON(http.StatusUnauthorized, rest.ErrorResponse{&#10;&#9;&#9;&#9;&#9;ApiError: rest.UnauthorizedError,&#10;&#9;&#9;&#9;&#9;Message:  &quot;Invalid user authentication&quot;,&#10;&#9;&#9;&#9;})&#10;&#9;&#9;&#9;c.Abort()&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// Get other user info from headers&#10;&#9;&#9;email := c.GetHeader(&quot;X-User-Email&quot;)&#10;&#9;&#9;rolesHeader := c.GetHeader(&quot;X-User-Roles&quot;)&#10;&#9;&#9;permissionsHeader := c.GetHeader(&quot;X-User-Permissions&quot;)&#10;&#10;&#9;&#9;// Parse roles and permissions (comma-separated strings)&#10;&#9;&#9;var roles []string&#10;&#9;&#9;if rolesHeader != &quot;&quot; {&#10;&#9;&#9;&#9;roles = strings.Split(rolesHeader, &quot;,&quot;)&#10;&#9;&#9;&#9;// Trim whitespace&#10;&#9;&#9;&#9;for i, role := range roles {&#10;&#9;&#9;&#9;&#9;roles[i] = strings.TrimSpace(role)&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#10;&#9;&#9;var permissions []string&#10;&#9;&#9;if permissionsHeader != &quot;&quot; {&#10;&#9;&#9;&#9;permissions = strings.Split(permissionsHeader, &quot;,&quot;)&#10;&#9;&#9;&#9;// Trim whitespace&#10;&#9;&#9;&#9;for i, perm := range permissions {&#10;&#9;&#9;&#9;&#9;permissions[i] = strings.TrimSpace(perm)&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// Set user info in context for services to use&#10;&#9;&#9;c.Set(&quot;user_id&quot;, userID)&#10;&#9;&#9;c.Set(&quot;email&quot;, email)&#10;&#9;&#9;c.Set(&quot;roles&quot;, roles)&#10;&#9;&#9;c.Set(&quot;permissions&quot;, permissions)&#10;&#10;&#9;&#9;c.Next()&#10;&#9;}&#10;}&#10;&#10;// RequirePermissions checks if user has ALL specified permissions&#10;func (m *SharedAuthMiddleware) RequirePermissions(requiredPermissions ...string) gin.HandlerFunc {&#10;&#9;return func(c *gin.Context) {&#10;&#9;&#9;permissions, exists := c.Get(&quot;permissions&quot;)&#10;&#9;&#9;if !exists {&#10;&#9;&#9;&#9;m.logger.Warn(&quot;Permissions not found in context, &quot;, &quot;context_key: &quot;, &quot;permissions&quot;)&#10;&#9;&#9;&#9;c.JSON(http.StatusUnauthorized, rest.ErrorResponse{&#10;&#9;&#9;&#9;&#9;ApiError: rest.UnauthorizedError,&#10;&#9;&#9;&#9;&#9;Message:  &quot;User not authenticated&quot;,&#10;&#9;&#9;&#9;})&#10;&#9;&#9;&#9;c.Abort()&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#10;&#9;&#9;userPermissions := permissions.([]string)&#10;&#9;&#9;userPermMap := make(map[string]bool)&#10;&#9;&#9;for _, perm := range userPermissions {&#10;&#9;&#9;&#9;userPermMap[perm] = true&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// Check if user has all required permissions&#10;&#9;&#9;for _, requiredPerm := range requiredPermissions {&#10;&#9;&#9;&#9;if !userPermMap[requiredPerm] {&#10;&#9;&#9;&#9;&#9;m.logger.Warn(&quot;Access denied - missing permission&quot;, &quot;required_permission&quot;,&#10;&#9;&#9;&#9;&#9;&#9;requiredPerm, &quot;user_permissions&quot;, userPermissions)&#10;&#9;&#9;&#9;&#9;c.JSON(http.StatusForbidden, rest.ErrorResponse{&#10;&#9;&#9;&#9;&#9;&#9;ApiError: rest.ForbiddenError,&#10;&#9;&#9;&#9;&#9;&#9;Message:  &quot;Insufficient permissions&quot;,&#10;&#9;&#9;&#9;&#9;})&#10;&#9;&#9;&#9;&#9;c.Abort()&#10;&#9;&#9;&#9;&#9;return&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#10;&#9;&#9;c.Next()&#10;&#9;}&#10;}&#10;&#10;// RequireAnyPermission checks if user has ANY of the specified permissions&#10;func (m *SharedAuthMiddleware) RequireAnyPermission(permissions ...string) gin.HandlerFunc {&#10;&#9;return func(c *gin.Context) {&#10;&#9;&#9;userPermissions, exists := c.Get(&quot;permissions&quot;)&#10;&#9;&#9;if !exists {&#10;&#9;&#9;&#9;m.logger.Warn(&quot;Permissions not found in context, &quot;, &quot;context_key&quot;, &quot;permissions&quot;)&#10;&#9;&#9;&#9;c.JSON(http.StatusUnauthorized, rest.ErrorResponse{&#10;&#9;&#9;&#9;&#9;ApiError: rest.UnauthorizedError,&#10;&#9;&#9;&#9;&#9;Message:  &quot;User not authenticated&quot;,&#10;&#9;&#9;&#9;})&#10;&#9;&#9;&#9;c.Abort()&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#10;&#9;&#9;userPerms := userPermissions.([]string)&#10;&#9;&#9;for _, userPerm := range userPerms {&#10;&#9;&#9;&#9;for _, requiredPerm := range permissions {&#10;&#9;&#9;&#9;&#9;if userPerm == requiredPerm {&#10;&#9;&#9;&#9;&#9;&#9;c.Next()&#10;&#9;&#9;&#9;&#9;&#9;return&#10;&#9;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#10;&#9;&#9;c.JSON(http.StatusForbidden, rest.ErrorResponse{&#10;&#9;&#9;&#9;ApiError: rest.ForbiddenError,&#10;&#9;&#9;&#9;Message:  &quot;Insufficient permissions&quot;,&#10;&#9;&#9;})&#10;&#9;&#9;c.Abort()&#10;&#9;}&#10;}&#10;&#10;// RequireRole checks if user has specific role&#10;func (m *SharedAuthMiddleware) RequireRole(role string) gin.HandlerFunc {&#10;&#9;return func(c *gin.Context) {&#10;&#9;&#9;roles, exists := c.Get(&quot;roles&quot;)&#10;&#9;&#9;if !exists {&#10;&#9;&#9;&#9;m.logger.Warn(&quot;Roles not found in context, &quot;, &quot;context_key: &quot;, &quot;roles&quot;)&#10;&#9;&#9;&#9;c.JSON(http.StatusUnauthorized, rest.ErrorResponse{&#10;&#9;&#9;&#9;&#9;ApiError: rest.UnauthorizedError,&#10;&#9;&#9;&#9;&#9;Message:  &quot;User not authenticated&quot;,&#10;&#9;&#9;&#9;})&#10;&#9;&#9;&#9;c.Abort()&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#10;&#9;&#9;userRoles := roles.([]string)&#10;&#9;&#9;for _, userRole := range userRoles {&#10;&#9;&#9;&#9;if userRole == role {&#10;&#9;&#9;&#9;&#9;c.Next()&#10;&#9;&#9;&#9;&#9;return&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#10;&#9;&#9;c.JSON(http.StatusForbidden, rest.ErrorResponse{&#10;&#9;&#9;&#9;ApiError: rest.ForbiddenError,&#10;&#9;&#9;&#9;Message:  &quot;Insufficient role permissions&quot;,&#10;&#9;&#9;})&#10;&#9;&#9;c.Abort()&#10;&#9;}&#10;}&#10;&#10;// RequireAnyRole checks if user has ANY of the specified roles&#10;func (m *SharedAuthMiddleware) RequireAnyRole(roles ...string) gin.HandlerFunc {&#10;&#9;return func(c *gin.Context) {&#10;&#9;&#9;userRoles, exists := c.Get(&quot;roles&quot;)&#10;&#9;&#9;if !exists {&#10;&#9;&#9;&#9;m.logger.Warn(&quot;Roles not found in context, &quot;, &quot;context_key: &quot;, &quot;roles&quot;)&#10;&#9;&#9;&#9;c.JSON(http.StatusUnauthorized, rest.ErrorResponse{&#10;&#9;&#9;&#9;&#9;ApiError: rest.UnauthorizedError,&#10;&#9;&#9;&#9;&#9;Message:  &quot;User not authenticated&quot;,&#10;&#9;&#9;&#9;})&#10;&#9;&#9;&#9;c.Abort()&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#10;&#9;&#9;userRolesList := userRoles.([]string)&#10;&#9;&#9;for _, userRole := range userRolesList {&#10;&#9;&#9;&#9;for _, requiredRole := range roles {&#10;&#9;&#9;&#9;&#9;if userRole == requiredRole {&#10;&#9;&#9;&#9;&#9;&#9;c.Next()&#10;&#9;&#9;&#9;&#9;&#9;return&#10;&#9;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#10;&#9;&#9;c.JSON(http.StatusForbidden, rest.ErrorResponse{&#10;&#9;&#9;&#9;ApiError: rest.ForbiddenError,&#10;&#9;&#9;&#9;Message:  &quot;Insufficient role permissions&quot;,&#10;&#9;&#9;})&#10;&#9;&#9;c.Abort()&#10;&#9;}&#10;}&#10;" />
              <option name="updatedContent" value="package auth&#13;&#10;&#13;&#10;import (&#13;&#10;&#9;&quot;net/http&quot;&#13;&#10;&#9;&quot;strconv&quot;&#13;&#10;&#9;&quot;strings&quot;&#13;&#10;&#13;&#10;&#9;&quot;github.com/gin-gonic/gin&quot;&#13;&#10;&#9;&quot;github.com/hthinh24/go-store/internal/pkg/logger&quot;&#13;&#10;&#9;&quot;github.com/hthinh24/go-store/internal/pkg/rest&quot;&#13;&#10;)&#13;&#10;&#13;&#10;type SharedAuthMiddleware struct {&#13;&#10;&#9;logger logger.Logger&#13;&#10;}&#13;&#10;&#13;&#10;func NewSharedAuthMiddleware(logger logger.Logger) *SharedAuthMiddleware {&#13;&#10;&#9;return &amp;SharedAuthMiddleware{&#13;&#10;&#9;&#9;logger: logger,&#13;&#10;&#9;}&#13;&#10;}&#13;&#10;&#13;&#10;// AuthRequired checks if user is authenticated by validating headers set by gateway&#13;&#10;func (m *SharedAuthMiddleware) AuthRequired() gin.HandlerFunc {&#13;&#10;&#9;return func(c *gin.Context) {&#13;&#10;&#9;&#9;// Check if user_id header exists (set by gateway after JWT validation)&#13;&#10;&#9;&#9;userIDHeader := c.GetHeader(&quot;X-User-ID&quot;)&#13;&#10;&#9;&#9;if userIDHeader == &quot;&quot; {&#13;&#10;&#9;&#9;&#9;m.logger.Warn(&quot;User ID header missing, header: &quot;, &quot;X-User-ID&quot;)&#13;&#10;&#9;&#9;&#9;c.JSON(http.StatusUnauthorized, rest.ErrorResponse{&#13;&#10;&#9;&#9;&#9;&#9;ApiError: rest.UnauthorizedError,&#13;&#10;&#9;&#9;&#9;&#9;Message:  &quot;User not authenticated&quot;,&#13;&#10;&#9;&#9;&#9;})&#13;&#10;&#9;&#9;&#9;c.Abort()&#13;&#10;&#9;&#9;&#9;return&#13;&#10;&#9;&#9;}&#13;&#10;&#13;&#10;&#9;&#9;// Parse user_id&#13;&#10;&#9;&#9;userID, err := strconv.ParseInt(userIDHeader, 10, 64)&#13;&#10;&#9;&#9;if err != nil {&#13;&#10;&#9;&#9;&#9;m.logger.Error(&quot;Invalid user ID header, &quot;, &quot;user_id: &quot;, userIDHeader, &quot;, error: &quot;, err)&#13;&#10;&#9;&#9;&#9;c.JSON(http.StatusUnauthorized, rest.ErrorResponse{&#13;&#10;&#9;&#9;&#9;&#9;ApiError: rest.UnauthorizedError,&#13;&#10;&#9;&#9;&#9;&#9;Message:  &quot;Invalid user authentication&quot;,&#13;&#10;&#9;&#9;&#9;})&#13;&#10;&#9;&#9;&#9;c.Abort()&#13;&#10;&#9;&#9;&#9;return&#13;&#10;&#9;&#9;}&#13;&#10;&#13;&#10;&#9;&#9;// Get other user info from headers&#13;&#10;&#9;&#9;email := c.GetHeader(&quot;X-User-Email&quot;)&#13;&#10;&#9;&#9;rolesHeader := c.GetHeader(&quot;X-User-Roles&quot;)&#13;&#10;&#9;&#9;permissionsHeader := c.GetHeader(&quot;X-User-Permissions&quot;)&#13;&#10;&#13;&#10;&#9;&#9;// Parse roles and permissions (comma-separated strings)&#13;&#10;&#9;&#9;var roles []string&#13;&#10;&#9;&#9;if rolesHeader != &quot;&quot; {&#13;&#10;&#9;&#9;&#9;roles = strings.Split(rolesHeader, &quot;,&quot;)&#13;&#10;&#9;&#9;&#9;// Trim whitespace&#13;&#10;&#9;&#9;&#9;for i, role := range roles {&#13;&#10;&#9;&#9;&#9;&#9;roles[i] = strings.TrimSpace(role)&#13;&#10;&#9;&#9;&#9;}&#13;&#10;&#9;&#9;}&#13;&#10;&#13;&#10;&#9;&#9;var permissions []string&#13;&#10;&#9;&#9;if permissionsHeader != &quot;&quot; {&#13;&#10;&#9;&#9;&#9;permissions = strings.Split(permissionsHeader, &quot;,&quot;)&#13;&#10;&#9;&#9;&#9;// Trim whitespace&#13;&#10;&#9;&#9;&#9;for i, perm := range permissions {&#13;&#10;&#9;&#9;&#9;&#9;permissions[i] = strings.TrimSpace(perm)&#13;&#10;&#9;&#9;&#9;}&#13;&#10;&#9;&#9;}&#13;&#10;&#13;&#10;&#9;&#9;// Set user info in context for services to use&#13;&#10;&#9;&#9;c.Set(&quot;user_id&quot;, userID)&#13;&#10;&#9;&#9;c.Set(&quot;email&quot;, email)&#13;&#10;&#9;&#9;c.Set(&quot;roles&quot;, roles)&#13;&#10;&#9;&#9;c.Set(&quot;permissions&quot;, permissions)&#13;&#10;&#13;&#10;&#9;&#9;c.Next()&#13;&#10;&#9;}&#13;&#10;}&#13;&#10;&#13;&#10;// RequirePermissions checks if user has ALL specified permissions&#13;&#10;func (m *SharedAuthMiddleware) RequirePermissions(requiredPermissions ...string) gin.HandlerFunc {&#13;&#10;&#9;return func(c *gin.Context) {&#13;&#10;&#9;&#9;permissions, exists := c.Get(&quot;permissions&quot;)&#13;&#10;&#9;&#9;if !exists {&#13;&#10;&#9;&#9;&#9;m.logger.Warn(&quot;Permissions not found in context, context_key: &quot;, &quot;permissions&quot;)&#13;&#10;&#9;&#9;&#9;c.JSON(http.StatusUnauthorized, rest.ErrorResponse{&#13;&#10;&#9;&#9;&#9;&#9;ApiError: rest.UnauthorizedError,&#13;&#10;&#9;&#9;&#9;&#9;Message:  &quot;User not authenticated&quot;,&#13;&#10;&#9;&#9;&#9;})&#13;&#10;&#9;&#9;&#9;c.Abort()&#13;&#10;&#9;&#9;&#9;return&#13;&#10;&#9;&#9;}&#13;&#10;&#13;&#10;&#9;&#9;userPermissions := permissions.([]string)&#13;&#10;&#9;&#9;userPermMap := make(map[string]bool)&#13;&#10;&#9;&#9;for _, perm := range userPermissions {&#13;&#10;&#9;&#9;&#9;userPermMap[perm] = true&#13;&#10;&#9;&#9;}&#13;&#10;&#13;&#10;&#9;&#9;// Check if user has all required permissions&#13;&#10;&#9;&#9;for _, requiredPerm := range requiredPermissions {&#13;&#10;&#9;&#9;&#9;if !userPermMap[requiredPerm] {&#13;&#10;&#9;&#9;&#9;&#9;m.logger.Warn(&quot;Access denied - missing permission, required_permission: &quot;,&#13;&#10;&#9;&#9;&#9;&#9;&#9;requiredPerm, &quot;user_permissions&quot;, userPermissions)&#13;&#10;&#9;&#9;&#9;&#9;c.JSON(http.StatusForbidden, rest.ErrorResponse{&#13;&#10;&#9;&#9;&#9;&#9;&#9;ApiError: rest.ForbiddenError,&#13;&#10;&#9;&#9;&#9;&#9;&#9;Message:  &quot;Insufficient permissions&quot;,&#13;&#10;&#9;&#9;&#9;&#9;})&#13;&#10;&#9;&#9;&#9;&#9;c.Abort()&#13;&#10;&#9;&#9;&#9;&#9;return&#13;&#10;&#9;&#9;&#9;}&#13;&#10;&#9;&#9;}&#13;&#10;&#13;&#10;&#9;&#9;c.Next()&#13;&#10;&#9;}&#13;&#10;}&#13;&#10;&#13;&#10;// RequireAnyPermission checks if user has ANY of the specified permissions&#13;&#10;func (m *SharedAuthMiddleware) RequireAnyPermission(permissions ...string) gin.HandlerFunc {&#13;&#10;&#9;return func(c *gin.Context) {&#13;&#10;&#9;&#9;userPermissions, exists := c.Get(&quot;permissions&quot;)&#13;&#10;&#9;&#9;if !exists {&#13;&#10;&#9;&#9;&#9;m.logger.Warn(&quot;Permissions not found in context, context_key: &quot;, &quot;permissions&quot;)&#13;&#10;&#9;&#9;&#9;c.JSON(http.StatusUnauthorized, rest.ErrorResponse{&#13;&#10;&#9;&#9;&#9;&#9;ApiError: rest.UnauthorizedError,&#13;&#10;&#9;&#9;&#9;&#9;Message:  &quot;User not authenticated&quot;,&#13;&#10;&#9;&#9;&#9;})&#13;&#10;&#9;&#9;&#9;c.Abort()&#13;&#10;&#9;&#9;&#9;return&#13;&#10;&#9;&#9;}&#13;&#10;&#13;&#10;&#9;&#9;userPerms := userPermissions.([]string)&#13;&#10;&#9;&#9;for _, userPerm := range userPerms {&#13;&#10;&#9;&#9;&#9;for _, requiredPerm := range permissions {&#13;&#10;&#9;&#9;&#9;&#9;if userPerm == requiredPerm {&#13;&#10;&#9;&#9;&#9;&#9;&#9;c.Next()&#13;&#10;&#9;&#9;&#9;&#9;&#9;return&#13;&#10;&#9;&#9;&#9;&#9;}&#13;&#10;&#9;&#9;&#9;}&#13;&#10;&#9;&#9;}&#13;&#10;&#13;&#10;&#9;&#9;c.JSON(http.StatusForbidden, rest.ErrorResponse{&#13;&#10;&#9;&#9;&#9;ApiError: rest.ForbiddenError,&#13;&#10;&#9;&#9;&#9;Message:  &quot;Insufficient permissions&quot;,&#13;&#10;&#9;&#9;})&#13;&#10;&#9;&#9;c.Abort()&#13;&#10;&#9;}&#13;&#10;}&#13;&#10;&#13;&#10;// RequireRole checks if user has specific role&#13;&#10;func (m *SharedAuthMiddleware) RequireRole(role string) gin.HandlerFunc {&#13;&#10;&#9;return func(c *gin.Context) {&#13;&#10;&#9;&#9;roles, exists := c.Get(&quot;roles&quot;)&#13;&#10;&#9;&#9;if !exists {&#13;&#10;&#9;&#9;&#9;m.logger.Warn(&quot;Roles not found in context, context_key: &quot;, &quot;roles&quot;)&#13;&#10;&#9;&#9;&#9;c.JSON(http.StatusUnauthorized, rest.ErrorResponse{&#13;&#10;&#9;&#9;&#9;&#9;ApiError: rest.UnauthorizedError,&#13;&#10;&#9;&#9;&#9;&#9;Message:  &quot;User not authenticated&quot;,&#13;&#10;&#9;&#9;&#9;})&#13;&#10;&#9;&#9;&#9;c.Abort()&#13;&#10;&#9;&#9;&#9;return&#13;&#10;&#9;&#9;}&#13;&#10;&#13;&#10;&#9;&#9;userRoles := roles.([]string)&#13;&#10;&#9;&#9;for _, userRole := range userRoles {&#13;&#10;&#9;&#9;&#9;if userRole == role {&#13;&#10;&#9;&#9;&#9;&#9;c.Next()&#13;&#10;&#9;&#9;&#9;&#9;return&#13;&#10;&#9;&#9;&#9;}&#13;&#10;&#9;&#9;}&#13;&#10;&#13;&#10;&#9;&#9;c.JSON(http.StatusForbidden, rest.ErrorResponse{&#13;&#10;&#9;&#9;&#9;ApiError: rest.ForbiddenError,&#13;&#10;&#9;&#9;&#9;Message:  &quot;Insufficient role permissions&quot;,&#13;&#10;&#9;&#9;})&#13;&#10;&#9;&#9;c.Abort()&#13;&#10;&#9;}&#13;&#10;}&#13;&#10;&#13;&#10;// RequireAnyRole checks if user has ANY of the specified roles&#13;&#10;func (m *SharedAuthMiddleware) RequireAnyRole(roles ...string) gin.HandlerFunc {&#13;&#10;&#9;return func(c *gin.Context) {&#13;&#10;&#9;&#9;userRoles, exists := c.Get(&quot;roles&quot;)&#13;&#10;&#9;&#9;if !exists {&#13;&#10;&#9;&#9;&#9;m.logger.Warn(&quot;Roles not found in context, context_key: &quot;, &quot;roles&quot;)&#13;&#10;&#9;&#9;&#9;c.JSON(http.StatusUnauthorized, rest.ErrorResponse{&#13;&#10;&#9;&#9;&#9;&#9;ApiError: rest.UnauthorizedError,&#13;&#10;&#9;&#9;&#9;&#9;Message:  &quot;User not authenticated&quot;,&#13;&#10;&#9;&#9;&#9;})&#13;&#10;&#9;&#9;&#9;c.Abort()&#13;&#10;&#9;&#9;&#9;return&#13;&#10;&#9;&#9;}&#13;&#10;&#13;&#10;&#9;&#9;userRolesList := userRoles.([]string)&#13;&#10;&#9;&#9;for _, userRole := range userRolesList {&#13;&#10;&#9;&#9;&#9;for _, requiredRole := range roles {&#13;&#10;&#9;&#9;&#9;&#9;if userRole == requiredRole {&#13;&#10;&#9;&#9;&#9;&#9;&#9;c.Next()&#13;&#10;&#9;&#9;&#9;&#9;&#9;return&#13;&#10;&#9;&#9;&#9;&#9;}&#13;&#10;&#9;&#9;&#9;}&#13;&#10;&#9;&#9;}&#13;&#10;&#13;&#10;&#9;&#9;c.JSON(http.StatusForbidden, rest.ErrorResponse{&#13;&#10;&#9;&#9;&#9;ApiError: rest.ForbiddenError,&#13;&#10;&#9;&#9;&#9;Message:  &quot;Insufficient role permissions&quot;,&#13;&#10;&#9;&#9;})&#13;&#10;&#9;&#9;c.Abort()&#13;&#10;&#9;}&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/internal/services/cart/cmd/main.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/internal/services/cart/cmd/main.go" />
              <option name="originalContent" value="package main&#10;&#10;import (&#10;&#9;&quot;github.com/hthinh24/go-store/internal/pkg/middleware/auth&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/internal/services/cart/internal/controller/http&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/internal/services/cart/internal/controller/http/client&quot;&#10;&#9;&quot;log&quot;&#10;&#10;&#9;&quot;github.com/gin-gonic/gin&quot;&#10;&#9;customLog &quot;github.com/hthinh24/go-store/internal/pkg/logger&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/internal/services/cart/internal/config&quot;&#10;&#9;repository &quot;github.com/hthinh24/go-store/internal/services/cart/internal/infra/postgres&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/internal/services/cart/internal/service&quot;&#10;&#9;&quot;gorm.io/driver/postgres&quot;&#10;&#9;&quot;gorm.io/gorm&quot;&#10;)&#10;&#10;func main() {&#10;&#9;configPath := &quot;config.yaml&quot;&#10;&#10;&#9;// Load configuration using shared pkg config&#10;&#9;cfg, err := config.LoadConfig(configPath)&#10;&#9;if err != nil {&#10;&#9;&#9;log.Fatalf(&quot;Failed to load config: %v&quot;, err)&#10;&#9;}&#10;&#10;&#9;appLogger := customLog.NewAppLogger(cfg.GetLogLevel())&#10;&#9;appLogger.Info(&quot;Starting Cart Service...&quot;)&#10;&#9;appLogger.Info(&quot;Environment: %s&quot;, cfg.GetEnvironment())&#10;&#10;&#9;db, err := initDatabase(cfg)&#10;&#9;if err != nil {&#10;&#9;&#9;appLogger.Error(&quot;Failed to connect to database: %v&quot;, err)&#10;&#9;&#9;log.Fatal(err)&#10;&#9;}&#10;&#9;appLogger.Info(&quot;Database connected successfully&quot;)&#10;&#10;&#9;productClient := client.NewProductClient(cfg.ProductServiceURL)&#10;&#10;&#9;cartRepository := repository.NewCartRepository(customLog.WithComponent(cfg.LogLevel, &quot;CART-REPOSITORY&quot;), db)&#10;&#9;cartService := service.NewCartService(customLog.WithComponent(cfg.LogLevel, &quot;CART-SERVICE&quot;),&#10;&#9;&#9;cartRepository,&#10;&#9;&#9;productClient)&#10;&#9;cartController := http.NewCartController(customLog.WithComponent(cfg.LogLevel, &quot;CART-CONTROLLER&quot;), cartService)&#10;&#10;&#9;router := setupRouter(cartController, cfg)&#10;&#10;&#9;serverAddr := &quot;:&quot; + cfg.ServerPort&#10;&#9;appLogger.Info(&quot;Cart service starting on %s&quot;, serverAddr)&#10;&#9;if err := router.Run(serverAddr); err != nil {&#10;&#9;&#9;appLogger.Error(&quot;Failed to start server: %v&quot;, err)&#10;&#9;&#9;log.Fatal(err)&#10;&#9;}&#10;}&#10;&#10;func initDatabase(cfg *config.AppConfig) (*gorm.DB, error) {&#10;&#9;dsn := &quot;host=&quot; + cfg.DBHost + &quot; user=&quot; + cfg.DBUser + &quot; password=&quot; + cfg.DBPassword + &quot; dbname=&quot; + cfg.DBName + &quot; port=&quot; + cfg.DBPort + &quot; sslmode=&quot; + cfg.DBSSLMode&#10;&#9;db, err := gorm.Open(postgres.Open(dsn), &amp;gorm.Config{})&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#9;return db, nil&#10;}&#10;&#10;func setupRouter(cartController *http.CartController, cfg *config.AppConfig) *gin.Engine {&#10;&#9;router := gin.Default()&#10;&#10;&#9;authMiddleware := auth.NewSharedAuthMiddleware(customLog.WithComponent(cfg.LogLevel, &quot;AUTH-MIDDLEWARE&quot;))&#10;&#10;&#9;router.GET(&quot;/health&quot;, func(c *gin.Context) {&#10;&#9;&#9;c.JSON(200, gin.H{&quot;status&quot;: &quot;healthy&quot;})&#10;&#9;})&#10;&#10;&#9;api := router.Group(&quot;/api&quot;)&#10;&#9;{&#10;&#9;&#9;v1 := api.Group(&quot;/v1&quot;)&#10;&#9;&#9;cart := v1.Group(&quot;/cart&quot;)&#10;&#10;&#9;&#9;// Public endpoints&#10;&#9;&#9;cart.POST(&quot;/register&quot;, cartController.CreateCart())&#10;&#10;&#9;&#9;// Apply authentication middleware to cart routes&#10;&#9;&#9;cart.Use(authMiddleware.AuthRequired())&#10;&#9;&#9;{&#10;&#9;&#9;&#9;cart.GET(&quot;&quot;, cartController.GetCartItemsByUserID())&#10;&#10;&#9;&#9;&#9;cart.POST(&quot;/items&quot;, cartController.AddItemToCart())&#10;&#9;&#9;&#9;cart.PUT(&quot;/items&quot;, cartController.UpdateItemQuantity())&#10;&#9;&#9;&#9;cart.DELETE(&quot;/:item_id&quot;, cartController.RemoveItemFromCart())&#10;&#9;&#9;}&#10;&#9;}&#10;&#9;return router&#10;}&#10;" />
              <option name="updatedContent" value="package main&#10;&#10;import (&#10;&#9;&quot;github.com/hthinh24/go-store/internal/pkg/middleware/auth&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/internal/services/cart/internal/controller/http&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/internal/services/cart/internal/controller/http/client&quot;&#10;&#9;&quot;log&quot;&#10;&#10;&#9;&quot;github.com/gin-gonic/gin&quot;&#10;&#9;customLog &quot;github.com/hthinh24/go-store/internal/pkg/logger&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/internal/services/cart/internal/config&quot;&#10;&#9;repository &quot;github.com/hthinh24/go-store/internal/services/cart/internal/infra/postgres&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/internal/services/cart/internal/service&quot;&#10;&#9;&quot;gorm.io/driver/postgres&quot;&#10;&#9;&quot;gorm.io/gorm&quot;&#10;)&#10;&#10;func main() {&#10;&#9;configPath := &quot;config.yaml&quot;&#10;&#10;&#9;// Load configuration using shared pkg config&#10;&#9;cfg, err := config.LoadConfig(configPath)&#10;&#9;if err != nil {&#10;&#9;&#9;log.Fatalf(&quot;Failed to load config: %v&quot;, err)&#10;&#9;}&#10;&#10;&#9;appLogger := customLog.NewAppLogger(cfg.GetLogLevel())&#10;&#9;appLogger.Info(&quot;Starting Cart Service...&quot;)&#10;&#9;appLogger.Info(&quot;Environment: %s&quot;, cfg.GetEnvironment())&#10;&#10;&#9;db, err := initDatabase(cfg)&#10;&#9;if err != nil {&#10;&#9;&#9;appLogger.Error(&quot;Failed to connect to database: %v&quot;, err)&#10;&#9;&#9;log.Fatal(err)&#10;&#9;}&#10;&#9;appLogger.Info(&quot;Database connected successfully&quot;)&#10;&#10;&#9;productClient := client.NewProductClient(cfg.GetProductServiceURL())&#10;&#10;&#9;cartRepository := repository.NewCartRepository(customLog.WithComponent(cfg.GetLogLevel(), &quot;CART-REPOSITORY&quot;), db)&#10;&#9;cartService := service.NewCartService(customLog.WithComponent(cfg.GetLogLevel(), &quot;CART-SERVICE&quot;),&#10;&#9;&#9;cartRepository,&#10;&#9;&#9;productClient)&#10;&#9;cartController := http.NewCartController(customLog.WithComponent(cfg.GetLogLevel(), &quot;CART-CONTROLLER&quot;), cartService)&#10;&#10;&#9;router := setupRouter(cartController, cfg)&#10;&#10;&#9;serverAddr := cfg.GetServerAddress()&#10;&#9;appLogger.Info(&quot;Cart service starting on %s&quot;, serverAddr)&#10;&#9;if err := router.Run(serverAddr); err != nil {&#10;&#9;&#9;appLogger.Error(&quot;Failed to start server: %v&quot;, err)&#10;&#9;&#9;log.Fatal(err)&#10;&#9;}&#10;}&#10;&#10;func initDatabase(cfg *config.AppConfig) (*gorm.DB, error) {&#10;&#9;db, err := gorm.Open(postgres.Open(cfg.GetDatabaseURL()), &amp;gorm.Config{})&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#9;return db, nil&#10;}&#10;&#10;func setupRouter(cartController *http.CartController, cfg *config.AppConfig) *gin.Engine {&#10;&#9;router := gin.Default()&#10;&#10;&#9;authMiddleware := auth.NewSharedAuthMiddleware(customLog.WithComponent(cfg.GetLogLevel(), &quot;AUTH-MIDDLEWARE&quot;))&#10;&#10;&#9;router.GET(&quot;/health&quot;, func(c *gin.Context) {&#10;&#9;&#9;c.JSON(200, gin.H{&quot;status&quot;: &quot;healthy&quot;})&#10;&#9;})&#10;&#10;&#9;api := router.Group(&quot;/api&quot;)&#10;&#9;{&#10;&#9;&#9;v1 := api.Group(&quot;/v1&quot;)&#10;&#9;&#9;cart := v1.Group(&quot;/cart&quot;)&#10;&#10;&#9;&#9;// Public endpoints&#10;&#9;&#9;cart.POST(&quot;/register&quot;, cartController.CreateCart())&#10;&#10;&#9;&#9;// Apply authentication middleware to cart routes&#10;&#9;&#9;cart.Use(authMiddleware.AuthRequired())&#10;&#9;&#9;{&#10;&#9;&#9;&#9;cart.GET(&quot;&quot;, cartController.GetCartItemsByUserID())&#10;&#10;&#9;&#9;&#9;cart.POST(&quot;/items&quot;, cartController.AddItemToCart())&#10;&#9;&#9;&#9;cart.PUT(&quot;/items&quot;, cartController.UpdateItemQuantity())&#10;&#9;&#9;&#9;cart.DELETE(&quot;/:item_id&quot;, cartController.RemoveItemFromCart())&#10;&#9;&#9;}&#10;&#9;}&#10;&#9;return router&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/internal/services/cart/config.yaml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/internal/services/cart/config.yaml" />
              <option name="originalContent" value="environment: &quot;development&quot;&#10;service_name: &quot;cart&quot;&#10;&#10;# Application Configuration (host and port)&#10;app:&#10;  host: &quot;localhost&quot;&#10;  port: &quot;8082&quot;&#10;&#10;# HTTP Server Configuration&#10;http:&#10;  read_timeout: 10&#10;  write_timeout: 10&#10;  max_header_bytes: 1048576&#10;  allowed_origins: &quot;*&quot;&#10;  allowed_methods: &quot;GET,POST,PUT,DELETE,OPTIONS&quot;&#10;  allowed_headers: &quot;Content-Type,Authorization&quot;&#10;  exposed_headers: &quot;&quot;&#10;  allow_credentials: true&#10;&#10;# Database Configuration&#10;pg:&#10;  host: &quot;localhost&quot;&#10;  port: &quot;5432&quot;&#10;  user: &quot;postgres&quot;&#10;  password: &quot;password&quot;&#10;  database: &quot;gostore_cart&quot;&#10;  ssl_mode: &quot;disable&quot;&#10;  max_open_conns: 25&#10;  max_idle_conns: 10&#10;  conn_max_lifetime: 3600&#10;  conn_max_idle_time: 1800&#10;&#10;# JWT Configuration&#10;jwt:&#10;  secret: &quot;your-secret-key&quot;&#10;  expiration: &quot;24h&quot;&#10;  issuer: &quot;gostore-cart&quot;&#10;  audience: &quot;gostore-users&quot;&#10;&#10;# Redis Configuration&#10;redis:&#10;  host: &quot;localhost&quot;&#10;  port: &quot;6379&quot;&#10;  password: &quot;&quot;&#10;  db: 0&#10;  pool_size: 10&#10;  min_idle_conns: 3&#10;  dial_timeout: 5&#10;  read_timeout: 3&#10;  write_timeout: 3&#10;  idle_timeout: 300&#10;&#10;# Logging Configuration&#10;log:&#10;  level: &quot;info&quot;&#10;  format: &quot;json&quot;&#10;  output: &quot;stdout&quot;&#10;  file_path: &quot;&quot;&#10;  max_size: 10&#10;  max_backups: 3&#10;  max_age: 28&#10;  compress: true&#10;&#10;# Services Configuration for inter-service communication&#10;services:&#10;  identity_service_url: &quot;http://localhost:8080&quot;&#10;  product_service_url: &quot;http://localhost:8081&quot;&#10;  cart_service_url: &quot;http://localhost:8082&quot;&#10;  order_service_url: &quot;http://localhost:8083&quot;&#10;  gateway_service_url: &quot;http://localhost:8000&quot;&#10;  notification_service_url: &quot;http://localhost:8084&quot;&#10;  payment_service_url: &quot;http://localhost:8085&quot;&#10;" />
              <option name="updatedContent" value="environment: &quot;development&quot;&#10;service_name: &quot;cart&quot;&#10;&#10;# Application Configuration (host and port from .env: SERVER_HOST=localhost, SERVER_PORT=8082)&#10;app:&#10;  host: &quot;localhost&quot;&#10;  port: &quot;8082&quot;&#10;&#10;# HTTP Server Configuration&#10;http:&#10;  read_timeout: 10&#10;  write_timeout: 10&#10;  max_header_bytes: 1048576&#10;  allowed_origins: &quot;*&quot;&#10;  allowed_methods: &quot;GET,POST,PUT,DELETE,OPTIONS&quot;&#10;  allowed_headers: &quot;Content-Type,Authorization&quot;&#10;  exposed_headers: &quot;&quot;&#10;  allow_credentials: true&#10;&#10;# Database Configuration (from .env: DB_HOST=localhost, DB_PORT=5003, etc.)&#10;pg:&#10;  host: &quot;localhost&quot;&#10;  port: &quot;5003&quot;&#10;  user: &quot;postgres&quot;&#10;  password: &quot;root&quot;&#10;  database: &quot;postgres&quot;&#10;  ssl_mode: &quot;disable&quot;&#10;  max_open_conns: 25&#10;  max_idle_conns: 10&#10;  conn_max_lifetime: 3600&#10;  conn_max_idle_time: 1800&#10;&#10;# JWT Configuration (cart service doesn't have JWT in .env, using defaults)&#10;jwt:&#10;  secret: &quot;your-secret-key&quot;&#10;  expiration: &quot;24h&quot;&#10;  issuer: &quot;gostore-cart&quot;&#10;  audience: &quot;gostore-users&quot;&#10;&#10;# Redis Configuration (from .env: REDIS_HOST=localhost, REDIS_PORT=6002)&#10;redis:&#10;  host: &quot;localhost&quot;&#10;  port: &quot;6002&quot;&#10;  password: &quot;&quot;&#10;  db: 0&#10;  pool_size: 10&#10;  min_idle_conns: 3&#10;  dial_timeout: 5&#10;  read_timeout: 3&#10;  write_timeout: 3&#10;  idle_timeout: 300&#10;&#10;# Logging Configuration (from .env: LOG_LEVEL=info)&#10;log:&#10;  level: &quot;info&quot;&#10;  format: &quot;json&quot;&#10;  output: &quot;stdout&quot;&#10;  file_path: &quot;&quot;&#10;  max_size: 10&#10;  max_backups: 3&#10;  max_age: 28&#10;  compress: true&#10;&#10;# Services Configuration for inter-service communication (updated PRODUCT_SERVICE_URL)&#10;services:&#10;  identity_service_url: &quot;http://localhost:8080&quot;&#10;  product_service_url: &quot;http://localhost:8081&quot;&#10;  cart_service_url: &quot;http://localhost:8082&quot;&#10;  order_service_url: &quot;http://localhost:8083&quot;&#10;  gateway_service_url: &quot;http://localhost:8000&quot;&#10;  notification_service_url: &quot;http://localhost:8084&quot;&#10;  payment_service_url: &quot;http://localhost:8085&quot;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/internal/services/cart/internal/config/config.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/internal/services/cart/internal/config/config.go" />
              <option name="originalContent" value="package config&#10;&#10;import (&#10;&#9;&quot;fmt&quot;&#10;&#9;&quot;github.com/joho/godotenv&quot;&#10;&#9;&quot;os&quot;&#10;)&#10;&#10;type AppConfig struct {&#10;&#9;// Database Configuration&#10;&#9;DBHost     string&#10;&#9;DBPort     string&#10;&#9;DBUser     string&#10;&#9;DBPassword string&#10;&#9;DBName     string&#10;&#9;DBSSLMode  string&#10;&#10;&#9;// Server Configuration&#10;&#9;ServerPort string&#10;&#9;ServerHost string&#10;&#10;&#9;ProductServiceURL string&#10;&#10;&#9;// Log Configuration&#10;&#9;LogLevel string&#10;&#10;&#9;// Redis Configuration&#10;&#9;RedisHost     string&#10;&#9;RedisPort     string&#10;&#9;RedisPassword string&#10;&#10;&#9;// Environment&#10;&#9;Environment string&#10;}&#10;&#10;func LoadConfig(filename string) (*AppConfig, error) {&#10;&#9;// Load .env file in development&#10;&#9;if os.Getenv(&quot;ENV&quot;) != &quot;production&quot; {&#10;&#9;&#9;err := godotenv.Load(filename)&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;// Don't fail if .env file doesn't exist&#10;&#9;&#9;&#9;fmt.Println(&quot;Warning: .env file not found, using system environment variables&quot;)&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;config := &amp;AppConfig{&#10;&#9;&#9;DBHost:     getEnv(&quot;DB_HOST&quot;, &quot;localhost&quot;),&#10;&#9;&#9;DBPort:     getEnv(&quot;DB_PORT&quot;, &quot;5432&quot;),&#10;&#9;&#9;DBUser:     getEnv(&quot;DB_USER&quot;, &quot;postgres&quot;),&#10;&#9;&#9;DBPassword: getEnv(&quot;DB_PASSWORD&quot;, &quot;&quot;),&#10;&#9;&#9;DBName:     getEnv(&quot;DB_NAME&quot;, &quot;go_store_identity&quot;),&#10;&#9;&#9;DBSSLMode:  getEnv(&quot;DB_SSL_MODE&quot;, &quot;disable&quot;),&#10;&#10;&#9;&#9;ServerPort: getEnv(&quot;SERVER_PORT&quot;, &quot;8080&quot;),&#10;&#9;&#9;ServerHost: getEnv(&quot;SERVER_HOST&quot;, &quot;localhost&quot;),&#10;&#10;&#9;&#9;ProductServiceURL: getEnv(&quot;PRODUCT_SERVICE_URL&quot;, &quot;http://localhost:8081&quot;),&#10;&#10;&#9;&#9;LogLevel: getEnv(&quot;LOG_LEVEL&quot;, &quot;info&quot;),&#10;&#10;&#9;&#9;RedisHost:     getEnv(&quot;REDIS_HOST&quot;, &quot;localhost&quot;),&#10;&#9;&#9;RedisPort:     getEnv(&quot;REDIS_PORT&quot;, &quot;6379&quot;),&#10;&#9;&#9;RedisPassword: getEnv(&quot;REDIS_PASSWORD&quot;, &quot;&quot;),&#10;&#10;&#9;&#9;Environment: getEnv(&quot;ENV&quot;, &quot;development&quot;),&#10;&#9;}&#10;&#10;&#9;return config, nil&#10;}&#10;&#10;func (c *AppConfig) GetServerAddress() string {&#10;&#9;return fmt.Sprintf(&quot;%s:%s&quot;, c.ServerHost, c.ServerPort)&#10;}&#10;&#10;func (c *AppConfig) IsProduction() bool {&#10;&#9;return c.Environment == &quot;production&quot;&#10;}&#10;&#10;// getEnv gets environment variable with fallback&#10;func getEnv(key, fallback string) string {&#10;&#9;if value := os.Getenv(key); value != &quot;&quot; {&#10;&#9;&#9;return value&#10;&#9;}&#10;&#9;return fallback&#10;}&#10;" />
              <option name="updatedContent" value="package config&#13;&#10;&#13;&#10;import (&#13;&#10;&#9;&quot;fmt&quot;&#13;&#10;&#9;&quot;github.com/hthinh24/go-store/internal/pkg/config&quot;&#13;&#10;)&#13;&#10;&#13;&#10;type AppConfig struct {&#13;&#10;&#9;*config.Config&#13;&#10;}&#13;&#10;&#13;&#10;func LoadConfig(configPath string) (*AppConfig, error) {&#13;&#10;&#9;// Load shared configuration from pkg&#13;&#10;&#9;sharedConfig, err := config.LoadConfig(configPath)&#13;&#10;&#9;if err != nil {&#13;&#10;&#9;&#9;return nil, fmt.Errorf(&quot;error loading shared config: %w&quot;, err)&#13;&#10;&#9;}&#13;&#10;&#13;&#10;&#9;appConfig := &amp;AppConfig{&#13;&#10;&#9;&#9;Config: sharedConfig,&#13;&#10;&#9;}&#13;&#10;&#13;&#10;&#9;return appConfig, nil&#13;&#10;}&#13;&#10;&#13;&#10;// Legacy getter methods for backward compatibility&#13;&#10;func (c *AppConfig) GetDBHost() string {&#13;&#10;&#9;return c.PG.Host&#13;&#10;}&#13;&#10;&#13;&#10;func (c *AppConfig) GetDBPort() string {&#13;&#10;&#9;return c.PG.Port&#13;&#10;}&#13;&#10;&#13;&#10;func (c *AppConfig) GetDBUser() string {&#13;&#10;&#9;return c.PG.User&#13;&#10;}&#13;&#10;&#13;&#10;func (c *AppConfig) GetDBPassword() string {&#13;&#10;&#9;return c.PG.Password&#13;&#10;}&#13;&#10;&#13;&#10;func (c *AppConfig) GetDBName() string {&#13;&#10;&#9;return c.PG.Database&#13;&#10;}&#13;&#10;&#13;&#10;func (c *AppConfig) GetDBSSLMode() string {&#13;&#10;&#9;return c.PG.SSLMode&#13;&#10;}&#13;&#10;&#13;&#10;func (c *AppConfig) GetServerPort() string {&#13;&#10;&#9;return c.App.Port&#13;&#10;}&#13;&#10;&#13;&#10;func (c *AppConfig) GetServerHost() string {&#13;&#10;&#9;return c.App.Host&#13;&#10;}&#13;&#10;&#13;&#10;func (c *AppConfig) GetProductServiceURL() string {&#13;&#10;&#9;return c.Services.GetServiceURL(&quot;product&quot;)&#13;&#10;}&#13;&#10;&#13;&#10;func (c *AppConfig) GetLogLevel() string {&#13;&#10;&#9;return c.Log.Level&#13;&#10;}&#13;&#10;&#13;&#10;func (c *AppConfig) GetRedisHost() string {&#13;&#10;&#9;return c.Redis.Host&#13;&#10;}&#13;&#10;&#13;&#10;func (c *AppConfig) GetRedisPort() string {&#13;&#10;&#9;return c.Redis.Port&#13;&#10;}&#13;&#10;&#13;&#10;func (c *AppConfig) GetRedisPassword() string {&#13;&#10;&#9;return c.Redis.Password&#13;&#10;}&#13;&#10;&#13;&#10;func (c *AppConfig) GetEnvironment() string {&#13;&#10;&#9;return c.Environment&#13;&#10;}&#13;&#10;&#13;&#10;func (c *AppConfig) GetDatabaseURL() string {&#13;&#10;&#9;return fmt.Sprintf(&quot;host=%s user=%s password=%s dbname=%s port=%s sslmode=%s TimeZone=Asia/Shanghai&quot;,&#13;&#10;&#9;&#9;c.PG.Host, c.PG.User, c.PG.Password, c.PG.Database, c.PG.Port, c.PG.SSLMode)&#13;&#10;}&#13;&#10;&#13;&#10;func (c *AppConfig) GetServerAddress() string {&#13;&#10;&#9;return fmt.Sprintf(&quot;%s:%s&quot;, c.App.Host, c.App.Port)&#13;&#10;}&#13;&#10;&#13;&#10;func (c *AppConfig) IsProduction() bool {&#13;&#10;&#9;return c.Environment == &quot;production&quot;&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/internal/services/cart/internal/controller/cart_controller.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/internal/services/cart/internal/controller/cart_controller.go" />
              <option name="originalContent" value="package controller&#10;&#10;import (&#10;&#9;&quot;errors&quot;&#10;&#9;&quot;github.com/gin-gonic/gin&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/internal/pkg/logger&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/internal/pkg/rest&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/services/cart/internal&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/services/cart/internal/dto/request&quot;&#10;&#9;customErr &quot;github.com/hthinh24/go-store/services/cart/internal/errors&quot;&#10;&#9;&quot;net/http&quot;&#10;&#9;&quot;strconv&quot;&#10;)&#10;&#10;type CartController struct {&#10;&#9;logger      logger.Logger&#10;&#9;cartService internal.CartService&#10;}&#10;&#10;func NewCartController(logger logger.Logger, cartService internal.CartService) *CartController {&#10;&#9;return &amp;CartController{&#10;&#9;&#9;logger:      logger,&#10;&#9;&#9;cartService: cartService,&#10;&#9;}&#10;}&#10;&#10;func (c *CartController) GetCartItemsByUserID() func(c *gin.Context) {&#10;&#9;return func(ctx *gin.Context) {&#10;&#9;&#9;userID, err := c.getUserIDFromContext(ctx)&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;ctx.JSON(http.StatusUnauthorized, rest.NewErrorResponse(rest.UnauthorizedError, &quot;User not authenticated&quot;))&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#10;&#9;&#9;cartItems, err := c.cartService.FindCartItemsByCartID(userID)&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;c.handleCartError(ctx, err)&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#10;&#9;&#9;ctx.JSON(http.StatusOK, rest.NewAPIResponse(http.StatusOK, &quot;Get cart items by user id successfully&quot;, cartItems))&#10;&#9;}&#10;}&#10;&#10;func (c *CartController) AddItemToCart() func(c *gin.Context) {&#10;&#9;return func(ctx *gin.Context) {&#10;&#9;&#9;var item request.AddItemRequest&#10;&#9;&#9;if err := ctx.ShouldBindJSON(&amp;item); err != nil {&#10;&#9;&#9;&#9;ctx.JSON(http.StatusBadRequest, rest.NewErrorResponse(rest.BadRequestError, &quot;Invalid input&quot;))&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#10;&#9;&#9;userID, err := c.getUserIDFromContext(ctx)&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;ctx.JSON(http.StatusUnauthorized, rest.NewErrorResponse(rest.UnauthorizedError, err.Error()))&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#10;&#9;&#9;if err := c.cartService.AddItemToCart(userID, &amp;item); err != nil {&#10;&#9;&#9;&#9;c.handleCartError(ctx, err)&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#10;&#9;&#9;ctx.JSON(http.StatusCreated, rest.NewAPIResponse(http.StatusCreated, &quot;Item added to cart successfully&quot;, nil))&#10;&#9;}&#10;}&#10;&#10;func (c *CartController) UpdateItemQuantity() func(c *gin.Context) {&#10;&#9;return func(ctx *gin.Context) {&#10;&#9;&#9;var item request.UpdateItemQuantityRequest&#10;&#9;&#9;if err := ctx.ShouldBindJSON(&amp;item); err != nil {&#10;&#9;&#9;&#9;ctx.JSON(http.StatusBadRequest, rest.NewErrorResponse(rest.BadRequestError, &quot;Invalid input&quot;))&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#10;&#9;&#9;userID, err := c.getUserIDFromContext(ctx)&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;ctx.JSON(http.StatusUnauthorized, rest.NewErrorResponse(rest.UnauthorizedError, err.Error()))&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#10;&#9;&#9;if err := c.cartService.UpdateItemQuantity(userID, item.ItemID, item.Quantity); err != nil {&#10;&#9;&#9;&#9;c.handleCartError(ctx, err)&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#10;&#9;&#9;ctx.JSON(http.StatusOK, rest.NewAPIResponse(http.StatusOK, &quot;Item quantity updated successfully&quot;, nil))&#10;&#9;}&#10;}&#10;&#10;func (c *CartController) RemoveItemFromCart() func(c *gin.Context) {&#10;&#9;return func(ctx *gin.Context) {&#10;&#9;&#9;itemID := ctx.Param(&quot;item_id&quot;)&#10;&#9;&#9;itemIDInt, err := strconv.Atoi(itemID)&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;ctx.JSON(http.StatusBadRequest, rest.NewErrorResponse(rest.BadRequestError, &quot;Invalid item ID format&quot;))&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#10;&#9;&#9;userID, err := c.getUserIDFromContext(ctx)&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;ctx.JSON(http.StatusUnauthorized, rest.NewErrorResponse(rest.UnauthorizedError, err.Error()))&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#10;&#9;&#9;if err := c.cartService.RemoveItemFromCart(userID, int64(itemIDInt)); err != nil {&#10;&#9;&#9;&#9;c.handleCartError(ctx, err)&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#10;&#9;&#9;ctx.JSON(http.StatusOK, rest.NewAPIResponse(http.StatusOK, &quot;Item removed from cart successfully&quot;, nil))&#10;&#9;}&#10;}&#10;&#10;func (c *CartController) getUserIDFromContext(ctx *gin.Context) (int64, error) {&#10;&#9;userID, exists := ctx.Get(&quot;user_id&quot;)&#10;&#9;if !exists {&#10;&#9;&#9;return 0, errors.New(&quot;user ID not found in context&quot;)&#10;&#9;}&#10;&#10;&#9;userIDInt64, ok := userID.(int64)&#10;&#9;if !ok {&#10;&#9;&#9;return 0, errors.New(&quot;invalid user ID type&quot;)&#10;&#9;}&#10;&#10;&#9;return userIDInt64, nil&#10;}&#10;&#10;func (c *CartController) handleCartError(ctx *gin.Context, err error) {&#10;&#9;switch {&#10;&#9;case errors.Is(err, customErr.ErrCartNotFound):&#10;&#9;&#9;ctx.JSON(http.StatusNotFound, rest.NewErrorResponse(rest.NotFoundError, err.Error()))&#10;&#9;case errors.Is(err, customErr.ErrCartItemNotFound):&#10;&#9;&#9;ctx.JSON(http.StatusNotFound, rest.NewErrorResponse(rest.NotFoundError, err.Error()))&#10;&#9;case errors.Is(err, customErr.ErrCartItemAlreadyExists):&#10;&#9;&#9;ctx.JSON(http.StatusConflict, rest.NewErrorResponse(rest.ConflictError, err.Error()))&#10;&#9;default:&#10;&#9;&#9;ctx.JSON(http.StatusInternalServerError, rest.NewErrorResponse(rest.InternalServerErrorError, &quot;An unexpected error occurred&quot;))&#10;&#9;}&#10;}&#10;" />
              <option name="updatedContent" value="package controller&#13;&#10;&#13;&#10;import (&#13;&#10;&#9;&quot;errors&quot;&#13;&#10;&#9;&quot;github.com/gin-gonic/gin&quot;&#13;&#10;&#9;&quot;github.com/hthinh24/go-store/internal/pkg/logger&quot;&#13;&#10;&#9;&quot;github.com/hthinh24/go-store/internal/pkg/rest&quot;&#13;&#10;&#9;&quot;github.com/hthinh24/go-store/services/cart/internal&quot;&#13;&#10;&#9;&quot;github.com/hthinh24/go-store/services/cart/internal/dto/request&quot;&#13;&#10;&#9;customErr &quot;github.com/hthinh24/go-store/services/cart/internal/errors&quot;&#13;&#10;&#9;&quot;net/http&quot;&#13;&#10;&#9;&quot;strconv&quot;&#13;&#10;)&#13;&#10;&#13;&#10;type CartController struct {&#13;&#10;&#9;logger      logger.Logger&#13;&#10;&#9;cartService internal.CartService&#13;&#10;}&#13;&#10;&#13;&#10;func NewCartController(logger logger.Logger, cartService internal.CartService) *CartController {&#13;&#10;&#9;return &amp;CartController{&#13;&#10;&#9;&#9;logger:      logger,&#13;&#10;&#9;&#9;cartService: cartService,&#13;&#10;&#9;}&#13;&#10;}&#13;&#10;&#13;&#10;func (c *CartController) CreateCart() func(c *gin.Context) {&#13;&#10;&#9;return func(ctx *gin.Context) {&#13;&#10;&#9;&#9;var createCartRequest request.CreateCartRequest&#13;&#10;&#9;&#9;if err := ctx.ShouldBindJSON(&amp;createCartRequest); err != nil {&#13;&#10;&#9;&#9;&#9;c.logger.Error(&quot;Invalid create cart request&quot;, &quot;error&quot;, err)&#13;&#10;&#9;&#9;&#9;ctx.JSON(http.StatusBadRequest, rest.NewErrorResponse(rest.BadRequestError, &quot;Invalid input&quot;))&#13;&#10;&#9;&#9;&#9;return&#13;&#10;&#9;&#9;}&#13;&#10;&#13;&#10;&#9;&#9;cart, err := c.cartService.CreateCart(&amp;createCartRequest)&#13;&#10;&#9;&#9;if err != nil {&#13;&#10;&#9;&#9;&#9;c.handleCartError(ctx, err)&#13;&#10;&#9;&#9;&#9;return&#13;&#10;&#9;&#9;}&#13;&#10;&#13;&#10;&#9;&#9;ctx.JSON(http.StatusCreated, rest.NewAPIResponse(http.StatusCreated, &quot;Cart created successfully&quot;, cart))&#13;&#10;&#9;}&#13;&#10;}&#13;&#10;&#13;&#10;func (c *CartController) GetCartItemsByUserID() func(c *gin.Context) {&#13;&#10;&#9;return func(ctx *gin.Context) {&#13;&#10;&#9;&#9;userID, err := c.getUserIDFromContext(ctx)&#13;&#10;&#9;&#9;if err != nil {&#13;&#10;&#9;&#9;&#9;ctx.JSON(http.StatusUnauthorized, rest.NewErrorResponse(rest.UnauthorizedError, &quot;User not authenticated&quot;))&#13;&#10;&#9;&#9;&#9;return&#13;&#10;&#9;&#9;}&#13;&#10;&#13;&#10;&#9;&#9;cartItems, err := c.cartService.FindCartItemsByCartID(userID)&#13;&#10;&#9;&#9;if err != nil {&#13;&#10;&#9;&#9;&#9;c.handleCartError(ctx, err)&#13;&#10;&#9;&#9;&#9;return&#13;&#10;&#9;&#9;}&#13;&#10;&#13;&#10;&#9;&#9;ctx.JSON(http.StatusOK, rest.NewAPIResponse(http.StatusOK, &quot;Get cart items by user id successfully&quot;, cartItems))&#13;&#10;&#9;}&#13;&#10;}&#13;&#10;&#13;&#10;func (c *CartController) AddItemToCart() func(c *gin.Context) {&#13;&#10;&#9;return func(ctx *gin.Context) {&#13;&#10;&#9;&#9;var item request.AddItemRequest&#13;&#10;&#9;&#9;if err := ctx.ShouldBindJSON(&amp;item); err != nil {&#13;&#10;&#9;&#9;&#9;ctx.JSON(http.StatusBadRequest, rest.NewErrorResponse(rest.BadRequestError, &quot;Invalid input&quot;))&#13;&#10;&#9;&#9;&#9;return&#13;&#10;&#9;&#9;}&#13;&#10;&#13;&#10;&#9;&#9;userID, err := c.getUserIDFromContext(ctx)&#13;&#10;&#9;&#9;if err != nil {&#13;&#10;&#9;&#9;&#9;ctx.JSON(http.StatusUnauthorized, rest.NewErrorResponse(rest.UnauthorizedError, err.Error()))&#13;&#10;&#9;&#9;&#9;return&#13;&#10;&#9;&#9;}&#13;&#10;&#13;&#10;&#9;&#9;if err := c.cartService.AddItemToCart(userID, &amp;item); err != nil {&#13;&#10;&#9;&#9;&#9;c.handleCartError(ctx, err)&#13;&#10;&#9;&#9;&#9;return&#13;&#10;&#9;&#9;}&#13;&#10;&#13;&#10;&#9;&#9;ctx.JSON(http.StatusCreated, rest.NewAPIResponse(http.StatusCreated, &quot;Item added to cart successfully&quot;, nil))&#13;&#10;&#9;}&#13;&#10;}&#13;&#10;&#13;&#10;func (c *CartController) UpdateItemQuantity() func(c *gin.Context) {&#13;&#10;&#9;return func(ctx *gin.Context) {&#13;&#10;&#9;&#9;var item request.UpdateItemQuantityRequest&#13;&#10;&#9;&#9;if err := ctx.ShouldBindJSON(&amp;item); err != nil {&#13;&#10;&#9;&#9;&#9;ctx.JSON(http.StatusBadRequest, rest.NewErrorResponse(rest.BadRequestError, &quot;Invalid input&quot;))&#13;&#10;&#9;&#9;&#9;return&#13;&#10;&#9;&#9;}&#13;&#10;&#13;&#10;&#9;&#9;userID, err := c.getUserIDFromContext(ctx)&#13;&#10;&#9;&#9;if err != nil {&#13;&#10;&#9;&#9;&#9;ctx.JSON(http.StatusUnauthorized, rest.NewErrorResponse(rest.UnauthorizedError, err.Error()))&#13;&#10;&#9;&#9;&#9;return&#13;&#10;&#9;&#9;}&#13;&#10;&#13;&#10;&#9;&#9;if err := c.cartService.UpdateItemQuantity(userID, item.ItemID, item.Quantity); err != nil {&#13;&#10;&#9;&#9;&#9;c.handleCartError(ctx, err)&#13;&#10;&#9;&#9;&#9;return&#13;&#10;&#9;&#9;}&#13;&#10;&#13;&#10;&#9;&#9;ctx.JSON(http.StatusOK, rest.NewAPIResponse(http.StatusOK, &quot;Item quantity updated successfully&quot;, nil))&#13;&#10;&#9;}&#13;&#10;}&#13;&#10;&#13;&#10;func (c *CartController) RemoveItemFromCart() func(c *gin.Context) {&#13;&#10;&#9;return func(ctx *gin.Context) {&#13;&#10;&#9;&#9;itemID := ctx.Param(&quot;item_id&quot;)&#13;&#10;&#9;&#9;itemIDInt, err := strconv.Atoi(itemID)&#13;&#10;&#9;&#9;if err != nil {&#13;&#10;&#9;&#9;&#9;ctx.JSON(http.StatusBadRequest, rest.NewErrorResponse(rest.BadRequestError, &quot;Invalid item ID format&quot;))&#13;&#10;&#9;&#9;&#9;return&#13;&#10;&#9;&#9;}&#13;&#10;&#13;&#10;&#9;&#9;userID, err := c.getUserIDFromContext(ctx)&#13;&#10;&#9;&#9;if err != nil {&#13;&#10;&#9;&#9;&#9;ctx.JSON(http.StatusUnauthorized, rest.NewErrorResponse(rest.UnauthorizedError, err.Error()))&#13;&#10;&#9;&#9;&#9;return&#13;&#10;&#9;&#9;}&#13;&#10;&#13;&#10;&#9;&#9;if err := c.cartService.RemoveItemFromCart(userID, int64(itemIDInt)); err != nil {&#13;&#10;&#9;&#9;&#9;c.handleCartError(ctx, err)&#13;&#10;&#9;&#9;&#9;return&#13;&#10;&#9;&#9;}&#13;&#10;&#13;&#10;&#9;&#9;ctx.JSON(http.StatusOK, rest.NewAPIResponse(http.StatusOK, &quot;Item removed from cart successfully&quot;, nil))&#13;&#10;&#9;}&#13;&#10;}&#13;&#10;&#13;&#10;func (c *CartController) getUserIDFromContext(ctx *gin.Context) (int64, error) {&#13;&#10;&#9;userID, exists := ctx.Get(&quot;user_id&quot;)&#13;&#10;&#9;if !exists {&#13;&#10;&#9;&#9;return 0, errors.New(&quot;user ID not found in context&quot;)&#13;&#10;&#9;}&#13;&#10;&#13;&#10;&#9;userIDInt64, ok := userID.(int64)&#13;&#10;&#9;if !ok {&#13;&#10;&#9;&#9;return 0, errors.New(&quot;invalid user ID type&quot;)&#13;&#10;&#9;}&#13;&#10;&#13;&#10;&#9;return userIDInt64, nil&#13;&#10;}&#13;&#10;&#13;&#10;func (c *CartController) handleCartError(ctx *gin.Context, err error) {&#13;&#10;&#9;switch {&#13;&#10;&#9;case errors.Is(err, customErr.ErrCartNotFound):&#13;&#10;&#9;&#9;ctx.JSON(http.StatusNotFound, rest.NewErrorResponse(rest.NotFoundError, err.Error()))&#13;&#10;&#9;case errors.Is(err, customErr.ErrCartItemNotFound):&#13;&#10;&#9;&#9;ctx.JSON(http.StatusNotFound, rest.NewErrorResponse(rest.NotFoundError, err.Error()))&#13;&#10;&#9;case errors.Is(err, customErr.ErrCartItemAlreadyExists):&#13;&#10;&#9;&#9;ctx.JSON(http.StatusConflict, rest.NewErrorResponse(rest.ConflictError, err.Error()))&#13;&#10;&#9;default:&#13;&#10;&#9;&#9;ctx.JSON(http.StatusInternalServerError, rest.NewErrorResponse(rest.InternalServerErrorError, &quot;An unexpected error occurred&quot;))&#13;&#10;&#9;}&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/internal/services/cart/internal/entity/cart_item.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/internal/services/cart/internal/entity/cart_item.go" />
              <option name="originalContent" value="package entity&#10;&#10;import (&#10;&#9;&quot;github.com/hthinh24/go-store/internal/pkg/entity&quot;&#10;)&#10;&#10;type CartItem struct {&#10;&#9;entity.BaseEntity&#10;&#9;CartID       int64   `json:&quot;cart_id&quot; gorm:&quot;column:cart_id;not null&quot;`&#10;&#9;ProductID    int64   `json:&quot;product_id&quot; gorm:&quot;column:product_id;not null&quot;`&#10;&#9;ProductSKUID int64   `json:&quot;product_sku_id&quot; gorm:&quot;column:product_sku_id;not null&quot;`&#10;&#9;Quantity     int     `json:&quot;quantity&quot; gorm:&quot;column:quantity;not null;default:1&quot;`&#10;&#9;UnitPrice    float64 `json:&quot;unit_price&quot; gorm:&quot;column:unit_price;not null;type:decimal(10,2)&quot;`&#10;&#9;TotalPrice   float64 `json:&quot;total_price&quot; gorm:&quot;column:total_price;not null;type:decimal(10,2) &lt;-:false&quot;`&#10;&#9;Status       string  `json:&quot;status&quot; gorm:&quot;column:status;not null;default:ACTIVE&quot;`&#10;}&#10;&#10;func (ci CartItem) TableName() string {&#10;&#9;return &quot;cart_item&quot;&#10;}&#10;" />
              <option name="updatedContent" value="package entity&#10;&#10;import (&#10;&#9;&quot;github.com/hthinh24/go-store/internal/pkg/entity&quot;&#10;)&#10;&#10;type CartItem struct {&#10;&#9;entity.BaseEntity&#10;&#9;CartID       int64   `json:&quot;cart_id&quot; gorm:&quot;column:cart_id;not null&quot;`&#10;&#9;ProductID    int64   `json:&quot;product_id&quot; gorm:&quot;column:product_id;not null&quot;`&#10;&#9;ProductSKUID int64   `json:&quot;product_sku_id&quot; gorm:&quot;column:product_sku_id;not null&quot;`&#10;&#9;Quantity     int     `json:&quot;quantity&quot; gorm:&quot;column:quantity;not null;default:1&quot;`&#10;&#9;UnitPrice    float64 `json:&quot;unit_price&quot; gorm:&quot;column:unit_price;not null;type:decimal(10,2)&quot;`&#10;&#9;TotalPrice   float64 `json:&quot;total_price&quot; gorm:&quot;column:total_price;type:decimal(10,2);-&gt;:false;&lt;-:false&quot;`&#10;&#9;Status       string  `json:&quot;status&quot; gorm:&quot;column:status;not null;default:ACTIVE&quot;`&#10;}&#10;&#10;func (ci CartItem) TableName() string {&#10;&#9;return &quot;cart_item&quot;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/internal/services/cart/internal/service/cart_service.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/internal/services/cart/internal/service/cart_service.go" />
              <option name="originalContent" value="package service&#10;&#10;import (&#10;&#9;&quot;context&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/internal/pkg/logger&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/services/cart/internal&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/services/cart/internal/config&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/services/cart/internal/constants&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/services/cart/internal/controller/http/client&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/services/cart/internal/dto/request&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/services/cart/internal/dto/response&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/services/cart/internal/entity&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/services/cart/internal/errors&quot;&#10;&#9;&quot;time&quot;&#10;)&#10;&#10;type cartService struct {&#10;&#9;logger         logger.Logger&#10;&#9;config         config.AppConfig&#10;&#9;cartRepository internal.CartRepository&#10;&#9;productClient  client.ProductClient&#10;}&#10;&#10;func NewCartService(logger logger.Logger, cartRepository internal.CartRepository, productClient client.ProductClient) *cartService {&#10;&#9;return &amp;cartService{&#10;&#9;&#9;logger:         logger,&#10;&#9;&#9;cartRepository: cartRepository,&#10;&#9;&#9;productClient:  productClient,&#10;&#9;}&#10;}&#10;&#10;func (c *cartService) CreateCart(data *request.CreateCartRequest) (*response.CartResponse, error) {&#10;&#9;c.logger.Info(&quot;Creating cart for user ID&quot;, &quot;userID&quot;, data.UserID)&#10;&#10;&#9;// Check if cart already exists for this user&#10;&#9;existingCart, err := c.cartRepository.FindCartByUserID(data.UserID)&#10;&#9;if err == nil &amp;&amp; existingCart != nil {&#10;&#9;&#9;c.logger.Info(&quot;Cart already exists for user&quot;, &quot;userID&quot;, data.UserID, &quot;cartID&quot;, existingCart.ID)&#10;&#9;&#9;// Return existing cart with empty items&#10;&#9;&#9;return c.createCartResponse(existingCart, &amp;[]response.CartItemResponse{}), nil&#10;&#9;}&#10;&#10;&#9;// Create cart entity in service layer&#10;&#9;cart := c.createCartEntity(data.UserID)&#10;&#10;&#9;// Pass entity to repository for persistence&#10;&#9;if err := c.cartRepository.CreateCart(cart); err != nil {&#10;&#9;&#9;c.logger.Error(&quot;Failed to create cart for user&quot;, &quot;userID&quot;, data.UserID, &quot;error&quot;, err)&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;c.logger.Info(&quot;Successfully created cart&quot;, &quot;userID&quot;, data.UserID, &quot;cartID&quot;, cart.ID)&#10;&#9;return c.createCartResponse(cart, &amp;[]response.CartItemResponse{}), nil&#10;}&#10;&#10;func (c *cartService) GetCartItemsByCartID(cartID int64) (*[]response.CartItemResponse, error) {&#10;&#9;items, err := c.cartRepository.FindCartItemsByCartID(cartID)&#10;&#9;if err != nil {&#10;&#9;&#9;c.logger.Error(&quot;Failed to find cart items by cart ID, &quot;, &quot;cartID: &quot;, cartID, &quot;error&quot;, err)&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;// If no items found, return empty cart items response&#10;&#9;if items == nil || len(*items) == 0 {&#10;&#9;&#9;c.logger.Info(&quot;No items found in cart&quot;, &quot;cartID&quot;, cartID)&#10;&#9;&#9;return &amp;[]response.CartItemResponse{}, nil&#10;&#9;}&#10;&#10;&#9;var cartItemResponses []response.CartItemResponse&#10;&#9;for _, item := range *items {&#10;&#9;&#9;cartItemResponse := c.createCartItemResponse(&amp;item)&#10;&#9;&#9;cartItemResponses = append(cartItemResponses, cartItemResponse)&#10;&#9;}&#10;&#10;&#9;return &amp;cartItemResponses, nil&#10;}&#10;&#10;func (c *cartService) GetCartByUserID(userID int64) (*response.CartResponse, error) {&#10;&#9;cart, err := c.cartRepository.FindCartByUserID(userID)&#10;&#9;if err != nil {&#10;&#9;&#9;c.logger.Error(&quot;Failed to get cart by user ID, &quot;, &quot;userID: &quot;, userID, &quot;error&quot;, err)&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;cartItemsResponse, err := c.GetCartItemsByCartID(cart.ID)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;return c.createCartResponse(cart, cartItemsResponse), nil&#10;}&#10;&#10;func (c *cartService) AddItemToCart(userID int64, newItem *request.AddItemRequest) error {&#10;&#9;c.logger.Info(&quot;Adding newItem to cart for user ID&quot;, &quot;userID&quot;, userID)&#10;&#10;&#9;// 1. Find the cart by user ID&#10;&#9;cart, err := c.cartRepository.FindCartByUserID(userID)&#10;&#9;if err != nil {&#10;&#9;&#9;c.logger.Error(&quot;Failed to find cart by user ID&quot;, &quot;userID&quot;, userID, &quot;error&quot;, err)&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;// 2. Get latest price &amp; status of the product SKU using client&#10;&#9;ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)&#10;&#9;defer cancel()&#10;&#10;&#9;productSKUResponse, err := c.productClient.GetProductSKUByID(ctx, newItem.ProductSKUID)&#10;&#9;if err != nil {&#10;&#9;&#9;c.logger.Error(&quot;Failed to get product SKU details&quot;, &quot;productSKUID&quot;, newItem.ProductSKUID, &quot;error&quot;, err)&#10;&#9;&#9;return errors.ErrProductSKUNotFound&#10;&#9;}&#10;&#10;&#9;c.logger.Info(&quot;Stattus: &quot;, productSKUResponse.SKU)&#10;&#9;if productSKUResponse.Status != constants.ProductStatusActive {&#10;&#9;&#9;c.logger.Error(&quot;Product SKU is not active&quot;, &quot;productSKUID&quot;, newItem.ProductSKUID, &quot;status&quot;, productSKUResponse.Status)&#10;&#9;&#9;return errors.ErrProductSKUNotActive&#10;&#9;}&#10;&#10;&#9;// 3. Store the newItem in the cart with latest price&#10;&#9;cartItemEntity := c.createCartItemEntity(cart.ID, productSKUResponse)&#10;&#9;if err := c.cartRepository.AddItemToCart(cartItemEntity); err != nil {&#10;&#9;&#9;c.logger.Error(&quot;Failed to add newItem to cart&quot;, &quot;userID&quot;, userID, &quot;error&quot;, err)&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;return nil&#10;}&#10;&#10;func (c *cartService) UpdateItemQuantity(userID int64, itemID int64, quantity int) error {&#10;&#9;c.logger.Info(&quot;Updating item quantity in cart&quot;, &quot;userID&quot;, userID, &quot;itemID&quot;, itemID, &quot;quantity&quot;, quantity)&#10;&#10;&#9;// 1. Find the cart by user ID&#10;&#9;if _, err := c.cartRepository.FindCartByUserID(userID); err != nil {&#10;&#9;&#9;c.logger.Error(&quot;Failed to find cart by user ID&quot;, &quot;userID&quot;, userID, &quot;error&quot;, err)&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;// 2. Find the cart item by item ID&#10;&#9;if _, err := c.cartRepository.FindCartItemByID(itemID); err != nil {&#10;&#9;&#9;c.logger.Error(&quot;Failed to find cart item by ID&quot;, &quot;itemID&quot;, itemID, &quot;error&quot;, err)&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;// 3. Update the item quantity in the cart&#10;&#9;if err := c.cartRepository.UpdateItemQuantity(itemID, quantity); err != nil {&#10;&#9;&#9;c.logger.Error(&quot;Failed to update cart item quantity&quot;, &quot;itemID&quot;, itemID, &quot;error&quot;, err)&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;return nil&#10;}&#10;&#10;func (c *cartService) RemoveItemFromCart(userID int64, itemID int64) error {&#10;&#9;c.logger.Info(&quot;Removing item from cart&quot;, &quot;userID&quot;, userID, &quot;itemID&quot;, itemID)&#10;&#10;&#9;// 1. Find the cart by user ID&#10;&#9;if _, err := c.cartRepository.FindCartByUserID(userID); err != nil {&#10;&#9;&#9;c.logger.Error(&quot;Failed to find cart by user ID&quot;, &quot;userID&quot;, userID, &quot;error&quot;, err)&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;// 2. Find the cart item by item ID&#10;&#9;if _, err := c.cartRepository.FindCartItemByID(itemID); err != nil {&#10;&#9;&#9;c.logger.Error(&quot;Failed to find cart item by ID&quot;, &quot;itemID&quot;, itemID, &quot;error&quot;, err)&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;// 3. Remove the item from the cart&#10;&#9;if err := c.cartRepository.RemoveItemFromCart(itemID); err != nil {&#10;&#9;&#9;c.logger.Error(&quot;Failed to remove item from cart&quot;, &quot;itemID&quot;, itemID, &quot;error&quot;, err)&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;return nil&#10;}&#10;&#10;func (c *cartService) createCartEntity(userID int64) *entity.Cart {&#10;&#9;return &amp;entity.Cart{&#10;&#9;&#9;UserID: userID,&#10;&#9;&#9;Status: constants.CartStatusActive,&#10;&#9;}&#10;}&#10;&#10;func (c *cartService) createCartItemEntity(cartID int64, productSKUResponse *client.ProductSKUDetailResponse) *entity.CartItem {&#10;&#9;return &amp;entity.CartItem{&#10;&#9;&#9;CartID:       cartID,&#10;&#9;&#9;ProductID:    productSKUResponse.ProductID,&#10;&#9;&#9;ProductSKUID: productSKUResponse.ID,&#10;&#9;&#9;UnitPrice:    productSKUResponse.Price,&#10;&#9;&#9;Status:       productSKUResponse.Status,&#10;&#9;}&#10;}&#10;&#10;func (c *cartService) createCartResponse(cart *entity.Cart, cartItemsResponse *[]response.CartItemResponse) *response.CartResponse {&#10;&#9;return &amp;response.CartResponse{&#10;&#9;&#9;ID:     cart.ID,&#10;&#9;&#9;UserID: cart.UserID,&#10;&#9;&#9;Status: cart.Status,&#10;&#9;&#9;Items:  cartItemsResponse,&#10;&#9;}&#10;}&#10;&#10;func (c *cartService) createCartItemResponse(item *entity.CartItem) response.CartItemResponse {&#10;&#9;return response.CartItemResponse{&#10;&#9;&#9;ID:           item.ID,&#10;&#9;&#9;ProductID:    item.ProductID,&#10;&#9;&#9;ProductSKUID: item.ProductSKUID,&#10;&#9;&#9;Quantity:     item.Quantity,&#10;&#9;&#9;UnitPrice:    item.UnitPrice,&#10;&#9;&#9;TotalPrice:   item.TotalPrice,&#10;&#9;&#9;Status:       item.Status,&#10;&#9;}&#10;}&#10;" />
              <option name="updatedContent" value="package service&#10;&#10;import (&#10;&#9;&quot;context&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/internal/pkg/logger&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/services/cart/internal&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/services/cart/internal/config&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/services/cart/internal/constants&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/services/cart/internal/controller/http/client&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/services/cart/internal/dto/request&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/services/cart/internal/dto/response&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/services/cart/internal/entity&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/services/cart/internal/errors&quot;&#10;&#9;&quot;time&quot;&#10;)&#10;&#10;type cartService struct {&#10;&#9;logger         logger.Logger&#10;&#9;config         config.AppConfig&#10;&#9;cartRepository internal.CartRepository&#10;&#9;productClient  client.ProductClient&#10;}&#10;&#10;func NewCartService(logger logger.Logger, cartRepository internal.CartRepository, productClient client.ProductClient) *cartService {&#10;&#9;return &amp;cartService{&#10;&#9;&#9;logger:         logger,&#10;&#9;&#9;cartRepository: cartRepository,&#10;&#9;&#9;productClient:  productClient,&#10;&#9;}&#10;}&#10;&#10;func (c *cartService) CreateCart(data *request.CreateCartRequest) (*response.CartResponse, error) {&#10;&#9;c.logger.Info(&quot;Creating cart for user ID: &quot;, data.UserID)&#10;&#10;&#9;// Check if cart already exists for this user&#10;&#9;existingCart, err := c.cartRepository.FindCartByUserID(data.UserID)&#10;&#9;if err == nil &amp;&amp; existingCart != nil {&#10;&#9;&#9;c.logger.Info(&quot;Cart already exists for user: &quot;, data.UserID, &quot;, cartID: &quot;, existingCart.ID)&#10;&#9;&#9;// Return existing cart with empty items&#10;&#9;&#9;return c.createCartResponse(existingCart, &amp;[]response.CartItemResponse{}), nil&#10;&#9;}&#10;&#10;&#9;// Create cart entity in service layer&#10;&#9;cart := c.createCartEntity(data.UserID)&#10;&#10;&#9;// Pass entity to repository for persistence&#10;&#9;if err := c.cartRepository.CreateCart(cart); err != nil {&#10;&#9;&#9;c.logger.Error(&quot;Failed to create cart for user: &quot;, data.UserID, &quot;, error: &quot;, err)&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;c.logger.Info(&quot;Successfully created cart for user: &quot;, data.UserID, &quot;, cartID: &quot;, cart.ID)&#10;&#9;return c.createCartResponse(cart, &amp;[]response.CartItemResponse{}), nil&#10;}&#10;&#10;func (c *cartService) GetCartItemsByCartID(cartID int64) (*[]response.CartItemResponse, error) {&#10;&#9;items, err := c.cartRepository.FindCartItemsByCartID(cartID)&#10;&#9;if err != nil {&#10;&#9;&#9;c.logger.Error(&quot;Failed to find cart items by cart ID: &quot;, cartID, &quot;, error: &quot;, err)&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;// If no items found, return empty cart items response&#10;&#9;if items == nil || len(*items) == 0 {&#10;&#9;&#9;c.logger.Info(&quot;No items found in cart: &quot;, cartID)&#10;&#9;&#9;return &amp;[]response.CartItemResponse{}, nil&#10;&#9;}&#10;&#10;&#9;var cartItemResponses []response.CartItemResponse&#10;&#9;for _, item := range *items {&#10;&#9;&#9;cartItemResponse := c.createCartItemResponse(&amp;item)&#10;&#9;&#9;cartItemResponses = append(cartItemResponses, cartItemResponse)&#10;&#9;}&#10;&#10;&#9;return &amp;cartItemResponses, nil&#10;}&#10;&#10;func (c *cartService) GetCartByUserID(userID int64) (*response.CartResponse, error) {&#10;&#9;cart, err := c.cartRepository.FindCartByUserID(userID)&#10;&#9;if err != nil {&#10;&#9;&#9;c.logger.Error(&quot;Failed to get cart by user ID: &quot;, userID, &quot;, error: &quot;, err)&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;cartItemsResponse, err := c.GetCartItemsByCartID(cart.ID)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;return c.createCartResponse(cart, cartItemsResponse), nil&#10;}&#10;&#10;func (c *cartService) AddItemToCart(userID int64, newItem *request.AddItemRequest) error {&#10;&#9;c.logger.Info(&quot;Adding item to cart for user ID: &quot;, userID)&#10;&#10;&#9;// 1. Find the cart by user ID&#10;&#9;cart, err := c.cartRepository.FindCartByUserID(userID)&#10;&#9;if err != nil {&#10;&#9;&#9;c.logger.Error(&quot;Failed to find cart by user ID: &quot;, userID, &quot;, error: &quot;, err)&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;// 2. Get latest price &amp; status of the product SKU using client&#10;&#9;ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)&#10;&#9;defer cancel()&#10;&#10;&#9;productSKUResponse, err := c.productClient.GetProductSKUByID(ctx, newItem.ProductSKUID)&#10;&#9;if err != nil {&#10;&#9;&#9;c.logger.Error(&quot;Failed to get product SKU details: &quot;, newItem.ProductSKUID, &quot;, error: &quot;, err)&#10;&#9;&#9;return errors.ErrProductSKUNotFound&#10;&#9;}&#10;&#10;&#9;c.logger.Info(&quot;Product SKU status: &quot;, productSKUResponse.SKU)&#10;&#9;if productSKUResponse.Status != constants.ProductStatusActive {&#10;&#9;&#9;c.logger.Error(&quot;Product SKU is not active: &quot;, newItem.ProductSKUID, &quot;, status: &quot;, productSKUResponse.Status)&#10;&#9;&#9;return errors.ErrProductSKUNotActive&#10;&#9;}&#10;&#10;&#9;// 3. Store the newItem in the cart with latest price&#10;&#9;cartItemEntity := c.createCartItemEntity(cart.ID, productSKUResponse)&#10;&#9;if err := c.cartRepository.AddItemToCart(cartItemEntity); err != nil {&#10;&#9;&#9;c.logger.Error(&quot;Failed to add item to cart for user: &quot;, userID, &quot;, error: &quot;, err)&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;return nil&#10;}&#10;&#10;func (c *cartService) UpdateItemQuantity(userID int64, itemID int64, quantity int) error {&#10;&#9;c.logger.Info(&quot;Updating item quantity in cart for user: &quot;, userID, &quot;, itemID: &quot;, itemID, &quot;, quantity: &quot;, quantity)&#10;&#10;&#9;// 1. Find the cart by user ID&#10;&#9;if _, err := c.cartRepository.FindCartByUserID(userID); err != nil {&#10;&#9;&#9;c.logger.Error(&quot;Failed to find cart by user ID: &quot;, userID, &quot;, error: &quot;, err)&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;// 2. Find the cart item by item ID&#10;&#9;if _, err := c.cartRepository.FindCartItemByID(itemID); err != nil {&#10;&#9;&#9;c.logger.Error(&quot;Failed to find cart item by ID: &quot;, itemID, &quot;, error: &quot;, err)&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;// 3. Update the item quantity in the cart&#10;&#9;if err := c.cartRepository.UpdateItemQuantity(itemID, quantity); err != nil {&#10;&#9;&#9;c.logger.Error(&quot;Failed to update cart item quantity: &quot;, itemID, &quot;, error: &quot;, err)&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;return nil&#10;}&#10;&#10;func (c *cartService) RemoveItemFromCart(userID int64, itemID int64) error {&#10;&#9;c.logger.Info(&quot;Removing item from cart for user: &quot;, userID, &quot;, itemID: &quot;, itemID)&#10;&#10;&#9;// 1. Find the cart by user ID&#10;&#9;if _, err := c.cartRepository.FindCartByUserID(userID); err != nil {&#10;&#9;&#9;c.logger.Error(&quot;Failed to find cart by user ID: &quot;, userID, &quot;, error: &quot;, err)&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;// 2. Find the cart item by item ID&#10;&#9;if _, err := c.cartRepository.FindCartItemByID(itemID); err != nil {&#10;&#9;&#9;c.logger.Error(&quot;Failed to find cart item by ID: &quot;, itemID, &quot;, error: &quot;, err)&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;// 3. Remove the item from the cart&#10;&#9;if err := c.cartRepository.RemoveItemFromCart(itemID); err != nil {&#10;&#9;&#9;c.logger.Error(&quot;Failed to remove item from cart: &quot;, itemID, &quot;, error: &quot;, err)&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;return nil&#10;}&#10;&#10;func (c *cartService) createCartEntity(userID int64) *entity.Cart {&#10;&#9;return &amp;entity.Cart{&#10;&#9;&#9;UserID: userID,&#10;&#9;&#9;Status: constants.CartStatusActive,&#10;&#9;}&#10;}&#10;&#10;func (c *cartService) createCartItemEntity(cartID int64, productSKUResponse *client.ProductSKUDetailResponse) *entity.CartItem {&#10;&#9;return &amp;entity.CartItem{&#10;&#9;&#9;CartID:       cartID,&#10;&#9;&#9;ProductID:    productSKUResponse.ProductID,&#10;&#9;&#9;ProductSKUID: productSKUResponse.ID,&#10;&#9;&#9;UnitPrice:    productSKUResponse.Price,&#10;&#9;&#9;Status:       productSKUResponse.Status,&#10;&#9;}&#10;}&#10;&#10;func (c *cartService) createCartResponse(cart *entity.Cart, cartItemsResponse *[]response.CartItemResponse) *response.CartResponse {&#10;&#9;return &amp;response.CartResponse{&#10;&#9;&#9;ID:     cart.ID,&#10;&#9;&#9;UserID: cart.UserID,&#10;&#9;&#9;Status: cart.Status,&#10;&#9;&#9;Items:  cartItemsResponse,&#10;&#9;}&#10;}&#10;&#10;func (c *cartService) createCartItemResponse(item *entity.CartItem) response.CartItemResponse {&#10;&#9;return response.CartItemResponse{&#10;&#9;&#9;ID:           item.ID,&#10;&#9;&#9;ProductID:    item.ProductID,&#10;&#9;&#9;ProductSKUID: item.ProductSKUID,&#10;&#9;&#9;Quantity:     item.Quantity,&#10;&#9;&#9;UnitPrice:    item.UnitPrice,&#10;&#9;&#9;TotalPrice:   item.TotalPrice,&#10;&#9;&#9;Status:       item.Status,&#10;&#9;}&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/internal/services/gateway/cmd/main.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/internal/services/gateway/cmd/main.go" />
              <option name="originalContent" value="package main&#10;&#10;import (&#10;&#9;&quot;log&quot;&#10;&#10;&#9;&quot;github.com/gin-gonic/gin&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/internal/pkg/logger&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/services/gateway/internal/config&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/services/gateway/internal/router&quot;&#10;)&#10;&#10;func main() {&#10;&#9;fileName := &quot;.env&quot;&#10;&#10;&#9;// Load configuration&#10;&#9;cfg, _ := config.LoadConfig(fileName)&#10;&#10;&#9;// Initialize logger&#10;&#9;appLogger := logger.WithComponent(&quot;info&quot;, &quot;GATEWAY&quot;)&#10;&#10;&#9;// Create gateway&#10;&#9;gateway := router.NewGateway(cfg, appLogger)&#10;&#10;&#9;// Setup gin router&#10;&#9;r := gin.Default()&#10;&#10;&#9;// Setup routes&#10;&#9;gateway.SetupRoutes(r)&#10;&#10;&#9;// Start server&#10;&#9;appLogger.Info(&quot;Starting Gateway on port&quot;, cfg.Port)&#10;&#9;if err := r.Run(&quot;:&quot; + cfg.Port); err != nil {&#10;&#9;&#9;log.Fatal(&quot;Failed to start server:&quot;, err)&#10;&#9;}&#10;}&#10;" />
              <option name="updatedContent" value="package main&#13;&#10;&#13;&#10;import (&#13;&#10;&#9;&quot;log&quot;&#13;&#10;&#13;&#10;&#9;&quot;github.com/gin-gonic/gin&quot;&#13;&#10;&#9;&quot;github.com/hthinh24/go-store/internal/pkg/logger&quot;&#13;&#10;&#9;&quot;github.com/hthinh24/go-store/internal/services/gateway/internal/config&quot;&#13;&#10;&#9;&quot;github.com/hthinh24/go-store/internal/services/gateway/internal/router&quot;&#13;&#10;)&#13;&#10;&#13;&#10;func main() {&#13;&#10;&#9;configPath := &quot;config.yaml&quot;&#13;&#10;&#13;&#10;&#9;// Load configuration using shared pkg config&#13;&#10;&#9;cfg, err := config.LoadConfig(configPath)&#13;&#10;&#9;if err != nil {&#13;&#10;&#9;&#9;log.Fatal(&quot;Failed to load config:&quot;, err)&#13;&#10;&#9;}&#13;&#10;&#13;&#10;&#9;// Initialize logger&#13;&#10;&#9;appLogger := logger.WithComponent(cfg.Log.Level, &quot;GATEWAY&quot;)&#13;&#10;&#13;&#10;&#9;// Create gateway&#13;&#10;&#9;gateway := router.NewGateway(cfg, appLogger)&#13;&#10;&#13;&#10;&#9;// Setup gin router&#13;&#10;&#9;r := gin.Default()&#13;&#10;&#13;&#10;&#9;// Setup routes&#13;&#10;&#9;gateway.SetupRoutes(r)&#13;&#10;&#13;&#10;&#9;// Start server&#13;&#10;&#9;appLogger.Info(&quot;Starting Gateway on port&quot;, cfg.GetPort())&#13;&#10;&#9;if err := r.Run(cfg.GetServerAddress()); err != nil {&#13;&#10;&#9;&#9;log.Fatal(&quot;Failed to start server:&quot;, err)&#13;&#10;&#9;}&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/internal/services/gateway/config.yaml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/internal/services/gateway/config.yaml" />
              <option name="originalContent" value="environment: &quot;development&quot;&#10;service_name: &quot;gateway&quot;&#10;&#10;# Application Configuration (host and port are here, not in http)&#10;app:&#10;  host: &quot;localhost&quot;&#10;  port: &quot;8000&quot;&#10;&#10;# HTTP Server Configuration (no host/port here - different fields)&#10;http:&#10;  read_timeout: 10&#10;  write_timeout: 10&#10;  max_header_bytes: 1048576&#10;  allowed_origins: &quot;*&quot;&#10;  allowed_methods: &quot;GET,POST,PUT,DELETE,OPTIONS&quot;&#10;  allowed_headers: &quot;Content-Type,Authorization&quot;&#10;  exposed_headers: &quot;&quot;&#10;  allow_credentials: true&#10;&#10;# Logging Configuration&#10;log:&#10;  level: &quot;info&quot;&#10;  format: &quot;json&quot;&#10;  output: &quot;stdout&quot;&#10;  file_path: &quot;&quot;&#10;  max_size: 10&#10;  max_backups: 3&#10;  max_age: 28&#10;  compress: true&#10;&#10;# Services Configuration for inter-service communication&#10;services:&#10;  identity_service_url: &quot;http://localhost:8080&quot;&#10;  product_service_url: &quot;http://localhost:8081&quot;&#10;  cart_service_url: &quot;http://localhost:8082&quot;&#10;  order_service_url: &quot;http://localhost:8083&quot;&#10;  gateway_service_url: &quot;http://localhost:8000&quot;&#10;  notification_service_url: &quot;http://localhost:8084&quot;&#10;  payment_service_url: &quot;http://localhost:8085&quot;&#10;&#10;# JWT Configuration for token validation (different field names)&#10;jwt:&#10;  secret: &quot;${JWT_SECRET:your-secret-key}&quot;&#10;  expiration: &quot;24h&quot;&#10;  issuer: &quot;gostore-gateway&quot;&#10;  audience: &quot;gostore-users&quot;&#10;" />
              <option name="updatedContent" value="environment: &quot;development&quot;&#13;&#10;service_name: &quot;gateway&quot;&#13;&#10;&#13;&#10;# Application Configuration (host and port are here, not in http)&#13;&#10;app:&#13;&#10;  host: &quot;localhost&quot;&#13;&#10;  port: &quot;8000&quot;&#13;&#10;&#13;&#10;# HTTP Server Configuration (no host/port here - different fields)&#13;&#10;http:&#13;&#10;  read_timeout: 10&#13;&#10;  write_timeout: 10&#13;&#10;  max_header_bytes: 1048576&#13;&#10;  allowed_origins: &quot;*&quot;&#13;&#10;  allowed_methods: &quot;GET,POST,PUT,DELETE,OPTIONS&quot;&#13;&#10;  allowed_headers: &quot;Content-Type,Authorization&quot;&#13;&#10;  exposed_headers: &quot;&quot;&#13;&#10;  allow_credentials: true&#13;&#10;&#13;&#10;# Logging Configuration&#13;&#10;log:&#13;&#10;  level: &quot;info&quot;&#13;&#10;  format: &quot;json&quot;&#13;&#10;  output: &quot;stdout&quot;&#13;&#10;  file_path: &quot;&quot;&#13;&#10;  max_size: 10&#13;&#10;  max_backups: 3&#13;&#10;  max_age: 28&#13;&#10;  compress: true&#13;&#10;&#13;&#10;# Services Configuration for inter-service communication&#13;&#10;services:&#13;&#10;  identity_service_url: &quot;http://localhost:8080&quot;&#13;&#10;  product_service_url: &quot;http://localhost:8081&quot;&#13;&#10;  cart_service_url: &quot;http://localhost:8082&quot;&#13;&#10;  order_service_url: &quot;http://localhost:8083&quot;&#13;&#10;  gateway_service_url: &quot;http://localhost:8000&quot;&#13;&#10;  notification_service_url: &quot;http://localhost:8084&quot;&#13;&#10;  payment_service_url: &quot;http://localhost:8085&quot;&#13;&#10;&#13;&#10;# JWT Configuration for token validation (using proper defaults)&#13;&#10;jwt:&#13;&#10;  secret: &quot;your-secret-key&quot;&#13;&#10;  expiration: &quot;24h&quot;&#13;&#10;  issuer: &quot;gostore-gateway&quot;&#13;&#10;  audience: &quot;gostore-users&quot;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/internal/services/gateway/internal/config/config.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/internal/services/gateway/internal/config/config.go" />
              <option name="originalContent" value="package config&#10;&#10;import (&#10;&#9;&quot;fmt&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/internal/pkg/config&quot;&#10;)&#10;&#10;const (&#10;&#9;ApiVersionV1 = &quot;api/v1&quot;&#10;&#9;ApiVersionV2 = &quot;api/v2&quot;&#10;)&#10;&#10;type GatewayConfig struct {&#10;&#9;*config.Config&#10;}&#10;&#10;func LoadConfig(configPath string) (*GatewayConfig, error) {&#10;&#9;// Load shared configuration from pkg&#10;&#9;sharedConfig, err := config.LoadConfig(configPath)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, fmt.Errorf(&quot;error loading shared config: %w&quot;, err)&#10;&#9;}&#10;&#10;&#9;gatewayConfig := &amp;GatewayConfig{&#10;&#9;&#9;Config: sharedConfig,&#10;&#9;}&#10;&#10;&#9;return gatewayConfig, nil&#10;}&#10;&#10;func (c *GatewayConfig) GetServerAddress() string {&#10;&#9;return fmt.Sprintf(&quot;%s:%s&quot;, c.App.Host, c.App.Port)&#10;}&#10;&#10;// Legacy methods for backward compatibility&#10;func (c *GatewayConfig) GetPort() string {&#10;&#9;return c.App.Port&#10;}&#10;&#10;func (c *GatewayConfig) GetIdentityServiceURL() string {&#10;&#9;return c.Services.GetServiceURL(&quot;identity&quot;)&#10;}&#10;&#10;func (c *GatewayConfig) GetProductServiceURL() string {&#10;&#9;return c.Services.GetServiceURL(&quot;product&quot;)&#10;}&#10;&#10;func (c *GatewayConfig) GetCartServiceURL() string {&#10;&#9;return c.Services.GetServiceURL(&quot;cart&quot;)&#10;}&#10;" />
              <option name="updatedContent" value="package config&#10;&#10;import (&#10;&#9;&quot;fmt&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/internal/pkg/config&quot;&#10;)&#10;&#10;const (&#10;&#9;ApiVersionV1 = &quot;api/v1&quot;&#10;&#9;ApiVersionV2 = &quot;api/v2&quot;&#10;)&#10;&#10;type GatewayConfig struct {&#10;&#9;*config.Config&#10;}&#10;&#10;func LoadConfig(configPath string) (*GatewayConfig, error) {&#10;&#9;// Load shared configuration from pkg&#10;&#9;sharedConfig, err := config.LoadConfig(configPath)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, fmt.Errorf(&quot;error loading shared config: %w&quot;, err)&#10;&#9;}&#10;&#10;&#9;gatewayConfig := &amp;GatewayConfig{&#10;&#9;&#9;Config: sharedConfig,&#10;&#9;}&#10;&#10;&#9;return gatewayConfig, nil&#10;}&#10;&#10;func (c *GatewayConfig) GetServerAddress() string {&#10;&#9;return &quot;:&quot; + c.App.Port // Updated to use App.Port instead of HTTP.Port&#10;}&#10;&#10;// Legacy methods for backward compatibility&#10;func (c *GatewayConfig) GetPort() string {&#10;&#9;return c.App.Port // Updated to use App.Port&#10;}&#10;&#10;func (c *GatewayConfig) GetIdentityServiceURL() string {&#10;&#9;return c.Services.GetServiceURL(&quot;identity&quot;)&#10;}&#10;&#10;func (c *GatewayConfig) GetProductServiceURL() string {&#10;&#9;return c.Services.GetServiceURL(&quot;product&quot;)&#10;}&#10;&#10;func (c *GatewayConfig) GetCartServiceURL() string {&#10;&#9;return c.Services.GetServiceURL(&quot;cart&quot;)&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/internal/services/gateway/internal/router/router.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/internal/services/gateway/internal/router/router.go" />
              <option name="originalContent" value="package router&#10;&#10;import (&#10;&#9;&quot;encoding/json&quot;&#10;&#9;&quot;fmt&quot;&#10;&#9;&quot;io&quot;&#10;&#9;&quot;net/http&quot;&#10;&#9;&quot;strings&quot;&#10;&#10;&#9;&quot;github.com/gin-gonic/gin&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/internal/pkg/logger&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/services/gateway/internal/config&quot;&#10;)&#10;&#10;type Gateway struct {&#10;&#9;config *config.GatewayConfig&#10;&#9;logger logger.Logger&#10;&#9;client *http.Client&#10;}&#10;&#10;type VerifyResponse struct {&#10;&#9;UserID      string   `json:&quot;user_id&quot;`&#10;&#9;Roles       []string `json:&quot;roles&quot;`&#10;&#9;Permissions []string `json:&quot;permissions&quot;`&#10;}&#10;&#10;func NewGateway(cfg *config.GatewayConfig, logger logger.Logger) *Gateway {&#10;&#9;return &amp;Gateway{&#10;&#9;&#9;config: cfg,&#10;&#9;&#9;logger: logger,&#10;&#9;&#9;client: &amp;http.Client{},&#10;&#9;}&#10;}&#10;&#10;func (g *Gateway) SetupRoutes(r *gin.Engine) {&#10;&#9;r.Any(&quot;/*path&quot;, g.handleRequest)&#10;}&#10;&#10;// Public endpoints that don't require authentication&#10;var publicEndpoints = map[string][]string{&#10;&#9;&quot;/api/v1/auth/login&quot;:    {&quot;POST&quot;},&#10;&#9;&quot;/api/v1/auth/register&quot;: {&quot;POST&quot;},&#10;&#9;&quot;/api/v1/auth/refresh&quot;:  {&quot;POST&quot;},&#10;&#10;&#9;&quot;/api/v1/users&quot;:         {&quot;POST&quot;}, // Public user list&#10;&#9;&quot;/api/v1/cart/register&quot;: {&quot;POST&quot;}, // Public user list&#10;&#10;&#9;&quot;/api/v1/products/:id&quot;: {&quot;GET&quot;}, // Public product details&#10;&#9;&quot;/api/v1/products&quot;:     {&quot;GET&quot;},&#10;}&#10;&#10;func (g *Gateway) handleRequest(c *gin.Context) {&#10;&#9;path := c.Request.URL.Path&#10;&#9;method := c.Request.Method&#10;&#10;&#9;g.logger.Info(&quot;Received request, &quot;, &quot;path: &quot;, path, &quot; | &quot;, &quot;method: &quot;, method)&#10;&#10;&#9;// Check if endpoint is public&#10;&#9;if g.isPublicEndpoint(path, method) {&#10;&#9;&#9;g.forwardToService(c, path)&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;// For non-public endpoints, verify auth with identity service&#10;&#9;authToken := c.GetHeader(&quot;Authorization&quot;)&#10;&#9;if authToken == &quot;&quot; {&#10;&#9;&#9;c.JSON(http.StatusUnauthorized, gin.H{&quot;error&quot;: &quot;Authorization header required&quot;})&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;// Verify token with identity service&#10;&#9;authResp, err := g.verifyWithIdentityService(authToken)&#10;&#9;if err != nil {&#10;&#9;&#9;g.logger.Error(&quot;Auth verification failed, error: &quot;, err)&#10;&#9;&#9;c.JSON(http.StatusUnauthorized, gin.H{&quot;error&quot;: &quot;Invalid token&quot;})&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;// Add user info to headers&#10;&#9;c.Request.Header.Set(&quot;X-User-ID&quot;, authResp.UserID)&#10;&#9;c.Request.Header.Set(&quot;X-User-Roles&quot;, strings.Join(authResp.Roles, &quot;,&quot;))&#10;&#9;c.Request.Header.Set(&quot;X-User-Permissions&quot;, strings.Join(authResp.Permissions, &quot;,&quot;))&#10;&#10;&#9;// Forward to appropriate service&#10;&#9;g.forwardToService(c, path)&#10;}&#10;&#10;func (g *Gateway) isPublicEndpoint(path, method string) bool {&#10;&#9;for publicPath, methods := range publicEndpoints {&#10;&#9;&#9;if strings.HasPrefix(path, publicPath) {&#10;&#9;&#9;&#9;for _, acceptMethod := range methods {&#10;&#9;&#9;&#9;&#9;if acceptMethod == method {&#10;&#9;&#9;&#9;&#9;&#9;return true&#10;&#9;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;return false&#10;}&#10;&#10;func (g *Gateway) verifyWithIdentityService(authToken string) (*VerifyResponse, error) {&#10;&#9;req, err := http.NewRequest(&quot;GET&quot;,&#10;&#9;&#9;g.config.GetIdentityServiceURL()+&quot;/&quot;+config.ApiVersionV1+&quot;/auth/verify&quot;, nil)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;req.Header.Set(&quot;Authorization&quot;, authToken)&#10;&#10;&#9;resp, err := g.client.Do(req)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#9;defer resp.Body.Close()&#10;&#10;&#9;if resp.StatusCode != http.StatusOK {&#10;&#9;&#9;return nil, fmt.Errorf(&quot;auth verification failed with status: %d&quot;, resp.StatusCode)&#10;&#9;}&#10;&#10;&#9;var verifyResponse VerifyResponse&#10;&#9;if err := json.NewDecoder(resp.Body).Decode(&amp;verifyResponse); err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;return &amp;verifyResponse, nil&#10;}&#10;&#10;func (g *Gateway) forwardToService(c *gin.Context, path string) {&#10;&#9;var targetURL string&#10;&#10;&#9;// Route to appropriate service based on path&#10;&#9;if strings.HasPrefix(path, &quot;/&quot;+config.ApiVersionV1+&quot;/auth&quot;) ||&#10;&#9;&#9;strings.HasPrefix(path, &quot;/&quot;+config.ApiVersionV1+&quot;/users&quot;) {&#10;&#9;&#9;targetURL = g.config.GetIdentityServiceURL() + path&#10;&#9;} else if strings.HasPrefix(path, &quot;/&quot;+config.ApiVersionV1+&quot;/products&quot;) {&#10;&#9;&#9;targetURL = g.config.GetProductServiceURL() + path&#10;&#9;} else if strings.HasPrefix(path, &quot;/&quot;+config.ApiVersionV1+&quot;/cart&quot;) {&#10;&#9;&#9;targetURL = g.config.GetCartServiceURL() + path&#10;&#9;} else {&#10;&#9;&#9;g.logger.Warn(&quot;No service found for path&quot;, &quot; path: &quot;, path)&#10;&#9;&#9;c.JSON(http.StatusNotFound, gin.H{&quot;error&quot;: &quot;page not found&quot;})&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;// Create new request&#10;&#9;req, err := http.NewRequest(c.Request.Method, targetURL, c.Request.Body)&#10;&#9;if err != nil {&#10;&#9;&#9;g.logger.Error(&quot;Failed to create request&quot;, err)&#10;&#9;&#9;c.JSON(http.StatusInternalServerError, gin.H{&quot;error&quot;: &quot;Internal server error&quot;})&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;// Copy headers&#10;&#9;for key, values := range c.Request.Header {&#10;&#9;&#9;for _, value := range values {&#10;&#9;&#9;&#9;req.Header.Add(key, value)&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;// Forward request&#10;&#9;resp, err := g.client.Do(req)&#10;&#9;if err != nil {&#10;&#9;&#9;g.logger.Error(&quot;Failed to forward request&quot;, err)&#10;&#9;&#9;c.JSON(http.StatusInternalServerError, gin.H{&quot;error&quot;: &quot;Service unavailable&quot;})&#10;&#9;&#9;return&#10;&#9;}&#10;&#9;defer resp.Body.Close()&#10;&#10;&#9;// Copy response headers&#10;&#9;for key, values := range resp.Header {&#10;&#9;&#9;for _, value := range values {&#10;&#9;&#9;&#9;c.Header(key, value)&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;// Copy response&#10;&#9;c.Status(resp.StatusCode)&#10;&#9;io.Copy(c.Writer, resp.Body)&#10;}&#10;" />
              <option name="updatedContent" value="package router&#10;&#10;import (&#10;&#9;&quot;encoding/json&quot;&#10;&#9;&quot;fmt&quot;&#10;&#9;&quot;io&quot;&#10;&#9;&quot;net/http&quot;&#10;&#9;&quot;strings&quot;&#10;&#10;&#9;&quot;github.com/gin-gonic/gin&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/internal/pkg/logger&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/services/gateway/internal/config&quot;&#10;)&#10;&#10;type Gateway struct {&#10;&#9;config *config.GatewayConfig&#10;&#9;logger logger.Logger&#10;&#9;client *http.Client&#10;}&#10;&#10;type VerifyResponse struct {&#10;&#9;UserID      string   `json:&quot;user_id&quot;`&#10;&#9;Roles       []string `json:&quot;roles&quot;`&#10;&#9;Permissions []string `json:&quot;permissions&quot;`&#10;}&#10;&#10;func NewGateway(cfg *config.GatewayConfig, logger logger.Logger) *Gateway {&#10;&#9;return &amp;Gateway{&#10;&#9;&#9;config: cfg,&#10;&#9;&#9;logger: logger,&#10;&#9;&#9;client: &amp;http.Client{},&#10;&#9;}&#10;}&#10;&#10;func (g *Gateway) SetupRoutes(r *gin.Engine) {&#10;&#9;r.Any(&quot;/*path&quot;, g.handleRequest)&#10;}&#10;&#10;// Public endpoints that don't require authentication&#10;var publicEndpoints = map[string][]string{&#10;&#9;&quot;/api/v1/auth/login&quot;:    {&quot;POST&quot;},&#10;&#9;&quot;/api/v1/auth/register&quot;: {&quot;POST&quot;},&#10;&#9;&quot;/api/v1/auth/refresh&quot;:  {&quot;POST&quot;},&#10;&#10;&#9;&quot;/api/v1/users&quot;:         {&quot;POST&quot;}, // Public user list&#10;&#9;&quot;/api/v1/cart/register&quot;: {&quot;POST&quot;}, // Public user list&#10;&#10;&#9;&quot;/api/v1/products/:id&quot;: {&quot;GET&quot;}, // Public product details&#10;&#9;&quot;/api/v1/products&quot;:     {&quot;GET&quot;},&#10;}&#10;&#10;func (g *Gateway) handleRequest(c *gin.Context) {&#10;&#9;path := c.Request.URL.Path&#10;&#9;method := c.Request.Method&#10;&#10;&#9;g.logger.Info(&quot;Received request, &quot;, &quot;path: &quot;, path, &quot; | &quot;, &quot;method: &quot;, method)&#10;&#10;&#9;// Check if endpoint is public&#10;&#9;if g.isPublicEndpoint(path, method) {&#10;&#9;&#9;g.forwardToService(c, path)&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;// For non-public endpoints, verify auth with identity service&#10;&#9;authToken := c.GetHeader(&quot;Authorization&quot;)&#10;&#9;if authToken == &quot;&quot; {&#10;&#9;&#9;c.JSON(http.StatusUnauthorized, gin.H{&quot;error&quot;: &quot;Authorization header required&quot;})&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;// Verify token with identity service&#10;&#9;authResp, err := g.verifyWithIdentityService(authToken)&#10;&#9;if err != nil {&#10;&#9;&#9;g.logger.Error(&quot;Auth verification failed, error: &quot;, err)&#10;&#9;&#9;c.JSON(http.StatusUnauthorized, gin.H{&quot;error&quot;: &quot;Invalid token&quot;})&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;// Add user info to headers&#10;&#9;c.Request.Header.Set(&quot;X-User-ID&quot;, authResp.UserID)&#10;&#9;c.Request.Header.Set(&quot;X-User-Roles&quot;, strings.Join(authResp.Roles, &quot;,&quot;))&#10;&#9;c.Request.Header.Set(&quot;X-User-Permissions&quot;, strings.Join(authResp.Permissions, &quot;,&quot;))&#10;&#10;&#9;// Forward to appropriate service&#10;&#9;g.forwardToService(c, path)&#10;}&#10;&#10;func (g *Gateway) isPublicEndpoint(path, method string) bool {&#10;&#9;for publicPath, methods := range publicEndpoints {&#10;&#9;&#9;if strings.HasPrefix(path, publicPath) {&#10;&#9;&#9;&#9;for _, acceptMethod := range methods {&#10;&#9;&#9;&#9;&#9;if acceptMethod == method {&#10;&#9;&#9;&#9;&#9;&#9;return true&#10;&#9;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;return false&#10;}&#10;&#10;func (g *Gateway) verifyWithIdentityService(authToken string) (*VerifyResponse, error) {&#10;&#9;req, err := http.NewRequest(&quot;GET&quot;,&#10;&#9;&#9;g.config.GetIdentityServiceURL()+&quot;/&quot;+config.ApiVersionV1+&quot;/auth/verify&quot;, nil)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;req.Header.Set(&quot;Authorization&quot;, authToken)&#10;&#10;&#9;resp, err := g.client.Do(req)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#9;defer resp.Body.Close()&#10;&#10;&#9;if resp.StatusCode != http.StatusOK {&#10;&#9;&#9;return nil, fmt.Errorf(&quot;auth verification failed with status: %d&quot;, resp.StatusCode)&#10;&#9;}&#10;&#10;&#9;var verifyResponse VerifyResponse&#10;&#9;if err := json.NewDecoder(resp.Body).Decode(&amp;verifyResponse); err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;return &amp;verifyResponse, nil&#10;}&#10;&#10;func (g *Gateway) forwardToService(c *gin.Context, path string) {&#10;&#9;var targetURL string&#10;&#10;&#9;// Route to appropriate service based on path&#10;&#9;if strings.HasPrefix(path, &quot;/&quot;+config.ApiVersionV1+&quot;/auth&quot;) ||&#10;&#9;&#9;strings.HasPrefix(path, &quot;/&quot;+config.ApiVersionV1+&quot;/users&quot;) {&#10;&#9;&#9;targetURL = g.config.GetIdentityServiceURL() + path&#10;&#9;} else if strings.HasPrefix(path, &quot;/&quot;+config.ApiVersionV1+&quot;/products&quot;) {&#10;&#9;&#9;targetURL = g.config.GetProductServiceURL() + path&#10;&#9;} else if strings.HasPrefix(path, &quot;/&quot;+config.ApiVersionV1+&quot;/cart&quot;) {&#10;&#9;&#9;targetURL = g.config.GetCartServiceURL() + path&#10;&#9;} else {&#10;&#9;&#9;g.logger.Warn(&quot;No service found for path: &quot;, path)&#10;&#9;&#9;c.JSON(http.StatusNotFound, gin.H{&quot;error&quot;: &quot;page not found&quot;})&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;// Create new request&#10;&#9;req, err := http.NewRequest(c.Request.Method, targetURL, c.Request.Body)&#10;&#9;if err != nil {&#10;&#9;&#9;g.logger.Error(&quot;Failed to create request&quot;, err)&#10;&#9;&#9;c.JSON(http.StatusInternalServerError, gin.H{&quot;error&quot;: &quot;Internal server error&quot;})&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;// Copy headers&#10;&#9;for key, values := range c.Request.Header {&#10;&#9;&#9;for _, value := range values {&#10;&#9;&#9;&#9;req.Header.Add(key, value)&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;// Forward request&#10;&#9;resp, err := g.client.Do(req)&#10;&#9;if err != nil {&#10;&#9;&#9;g.logger.Error(&quot;Failed to forward request&quot;, err)&#10;&#9;&#9;c.JSON(http.StatusInternalServerError, gin.H{&quot;error&quot;: &quot;Service unavailable&quot;})&#10;&#9;&#9;return&#10;&#9;}&#10;&#9;defer resp.Body.Close()&#10;&#10;&#9;// Copy response headers&#10;&#9;for key, values := range resp.Header {&#10;&#9;&#9;for _, value := range values {&#10;&#9;&#9;&#9;c.Header(key, value)&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;// Copy response&#10;&#9;c.Status(resp.StatusCode)&#10;&#9;io.Copy(c.Writer, resp.Body)&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/internal/services/identity/cmd/main.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/internal/services/identity/cmd/main.go" />
              <option name="originalContent" value="package main&#10;&#10;import (&#10;&#9;&quot;errors&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/services/identity&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/services/identity/internal/config&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/services/identity/internal/constants&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/services/identity/internal/controller/http/client&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/services/identity/internal/controller/http/v1&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/services/identity/internal/entity&quot;&#10;&#9;customErr &quot;github.com/hthinh24/go-store/services/identity/internal/errors&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/services/identity/internal/middleware&quot;&#10;&#9;repository &quot;github.com/hthinh24/go-store/services/identity/internal/repository/postgres&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/services/identity/internal/service&quot;&#10;&#9;&quot;golang.org/x/crypto/bcrypt&quot;&#10;&#9;&quot;gorm.io/driver/postgres&quot;&#10;&#9;&quot;log&quot;&#10;&#9;&quot;time&quot;&#10;&#10;&#9;&quot;github.com/gin-gonic/gin&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/internal/pkg/logger&quot;&#10;&#9;&quot;gorm.io/gorm&quot;&#10;)&#10;&#10;func main() {&#10;&#9;// Load configuration from environment variables&#10;&#9;cfg, err := config.LoadConfig(&quot;.env&quot;)&#10;&#9;if err != nil {&#10;&#9;&#9;log.Fatalf(&quot;Failed to load config: %v&quot;, err)&#10;&#9;}&#10;&#10;&#9;// Initialize logger&#10;&#9;appLogger := logger.NewAppLogger(cfg.LogLevel)&#10;&#9;appLogger.Info(&quot;Starting Identity Service...&quot;)&#10;&#9;appLogger.Info(&quot;Environment: %s&quot;, cfg.Environment)&#10;&#10;&#9;// Initialize database connection&#10;&#9;db, err := initDatabase(cfg)&#10;&#9;if err != nil {&#10;&#9;&#9;appLogger.Error(&quot;Failed to connect to database: %v&quot;, err)&#10;&#9;&#9;log.Fatal(err)&#10;&#9;}&#10;&#9;appLogger.Info(&quot;Database connected successfully&quot;)&#10;&#10;&#9;// Initialize repositories&#10;&#9;userRepo := repository.NewUserRepository(logger.WithComponent(cfg.LogLevel, &quot;USER-REPOSITORY&quot;), db)&#10;&#9;authRepo := repository.NewAuthRepository(logger.WithComponent(cfg.LogLevel, &quot;AUTH-REPOSITORY&quot;), db)&#10;&#10;&#9;// Initialize external service clients&#10;&#9;var cartClient client.CartClient&#10;&#9;if cfg.CartServiceURL != &quot;&quot; {&#10;&#9;&#9;cartClient = client.NewCartClient(cfg.CartServiceURL)&#10;&#9;&#9;appLogger.Info(&quot;Cart service client initialized with URL: %s&quot;, cfg.CartServiceURL)&#10;&#9;} else {&#10;&#9;&#9;appLogger.Warn(&quot;Cart service URL not configured, cart creation will be skipped&quot;)&#10;&#9;&#9;cartClient = client.NewCartClient(&quot;&quot;) // This will effectively disable cart creation&#10;&#9;}&#10;&#10;&#9;// Initialize services&#10;&#9;authService := service.NewAuthService(logger.WithComponent(cfg.LogLevel, &quot;AUTH-SERVICE&quot;), userRepo, authRepo, cfg)&#10;&#9;userService := service.NewUserService(logger.WithComponent(cfg.LogLevel, &quot;USER-SERVICE&quot;), userRepo, authRepo, cartClient)&#10;&#10;&#9;// Initialize middleware&#10;&#9;authMiddleware := middleware.NewAuthMiddleware(logger.WithComponent(cfg.LogLevel, &quot;AUTH-MIDDLEWARE&quot;), cfg.JWTSecret)&#10;&#10;&#9;// Initialize controllers&#10;&#9;authController := v1.NewAuthController(logger.WithComponent(cfg.LogLevel, &quot;AUTH-CONTROLLER&quot;), authService)&#10;&#9;userController := v1.NewUserController(logger.WithComponent(cfg.LogLevel, &quot;USER-CONTROLLER&quot;), userService)&#10;&#10;&#9;// Setup router&#10;&#9;router := setupRouter(authController, userController, authMiddleware)&#10;&#10;&#9;// Initialize user data&#10;&#9;if err := initUserData(userRepo, authRepo); err != nil {&#10;&#9;&#9;appLogger.Error(&quot;Failed to initialize user data: %v&quot;, err)&#10;&#9;&#9;log.Fatal(err)&#10;&#9;} else {&#10;&#9;&#9;appLogger.Info(&quot;User data initialized successfully&quot;)&#10;&#9;}&#10;&#10;&#9;// Start server&#10;&#9;serverAddr := cfg.GetServerAddress()&#10;&#9;appLogger.Info(&quot;Server starting on %s&quot;, serverAddr)&#10;&#9;if err := router.Run(serverAddr); err != nil {&#10;&#9;&#9;appLogger.Error(&quot;Failed to start server: %v&quot;, err)&#10;&#9;&#9;log.Fatal(err)&#10;&#9;}&#10;}&#10;&#10;func initDatabase(cfg *config.AppConfig) (*gorm.DB, error) {&#10;&#9;db, err := gorm.Open(postgres.Open(cfg.GetDatabaseURL()), &amp;gorm.Config{})&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;return db, nil&#10;}&#10;&#10;func setupRouter(authController *v1.AuthController, userController *v1.UserController, authMiddleware *middleware.AuthMiddleware) *gin.Engine {&#10;&#9;router := gin.Default()&#10;&#10;&#9;// Health check endpoint&#10;&#9;router.GET(&quot;/health&quot;, func(c *gin.Context) {&#10;&#9;&#9;c.JSON(200, gin.H{&quot;status&quot;: &quot;healthy&quot;})&#10;&#9;})&#10;&#10;&#9;// API routes&#10;&#9;api := router.Group(&quot;/api/v1&quot;)&#10;&#9;{&#10;&#9;&#9;auth := api.Group(&quot;/auth&quot;)&#10;&#9;&#9;users := api.Group(&quot;/users&quot;)&#10;&#10;&#9;&#9;// Public routes&#10;&#9;&#9;{&#10;&#9;&#9;&#9;users.POST(&quot;&quot;, userController.CreateUser())&#10;&#10;&#9;&#9;&#9;auth.POST(&quot;/login&quot;, authController.Login())&#10;&#9;&#9;&#9;auth.GET(&quot;/verify&quot;, authController.Verify())&#10;&#9;&#9;}&#10;&#10;&#9;&#9;auth.Use(authMiddleware.AuthRequired())&#10;&#9;&#9;{&#10;&#9;&#9;&#9;// TODO - Create login, register, logout endpoints&#10;&#9;&#9;&#9;//auth.POST(&quot;/register&quot;, authController.Register())&#10;&#9;&#9;&#9;//auth.POST(&quot;/logout&quot;, authMiddleware.AuthRequired(), authController.Logout())&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// User routes (protected)&#10;&#9;&#9;users.Use(authMiddleware.AuthRequired())&#10;&#9;&#9;{&#10;&#9;&#9;&#9;users.GET(&quot;:id&quot;, userController.GetUserByID())&#10;&#10;&#9;&#9;&#9;users.PUT(&quot;/:id/profile&quot;, userController.UpdateUserProfile())&#10;&#9;&#9;&#9;users.PATCH(&quot;/:id/register-merchant&quot;,&#10;&#9;&#9;&#9;&#9;userController.UpdateToMerchantAccount())&#10;&#9;&#9;&#9;users.PATCH(&quot;/:id/password&quot;, userController.UpdateUserPassword())&#10;&#9;&#9;&#9;users.DELETE(&quot;/:id&quot;, userController.DeleteUser())&#10;&#10;&#9;&#9;&#9;// Admin only routes&#10;&#9;&#9;&#9;users.GET(&quot;&quot;, authMiddleware.RequireRole(&quot;admin&quot;), userController.GetUsers())&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;return router&#10;}&#10;&#10;func initUserData(userRepository identity.UserRepository, authRepository identity.AuthRepository) error {&#10;&#9;user, err := userRepository.FindUserByID(1)&#10;&#9;if user != nil {&#10;&#9;&#9;return nil&#10;&#9;}&#10;&#10;&#9;// Create admin user if it does not exist&#10;&#9;if errors.Is(err, customErr.ErrUserNotFound{}) {&#10;&#9;&#9;user = createAdminUser()&#10;&#9;&#9;if err := userRepository.CreateUser(user); err != nil {&#10;&#9;&#9;&#9;return err&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;// Assign admin role to the user&#10;&#9;role, err := authRepository.FindRoleByName(string(constants.RoleAdmin))&#10;&#9;if err != nil {&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;adminRole := entity.UserRoles{&#10;&#9;&#9;UserID: user.ID,&#10;&#9;&#9;RoleID: role.ID,&#10;&#9;}&#10;&#10;&#9;if err := authRepository.AddRoleToUser(&amp;adminRole); err != nil {&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;log.Printf(&quot;Admin user initialized: %s&quot;, user.Email)&#10;&#9;return nil&#10;}&#10;&#10;func createAdminUser() *entity.User {&#10;&#9;password := &quot;admin&quot;&#10;&#9;hashedPassword, _ := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)&#10;&#10;&#9;return &amp;entity.User{&#10;&#9;&#9;Email:        &quot;test@gmail.com&quot;,&#10;&#9;&#9;Password:     string(hashedPassword),&#10;&#9;&#9;ProviderID:   &quot;1&quot;,&#10;&#9;&#9;ProviderName: &quot;app&quot;,&#10;&#9;&#9;LastName:     &quot;Admin&quot;,&#10;&#9;&#9;FirstName:    &quot;Admin&quot;,&#10;&#9;&#9;Avatar:       &quot;https://example.com/avatar.png&quot;,&#10;&#9;&#9;Gender:       string(constants.GenderOther),&#10;&#9;&#9;PhoneNumber:  &quot;1234567890&quot;,&#10;&#9;&#9;DateOfBirth:  time.Now(),&#10;&#9;&#9;Status:       string(constants.UserStatusActive),&#10;&#9;}&#10;}&#10;" />
              <option name="updatedContent" value="package main&#13;&#10;&#13;&#10;import (&#13;&#10;&#9;&quot;errors&quot;&#13;&#10;&#9;&quot;github.com/hthinh24/go-store/services/identity&quot;&#13;&#10;&#9;&quot;github.com/hthinh24/go-store/internal/services/identity/internal/config&quot;&#13;&#10;&#9;&quot;github.com/hthinh24/go-store/internal/services/identity/internal/constants&quot;&#13;&#10;&#9;&quot;github.com/hthinh24/go-store/internal/services/identity/internal/controller/http/client&quot;&#13;&#10;&#9;&quot;github.com/hthinh24/go-store/internal/services/identity/internal/controller/http/v1&quot;&#13;&#10;&#9;&quot;github.com/hthinh24/go-store/internal/services/identity/internal/entity&quot;&#13;&#10;&#9;customErr &quot;github.com/hthinh24/go-store/internal/services/identity/internal/errors&quot;&#13;&#10;&#9;&quot;github.com/hthinh24/go-store/internal/services/identity/internal/middleware&quot;&#13;&#10;&#9;repository &quot;github.com/hthinh24/go-store/internal/services/identity/internal/repository/postgres&quot;&#13;&#10;&#9;&quot;github.com/hthinh24/go-store/internal/services/identity/internal/service&quot;&#13;&#10;&#9;&quot;golang.org/x/crypto/bcrypt&quot;&#13;&#10;&#9;&quot;gorm.io/driver/postgres&quot;&#13;&#10;&#9;&quot;log&quot;&#13;&#10;&#9;&quot;time&quot;&#13;&#10;&#13;&#10;&#9;&quot;github.com/gin-gonic/gin&quot;&#13;&#10;&#9;&quot;github.com/hthinh24/go-store/internal/pkg/logger&quot;&#13;&#10;&#9;&quot;gorm.io/gorm&quot;&#13;&#10;)&#13;&#10;&#13;&#10;func main() {&#13;&#10;&#9;configPath := &quot;config.yaml&quot;&#13;&#10;&#13;&#10;&#9;// Load configuration using shared pkg config&#13;&#10;&#9;cfg, err := config.LoadConfig(configPath)&#13;&#10;&#9;if err != nil {&#13;&#10;&#9;&#9;log.Fatalf(&quot;Failed to load config: %v&quot;, err)&#13;&#10;&#9;}&#13;&#10;&#13;&#10;&#9;// Initialize logger&#13;&#10;&#9;appLogger := logger.NewAppLogger(cfg.GetLogLevel())&#13;&#10;&#9;appLogger.Info(&quot;Starting Identity Service...&quot;)&#13;&#10;&#9;appLogger.Info(&quot;Environment: %s&quot;, cfg.GetEnvironment())&#13;&#10;&#13;&#10;&#9;// Initialize database connection&#13;&#10;&#9;db, err := initDatabase(cfg)&#13;&#10;&#9;if err != nil {&#13;&#10;&#9;&#9;appLogger.Error(&quot;Failed to connect to database: %v&quot;, err)&#13;&#10;&#9;&#9;log.Fatal(err)&#13;&#10;&#9;}&#13;&#10;&#9;appLogger.Info(&quot;Database connected successfully&quot;)&#13;&#10;&#13;&#10;&#9;// Initialize repositories&#13;&#10;&#9;userRepo := repository.NewUserRepository(logger.WithComponent(cfg.GetLogLevel(), &quot;USER-REPOSITORY&quot;), db)&#13;&#10;&#9;authRepo := repository.NewAuthRepository(logger.WithComponent(cfg.GetLogLevel(), &quot;AUTH-REPOSITORY&quot;), db)&#13;&#10;&#13;&#10;&#9;// Initialize external service clients&#13;&#10;&#9;var cartClient client.CartClient&#13;&#10;&#9;if cfg.GetCartServiceURL() != &quot;&quot; {&#13;&#10;&#9;&#9;cartClient = client.NewCartClient(cfg.GetCartServiceURL())&#13;&#10;&#9;&#9;appLogger.Info(&quot;Cart service client initialized with URL: %s&quot;, cfg.GetCartServiceURL())&#13;&#10;&#9;} else {&#13;&#10;&#9;&#9;appLogger.Warn(&quot;Cart service URL not configured, cart creation will be skipped&quot;)&#13;&#10;&#9;&#9;cartClient = client.NewCartClient(&quot;&quot;) // This will effectively disable cart creation&#13;&#10;&#9;}&#13;&#10;&#13;&#10;&#9;// Initialize services&#13;&#10;&#9;authService := service.NewAuthService(logger.WithComponent(cfg.GetLogLevel(), &quot;AUTH-SERVICE&quot;), userRepo, authRepo, cfg)&#13;&#10;&#9;userService := service.NewUserService(logger.WithComponent(cfg.GetLogLevel(), &quot;USER-SERVICE&quot;), userRepo, authRepo, cartClient)&#13;&#10;&#13;&#10;&#9;// Initialize middleware&#13;&#10;&#9;authMiddleware := middleware.NewAuthMiddleware(logger.WithComponent(cfg.GetLogLevel(), &quot;AUTH-MIDDLEWARE&quot;), cfg.GetJWTSecret())&#13;&#10;&#13;&#10;&#9;// Initialize controllers&#13;&#10;&#9;authController := v1.NewAuthController(logger.WithComponent(cfg.GetLogLevel(), &quot;AUTH-CONTROLLER&quot;), authService)&#13;&#10;&#9;userController := v1.NewUserController(logger.WithComponent(cfg.GetLogLevel(), &quot;USER-CONTROLLER&quot;), userService)&#13;&#10;&#13;&#10;&#9;// Setup router&#13;&#10;&#9;router := setupRouter(authController, userController, authMiddleware)&#13;&#10;&#13;&#10;&#9;// Initialize user data&#13;&#10;&#9;if err := initUserData(userRepo, authRepo); err != nil {&#13;&#10;&#9;&#9;appLogger.Error(&quot;Failed to initialize user data: %v&quot;, err)&#13;&#10;&#9;&#9;log.Fatal(err)&#13;&#10;&#9;} else {&#13;&#10;&#9;&#9;appLogger.Info(&quot;User data initialized successfully&quot;)&#13;&#10;&#9;}&#13;&#10;&#13;&#10;&#9;// Start server&#13;&#10;&#9;serverAddr := cfg.GetServerAddress()&#13;&#10;&#9;appLogger.Info(&quot;Server starting on %s&quot;, serverAddr)&#13;&#10;&#9;if err := router.Run(serverAddr); err != nil {&#13;&#10;&#9;&#9;appLogger.Error(&quot;Failed to start server: %v&quot;, err)&#13;&#10;&#9;&#9;log.Fatal(err)&#13;&#10;&#9;}&#13;&#10;}&#13;&#10;&#13;&#10;func initDatabase(cfg *config.AppConfig) (*gorm.DB, error) {&#13;&#10;&#9;db, err := gorm.Open(postgres.Open(cfg.GetDatabaseURL()), &amp;gorm.Config{})&#13;&#10;&#9;if err != nil {&#13;&#10;&#9;&#9;return nil, err&#13;&#10;&#9;}&#13;&#10;&#13;&#10;&#9;return db, nil&#13;&#10;}&#13;&#10;&#13;&#10;func setupRouter(authController *v1.AuthController, userController *v1.UserController, authMiddleware *middleware.AuthMiddleware) *gin.Engine {&#13;&#10;&#9;router := gin.Default()&#13;&#10;&#13;&#10;&#9;// Health check endpoint&#13;&#10;&#9;router.GET(&quot;/health&quot;, func(c *gin.Context) {&#13;&#10;&#9;&#9;c.JSON(200, gin.H{&quot;status&quot;: &quot;healthy&quot;})&#13;&#10;&#9;})&#13;&#10;&#13;&#10;&#9;// API routes&#13;&#10;&#9;api := router.Group(&quot;/api/v1&quot;)&#13;&#10;&#9;{&#13;&#10;&#9;&#9;auth := api.Group(&quot;/auth&quot;)&#13;&#10;&#9;&#9;users := api.Group(&quot;/users&quot;)&#13;&#10;&#13;&#10;&#9;&#9;// Public routes&#13;&#10;&#9;&#9;{&#13;&#10;&#9;&#9;&#9;users.POST(&quot;&quot;, userController.CreateUser())&#13;&#10;&#13;&#10;&#9;&#9;&#9;auth.POST(&quot;/login&quot;, authController.Login())&#13;&#10;&#9;&#9;&#9;auth.GET(&quot;/verify&quot;, authController.Verify())&#13;&#10;&#9;&#9;}&#13;&#10;&#13;&#10;&#9;&#9;auth.Use(authMiddleware.AuthRequired())&#13;&#10;&#9;&#9;{&#13;&#10;&#9;&#9;&#9;// TODO - Create login, register, logout endpoints&#13;&#10;&#9;&#9;&#9;//auth.POST(&quot;/register&quot;, authController.Register())&#13;&#10;&#9;&#9;&#9;//auth.POST(&quot;/logout&quot;, authMiddleware.AuthRequired(), authController.Logout())&#13;&#10;&#9;&#9;}&#13;&#10;&#13;&#10;&#9;&#9;// User routes (protected)&#13;&#10;&#9;&#9;users.Use(authMiddleware.AuthRequired())&#13;&#10;&#9;&#9;{&#13;&#10;&#9;&#9;&#9;users.GET(&quot;:id&quot;, userController.GetUserByID())&#13;&#10;&#13;&#10;&#9;&#9;&#9;users.PUT(&quot;/:id/profile&quot;, userController.UpdateUserProfile())&#13;&#10;&#9;&#9;&#9;users.PATCH(&quot;/:id/register-merchant&quot;,&#13;&#10;&#9;&#9;&#9;&#9;userController.UpdateToMerchantAccount())&#13;&#10;&#9;&#9;&#9;users.PATCH(&quot;/:id/password&quot;, userController.UpdateUserPassword())&#13;&#10;&#9;&#9;&#9;users.DELETE(&quot;/:id&quot;, userController.DeleteUser())&#13;&#10;&#13;&#10;&#9;&#9;&#9;// Admin only routes&#13;&#10;&#9;&#9;&#9;users.GET(&quot;&quot;, authMiddleware.RequireRole(&quot;admin&quot;), userController.GetUsers())&#13;&#10;&#9;&#9;}&#13;&#10;&#9;}&#13;&#10;&#13;&#10;&#9;return router&#13;&#10;}&#13;&#10;&#13;&#10;func initUserData(userRepository identity.UserRepository, authRepository identity.AuthRepository) error {&#13;&#10;&#9;user, err := userRepository.FindUserByID(1)&#13;&#10;&#9;if user != nil {&#13;&#10;&#9;&#9;return nil&#13;&#10;&#9;}&#13;&#10;&#13;&#10;&#9;// Create admin user if it does not exist&#13;&#10;&#9;if errors.Is(err, customErr.ErrUserNotFound{}) {&#13;&#10;&#9;&#9;user = createAdminUser()&#13;&#10;&#9;&#9;if err := userRepository.CreateUser(user); err != nil {&#13;&#10;&#9;&#9;&#9;return err&#13;&#10;&#9;&#9;}&#13;&#10;&#9;}&#13;&#10;&#13;&#10;&#9;// Assign admin role to the user&#13;&#10;&#9;role, err := authRepository.FindRoleByName(string(constants.RoleAdmin))&#13;&#10;&#9;if err != nil {&#13;&#10;&#9;&#9;return err&#13;&#10;&#9;}&#13;&#10;&#13;&#10;&#9;adminRole := entity.UserRoles{&#13;&#10;&#9;&#9;UserID: user.ID,&#13;&#10;&#9;&#9;RoleID: role.ID,&#13;&#10;&#9;}&#13;&#10;&#13;&#10;&#9;if err := authRepository.AddRoleToUser(&amp;adminRole); err != nil {&#13;&#10;&#9;&#9;return err&#13;&#10;&#9;}&#13;&#10;&#13;&#10;&#9;log.Printf(&quot;Admin user initialized: %s&quot;, user.Email)&#13;&#10;&#9;return nil&#13;&#10;}&#13;&#10;&#13;&#10;func createAdminUser() *entity.User {&#13;&#10;&#9;password := &quot;admin&quot;&#13;&#10;&#9;hashedPassword, _ := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)&#13;&#10;&#13;&#10;&#9;return &amp;entity.User{&#13;&#10;&#9;&#9;Email:        &quot;test@gmail.com&quot;,&#13;&#10;&#9;&#9;Password:     string(hashedPassword),&#13;&#10;&#9;&#9;ProviderID:   &quot;1&quot;,&#13;&#10;&#9;&#9;ProviderName: &quot;app&quot;,&#13;&#10;&#9;&#9;LastName:     &quot;Admin&quot;,&#13;&#10;&#9;&#9;FirstName:    &quot;Admin&quot;,&#13;&#10;&#9;&#9;Avatar:       &quot;https://example.com/avatar.png&quot;,&#13;&#10;&#9;&#9;Gender:       string(constants.GenderOther),&#13;&#10;&#9;&#9;PhoneNumber:  &quot;1234567890&quot;,&#13;&#10;&#9;&#9;DateOfBirth:  time.Now(),&#13;&#10;&#9;&#9;Status:       string(constants.UserStatusActive),&#13;&#10;&#9;}&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/internal/services/identity/config.yaml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/internal/services/identity/config.yaml" />
              <option name="originalContent" value="environment: &quot;development&quot;&#10;service_name: &quot;identity&quot;&#10;&#10;# Application Configuration (host and port are here, not in http)&#10;app:&#10;  host: &quot;localhost&quot;&#10;  port: &quot;8080&quot;&#10;&#10;# HTTP Server Configuration (no host/port here - different fields)&#10;http:&#10;  read_timeout: 10&#10;  write_timeout: 10&#10;  max_header_bytes: 1048576&#10;  allowed_origins: &quot;*&quot;&#10;  allowed_methods: &quot;GET,POST,PUT,DELETE,OPTIONS&quot;&#10;  allowed_headers: &quot;Content-Type,Authorization&quot;&#10;  exposed_headers: &quot;&quot;&#10;  allow_credentials: true&#10;&#10;# Database Configuration (using proper defaults that Viper can handle)&#10;pg:&#10;  host: &quot;localhost&quot;&#10;  port: &quot;5432&quot;&#10;  user: &quot;postgres&quot;&#10;  password: &quot;password&quot;&#10;  database: &quot;gostore_identity&quot;&#10;  ssl_mode: &quot;disable&quot;&#10;  max_open_conns: 25&#10;  max_idle_conns: 10&#10;  conn_max_lifetime: 3600&#10;  conn_max_idle_time: 1800&#10;&#10;# JWT Configuration (different field names)&#10;jwt:&#10;  secret: &quot;${JWT_SECRET:your-secret-key}&quot;&#10;  expiration: &quot;15m&quot; # in minutes&#10;  issuer: &quot;gostore-identity&quot;&#10;  audience: &quot;gostore-users&quot;&#10;&#10;# Redis Configuration&#10;redis:&#10;  host: &quot;${REDIS_HOST:localhost}&quot;&#10;  port: &quot;${REDIS_PORT:6001}&quot;&#10;  password: &quot;${REDIS_PASSWORD:}&quot;&#10;  db: 0&#10;  pool_size: 10&#10;  min_idle_conns: 3&#10;  dial_timeout: 5&#10;  read_timeout: 3&#10;  write_timeout: 3&#10;  idle_timeout: 300&#10;&#10;# Logging Configuration&#10;log:&#10;  level: &quot;info&quot;&#10;  format: &quot;json&quot;&#10;  output: &quot;stdout&quot;&#10;  file_path: &quot;&quot;&#10;  max_size: 10&#10;  max_backups: 3&#10;  max_age: 28&#10;  compress: true&#10;&#10;# Services Configuration for inter-service communication&#10;services:&#10;  identity_service_url: &quot;http://localhost:8080&quot;&#10;  product_service_url: &quot;http://localhost:8081&quot;&#10;  cart_service_url: &quot;http://localhost:8082&quot;&#10;  order_service_url: &quot;http://localhost:8083&quot;&#10;  gateway_service_url: &quot;http://localhost:8000&quot;&#10;  notification_service_url: &quot;http://localhost:8084&quot;&#10;  payment_service_url: &quot;http://localhost:8085&quot;&#10;" />
              <option name="updatedContent" value="environment: &quot;development&quot;&#10;service_name: &quot;identity&quot;&#10;&#10;# Application Configuration (host and port are here, not in http)&#10;app:&#10;  host: &quot;localhost&quot;&#10;  port: &quot;8080&quot;&#10;&#10;# HTTP Server Configuration (no host/port here - different fields)&#10;http:&#10;  read_timeout: 10&#10;  write_timeout: 10&#10;  max_header_bytes: 1048576&#10;  allowed_origins: &quot;*&quot;&#10;  allowed_methods: &quot;GET,POST,PUT,DELETE,OPTIONS&quot;&#10;  allowed_headers: &quot;Content-Type,Authorization&quot;&#10;  exposed_headers: &quot;&quot;&#10;  allow_credentials: true&#10;&#10;# Database Configuration (using proper defaults that Viper can handle)&#10;pg:&#10;  host: &quot;localhost&quot;&#10;  port: &quot;5432&quot;&#10;  user: &quot;postgres&quot;&#10;  password: &quot;password&quot;&#10;  database: &quot;gostore_identity&quot;&#10;  ssl_mode: &quot;disable&quot;&#10;  max_open_conns: 25&#10;  max_idle_conns: 10&#10;  conn_max_lifetime: 3600&#10;  conn_max_idle_time: 1800&#10;&#10;# JWT Configuration (using proper defaults)&#10;jwt:&#10;  secret: &quot;your-secret-key&quot;&#10;  expiration: &quot;15m&quot;&#10;  issuer: &quot;gostore-identity&quot;&#10;  audience: &quot;gostore-users&quot;&#10;&#10;# Redis Configuration (using proper defaults)&#10;redis:&#10;  host: &quot;localhost&quot;&#10;  port: &quot;6379&quot;&#10;  password: &quot;&quot;&#10;  db: 0&#10;  pool_size: 10&#10;  min_idle_conns: 3&#10;  dial_timeout: 5&#10;  read_timeout: 3&#10;  write_timeout: 3&#10;  idle_timeout: 300&#10;&#10;# Logging Configuration&#10;log:&#10;  level: &quot;info&quot;&#10;  format: &quot;json&quot;&#10;  output: &quot;stdout&quot;&#10;  file_path: &quot;&quot;&#10;  max_size: 10&#10;  max_backups: 3&#10;  max_age: 28&#10;  compress: true&#10;&#10;# Services Configuration for inter-service communication&#10;services:&#10;  identity_service_url: &quot;http://localhost:8080&quot;&#10;  product_service_url: &quot;http://localhost:8081&quot;&#10;  cart_service_url: &quot;http://localhost:8082&quot;&#10;  order_service_url: &quot;http://localhost:8083&quot;&#10;  gateway_service_url: &quot;http://localhost:8000&quot;&#10;  notification_service_url: &quot;http://localhost:8084&quot;&#10;  payment_service_url: &quot;http://localhost:8085&quot;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/internal/services/identity/internal/client/cart_client.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/internal/services/identity/internal/client/cart_client.go" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/internal/services/identity/internal/config/config.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/internal/services/identity/internal/config/config.go" />
              <option name="originalContent" value="package config&#10;&#10;import (&#10;&#9;&quot;fmt&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/internal/pkg/config&quot;&#10;&#9;&quot;time&quot;&#10;)&#10;&#10;type AppConfig struct {&#10;&#9;*config.Config&#10;}&#10;&#10;func LoadConfig(configPath string) (*AppConfig, error) {&#10;&#9;// Load shared configuration from pkg&#10;&#9;sharedConfig, err := config.LoadConfig(configPath)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, fmt.Errorf(&quot;error loading shared config: %w&quot;, err)&#10;&#9;}&#10;&#10;&#9;appConfig := &amp;AppConfig{&#10;&#9;&#9;Config: sharedConfig,&#10;&#9;}&#10;&#10;&#9;return appConfig, nil&#10;}&#10;&#10;// Legacy getter methods for backward compatibility&#10;func (c *AppConfig) GetDBHost() string {&#10;&#9;return c.PG.Host&#10;}&#10;&#10;func (c *AppConfig) GetDBPort() string {&#10;&#9;return c.PG.Port&#10;}&#10;&#10;func (c *AppConfig) GetDBUser() string {&#10;&#9;return c.PG.User&#10;}&#10;&#10;func (c *AppConfig) GetDBPassword() string {&#10;&#9;return c.PG.Password&#10;}&#10;&#10;func (c *AppConfig) GetDBName() string {&#10;&#9;return c.PG.DBName&#10;}&#10;&#10;func (c *AppConfig) GetDBSSLMode() string {&#10;&#9;return c.PG.SSLMode&#10;}&#10;&#10;func (c *AppConfig) GetJWTSecret() string {&#10;&#9;return c.JWT.Secret&#10;}&#10;&#10;func (c *AppConfig) GetJWTExpiresIn() time.Duration {&#10;&#9;duration, _ := time.ParseDuration(c.JWT.ExpiresIn)&#10;&#9;return duration&#10;}&#10;&#10;func (c *AppConfig) GetJWTRefreshExpiresIn() time.Duration {&#10;&#9;duration, _ := time.ParseDuration(c.JWT.RefreshExpiresIn)&#10;&#9;return duration&#10;}&#10;&#10;func (c *AppConfig) GetServerPort() string {&#10;&#9;return c.HTTP.Port&#10;}&#10;&#10;func (c *AppConfig) GetServerHost() string {&#10;&#9;return c.HTTP.Host&#10;}&#10;&#10;func (c *AppConfig) GetLogLevel() string {&#10;&#9;return c.Log.Level&#10;}&#10;&#10;func (c *AppConfig) GetRedisHost() string {&#10;&#9;return c.Redis.Host&#10;}&#10;&#10;func (c *AppConfig) GetRedisPort() string {&#10;&#9;return c.Redis.Port&#10;}&#10;&#10;func (c *AppConfig) GetRedisPassword() string {&#10;&#9;return c.Redis.Password&#10;}&#10;&#10;func (c *AppConfig) GetCartServiceURL() string {&#10;&#9;return c.Services.GetServiceURL(&quot;cart&quot;)&#10;}&#10;&#10;func (c *AppConfig) GetEnvironment() string {&#10;&#9;return c.Environment&#10;}&#10;&#10;func (c *AppConfig) GetDatabaseURL() string {&#10;&#9;return fmt.Sprintf(&quot;host=%s port=%s user=%s password=%s dbname=%s sslmode=%s&quot;,&#10;&#9;&#9;c.PG.Host, c.PG.Port, c.PG.User, c.PG.Password, c.PG.DBName, c.PG.SSLMode)&#10;}&#10;&#10;func (c *AppConfig) GetServerAddress() string {&#10;&#9;return &quot;:&quot; + c.HTTP.Port&#10;}&#10;" />
              <option name="updatedContent" value="package config&#10;&#10;import (&#10;&#9;&quot;fmt&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/internal/pkg/config&quot;&#10;&#9;&quot;time&quot;&#10;)&#10;&#10;type AppConfig struct {&#10;&#9;*config.Config&#10;}&#10;&#10;func LoadConfig(configPath string) (*AppConfig, error) {&#10;&#9;// Load shared configuration from pkg&#10;&#9;sharedConfig, err := config.LoadConfig(configPath)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, fmt.Errorf(&quot;error loading shared config: %w&quot;, err)&#10;&#9;}&#10;&#10;&#9;appConfig := &amp;AppConfig{&#10;&#9;&#9;Config: sharedConfig,&#10;&#9;}&#10;&#10;&#9;return appConfig, nil&#10;}&#10;&#10;// Legacy getter methods for backward compatibility&#10;func (c *AppConfig) GetDBHost() string {&#10;&#9;return c.PG.Host&#10;}&#10;&#10;func (c *AppConfig) GetDBPort() string {&#10;&#9;return c.PG.Port&#10;}&#10;&#10;func (c *AppConfig) GetDBUser() string {&#10;&#9;return c.PG.User&#10;}&#10;&#10;func (c *AppConfig) GetDBPassword() string {&#10;&#9;return c.PG.Password&#10;}&#10;&#10;func (c *AppConfig) GetDBName() string {&#10;&#9;return c.PG.Database // Updated field name&#10;}&#10;&#10;func (c *AppConfig) GetDBSSLMode() string {&#10;&#9;return c.PG.SSLMode // Updated field name&#10;}&#10;&#10;func (c *AppConfig) GetJWTSecret() string {&#10;&#9;return c.JWT.Secret&#10;}&#10;&#10;func (c *AppConfig) GetJWTExpiresIn() time.Duration {&#10;&#9;duration, _ := time.ParseDuration(c.JWT.Expiration) // Updated field name&#10;&#9;return duration&#10;}&#10;&#10;func (c *AppConfig) GetJWTRefreshExpiresIn() time.Duration {&#10;&#9;// Since refresh_expires_in is not in pkg struct, use a default or derive from expiration&#10;&#9;duration, _ := time.ParseDuration(&quot;168h&quot;) // 7 days default&#10;&#9;return duration&#10;}&#10;&#10;func (c *AppConfig) GetServerPort() string {&#10;&#9;return c.App.Port // Updated to use App.Port&#10;}&#10;&#10;func (c *AppConfig) GetServerHost() string {&#10;&#9;return c.App.Host // Updated to use App.Host&#10;}&#10;&#10;func (c *AppConfig) GetLogLevel() string {&#10;&#9;return c.Log.Level&#10;}&#10;&#10;func (c *AppConfig) GetRedisHost() string {&#10;&#9;return c.Redis.Host&#10;}&#10;&#10;func (c *AppConfig) GetRedisPort() string {&#10;&#9;return c.Redis.Port&#10;}&#10;&#10;func (c *AppConfig) GetRedisPassword() string {&#10;&#9;return c.Redis.Password&#10;}&#10;&#10;func (c *AppConfig) GetCartServiceURL() string {&#10;&#9;return c.Services.GetServiceURL(&quot;cart&quot;)&#10;}&#10;&#10;func (c *AppConfig) GetEnvironment() string {&#10;&#9;return c.Environment&#10;}&#10;&#10;func (c *AppConfig) GetDatabaseURL() string {&#10;&#9;return fmt.Sprintf(&quot;host=%s port=%s user=%s password=%s dbname=%s sslmode=%s&quot;,&#10;&#9;&#9;c.PG.Host, c.PG.Port, c.PG.User, c.PG.Password, c.PG.Database, c.PG.SSLMode) // Updated field names&#10;}&#10;&#10;func (c *AppConfig) GetServerAddress() string {&#10;&#9;return &quot;:&quot; + c.App.Port // Updated to use App.Port&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/internal/services/identity/internal/controller/http/v1/auth_controller.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/internal/services/identity/internal/controller/http/v1/auth_controller.go" />
              <option name="originalContent" value="package v1&#10;&#10;import (&#10;&#9;&quot;github.com/gin-gonic/gin&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/internal/pkg/logger&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/internal/pkg/rest&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/services/identity&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/services/identity/internal/dto/request&quot;&#10;&#9;&quot;net/http&quot;&#10;&#9;&quot;strings&quot;&#10;)&#10;&#10;type AuthController struct {&#10;&#9;logger      logger.Logger&#10;&#9;authService identity.AuthService&#10;}&#10;&#10;func NewAuthController(logger logger.Logger, service identity.AuthService) *AuthController {&#10;&#9;return &amp;AuthController{&#10;&#9;&#9;logger:      logger,&#10;&#9;&#9;authService: service,&#10;&#9;}&#10;}&#10;&#10;func (a *AuthController) Login() func(ctx *gin.Context) {&#10;&#9;return func(ctx *gin.Context) {&#10;&#9;&#9;var AuthRequest request.AuthRequest&#10;&#9;&#9;if err := ctx.ShouldBindJSON(&amp;AuthRequest); err != nil {&#10;&#9;&#9;&#9;a.logger.Error(&quot;Error binding JSON:&quot;, err)&#10;&#9;&#9;&#9;ctx.JSON(http.StatusBadRequest, rest.ErrorResponse{ApiError: rest.BadRequestError, Message: &quot;Invalid request body&quot;})&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#10;&#9;&#9;a.logger.Info(&quot;Processing login for user:&quot;, AuthRequest.Email)&#10;&#9;&#9;authResponse, err := a.authService.Login(AuthRequest)&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;a.logger.Error(&quot;Error during login:&quot;, err)&#10;&#9;&#9;&#9;ctx.JSON(http.StatusInternalServerError, rest.ErrorResponse{ApiError: rest.InternalServerErrorError, Message: &quot;Login failed&quot;})&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#10;&#9;&#9;a.logger.Info(&quot;Login successful for user:&quot;, AuthRequest.Email)&#10;&#9;&#9;ctx.JSON(http.StatusOK, rest.NewAPIResponse(http.StatusOK, &quot;Login successful&quot;, authResponse))&#10;&#9;}&#10;}&#10;&#10;func (a *AuthController) Verify() func(ctx *gin.Context) {&#10;&#9;return func(ctx *gin.Context) {&#10;&#9;&#9;token := ctx.GetHeader(&quot;Authorization&quot;)&#10;&#9;&#9;if token == &quot;&quot; {&#10;&#9;&#9;&#9;a.logger.Error(&quot;Authorization header is missing&quot;)&#10;&#9;&#9;&#9;ctx.JSON(http.StatusUnauthorized, rest.ErrorResponse{ApiError: rest.UnauthorizedError, Message: &quot;Authorization header required&quot;})&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#10;&#9;&#9;token = strings.TrimPrefix(token, &quot;Bearer &quot;)&#10;&#10;&#9;&#9;a.logger.Info(&quot;Verifying token:&quot;, token)&#10;&#9;&#9;verifyResponse, err := a.authService.Verify(token)&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;a.logger.Error(&quot;Token verification failed:&quot;, err)&#10;&#9;&#9;&#9;ctx.JSON(http.StatusUnauthorized, rest.ErrorResponse{ApiError: rest.UnauthorizedError, Message: &quot;Invalid token&quot;})&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#10;&#9;&#9;a.logger.Info(&quot;Token verified successfully for user:&quot;, verifyResponse.UserID)&#10;&#9;&#9;ctx.JSON(http.StatusOK, verifyResponse)&#10;&#9;}&#10;}&#10;" />
              <option name="updatedContent" value="package v1&#13;&#10;&#13;&#10;import (&#13;&#10;&#9;&quot;github.com/gin-gonic/gin&quot;&#13;&#10;&#9;&quot;github.com/hthinh24/go-store/internal/pkg/logger&quot;&#13;&#10;&#9;&quot;github.com/hthinh24/go-store/internal/pkg/rest&quot;&#13;&#10;&#9;&quot;github.com/hthinh24/go-store/services/identity&quot;&#13;&#10;&#9;&quot;github.com/hthinh24/go-store/services/identity/internal/dto/request&quot;&#13;&#10;&#9;&quot;net/http&quot;&#13;&#10;&#9;&quot;strings&quot;&#13;&#10;)&#13;&#10;&#13;&#10;type AuthController struct {&#13;&#10;&#9;logger      logger.Logger&#13;&#10;&#9;authService identity.AuthService&#13;&#10;}&#13;&#10;&#13;&#10;func NewAuthController(logger logger.Logger, service identity.AuthService) *AuthController {&#13;&#10;&#9;return &amp;AuthController{&#13;&#10;&#9;&#9;logger:      logger,&#13;&#10;&#9;&#9;authService: service,&#13;&#10;&#9;}&#13;&#10;}&#13;&#10;&#13;&#10;func (a *AuthController) Login() func(ctx *gin.Context) {&#13;&#10;&#9;return func(ctx *gin.Context) {&#13;&#10;&#9;&#9;var AuthRequest request.AuthRequest&#13;&#10;&#9;&#9;if err := ctx.ShouldBindJSON(&amp;AuthRequest); err != nil {&#13;&#10;&#9;&#9;&#9;a.logger.Error(&quot;Error binding JSON: &quot;, err)&#13;&#10;&#9;&#9;&#9;ctx.JSON(http.StatusBadRequest, rest.ErrorResponse{ApiError: rest.BadRequestError, Message: &quot;Invalid request body&quot;})&#13;&#10;&#9;&#9;&#9;return&#13;&#10;&#9;&#9;}&#13;&#10;&#13;&#10;&#9;&#9;a.logger.Info(&quot;Processing login for user: &quot;, AuthRequest.Email)&#13;&#10;&#9;&#9;authResponse, err := a.authService.Login(AuthRequest)&#13;&#10;&#9;&#9;if err != nil {&#13;&#10;&#9;&#9;&#9;a.logger.Error(&quot;Error during login: &quot;, err)&#13;&#10;&#9;&#9;&#9;ctx.JSON(http.StatusInternalServerError, rest.ErrorResponse{ApiError: rest.InternalServerErrorError, Message: &quot;Login failed&quot;})&#13;&#10;&#9;&#9;&#9;return&#13;&#10;&#9;&#9;}&#13;&#10;&#13;&#10;&#9;&#9;a.logger.Info(&quot;Login successful for user: &quot;, AuthRequest.Email)&#13;&#10;&#9;&#9;ctx.JSON(http.StatusOK, rest.NewAPIResponse(http.StatusOK, &quot;Login successful&quot;, authResponse))&#13;&#10;&#9;}&#13;&#10;}&#13;&#10;&#13;&#10;func (a *AuthController) Verify() func(ctx *gin.Context) {&#13;&#10;&#9;return func(ctx *gin.Context) {&#13;&#10;&#9;&#9;token := ctx.GetHeader(&quot;Authorization&quot;)&#13;&#10;&#9;&#9;if token == &quot;&quot; {&#13;&#10;&#9;&#9;&#9;a.logger.Error(&quot;Authorization header is missing&quot;)&#13;&#10;&#9;&#9;&#9;ctx.JSON(http.StatusUnauthorized, rest.ErrorResponse{ApiError: rest.UnauthorizedError, Message: &quot;Authorization header required&quot;})&#13;&#10;&#9;&#9;&#9;return&#13;&#10;&#9;&#9;}&#13;&#10;&#13;&#10;&#9;&#9;token = strings.TrimPrefix(token, &quot;Bearer &quot;)&#13;&#10;&#13;&#10;&#9;&#9;a.logger.Info(&quot;Verifying token: &quot;, token)&#13;&#10;&#9;&#9;verifyResponse, err := a.authService.Verify(token)&#13;&#10;&#9;&#9;if err != nil {&#13;&#10;&#9;&#9;&#9;a.logger.Error(&quot;Token verification failed: &quot;, err)&#13;&#10;&#9;&#9;&#9;ctx.JSON(http.StatusUnauthorized, rest.ErrorResponse{ApiError: rest.UnauthorizedError, Message: &quot;Invalid token&quot;})&#13;&#10;&#9;&#9;&#9;return&#13;&#10;&#9;&#9;}&#13;&#10;&#13;&#10;&#9;&#9;a.logger.Info(&quot;Token verified successfully for user: &quot;, verifyResponse.UserID)&#13;&#10;&#9;&#9;ctx.JSON(http.StatusOK, verifyResponse)&#13;&#10;&#9;}&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/internal/services/identity/internal/controller/http/v1/user_controller.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/internal/services/identity/internal/controller/http/v1/user_controller.go" />
              <option name="originalContent" value="package v1&#10;&#10;import (&#10;&#9;&quot;errors&quot;&#10;&#9;&quot;github.com/gin-gonic/gin&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/internal/pkg/logger&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/internal/pkg/rest&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/services/identity&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/services/identity/internal/dto/request&quot;&#10;&#9;customErr &quot;github.com/hthinh24/go-store/services/identity/internal/errors&quot;&#10;&#9;&quot;net/http&quot;&#10;&#9;&quot;strconv&quot;&#10;)&#10;&#10;type UserController struct {&#10;&#9;logger      logger.Logger&#10;&#9;userService identity.UserService&#10;}&#10;&#10;func NewUserController(logger logger.Logger, service identity.UserService) *UserController {&#10;&#9;return &amp;UserController{&#10;&#9;&#9;logger:      logger,&#10;&#9;&#9;userService: service,&#10;&#9;}&#10;}&#10;&#10;func (u *UserController) GetUserByID() func(ctx *gin.Context) {&#10;&#9;return func(ctx *gin.Context) {&#10;&#9;&#9;idStr := ctx.Param(&quot;id&quot;)&#10;&#10;&#9;&#9;id, err := strconv.Atoi(idStr)&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;u.logger.Error(&quot;Invalid user ID:&quot;, idStr, &quot;Error:&quot;, err)&#10;&#9;&#9;&#9;ctx.JSON(http.StatusBadRequest, rest.ErrorResponse{ApiError: rest.BadRequestError, Message: &quot;Invalid user ID format&quot;})&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#10;&#9;&#9;u.logger.Info(&quot;Fetching user by ID:&quot;, id)&#10;&#10;&#9;&#9;user, err := u.userService.GetUserByID(int64(id))&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;if errors.Is(err, customErr.ErrUserNotFound{}) {&#10;&#9;&#9;&#9;&#9;u.logger.Error(&quot;User with ID:&quot;, id, &quot;not found&quot;)&#10;&#9;&#9;&#9;&#9;ctx.JSON(http.StatusNotFound, rest.ErrorResponse{ApiError: rest.NotFoundError, Message: &quot;User not found&quot;})&#10;&#9;&#9;&#9;&#9;return&#10;&#9;&#9;&#9;}&#10;&#10;&#9;&#9;&#9;u.logger.Error(&quot;Error fetching user by ID:&quot;, err)&#10;&#9;&#9;&#9;ctx.JSON(http.StatusInternalServerError, rest.ErrorResponse{ApiError: rest.InternalServerErrorError, Message: &quot;Failed to fetch user&quot;})&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#10;&#9;&#9;u.logger.Info(&quot;Successfully fetched user by ID:&quot;, id)&#10;&#9;&#9;ctx.JSON(http.StatusOK, rest.NewAPIResponse(http.StatusOK, &quot;User fetched successfully&quot;, user))&#10;&#9;}&#10;}&#10;&#10;func (u *UserController) GetUsers() func(ctx *gin.Context) {&#10;&#9;return func(ctx *gin.Context) {&#10;&#9;&#9;u.logger.Info(&quot;Get all users&quot;)&#10;&#10;&#9;&#9;users, err := u.userService.GetUsers()&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;u.logger.Error(&quot;Error fetching users:&quot;, err)&#10;&#9;&#9;&#9;ctx.JSON(http.StatusInternalServerError, rest.ErrorResponse{ApiError: rest.InternalServerErrorError, Message: &quot;Failed to fetch users&quot;})&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#10;&#9;&#9;u.logger.Info(&quot;Get all users successfully&quot;)&#10;&#9;&#9;ctx.JSON(http.StatusOK, users)&#10;&#9;}&#10;}&#10;&#10;func (u *UserController) CreateUser() func(ctx *gin.Context) {&#10;&#9;return func(ctx *gin.Context) {&#10;&#9;&#9;var userRequest request.CreateUserRequest&#10;&#9;&#9;if err := ctx.ShouldBindJSON(&amp;userRequest); err != nil {&#10;&#9;&#9;&#9;u.logger.Error(&quot;Error binding JSON:&quot;, err)&#10;&#9;&#9;&#9;ctx.JSON(http.StatusBadRequest, rest.ErrorResponse{ApiError: rest.BadRequestError, Message: &quot;Invalid request body&quot;})&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#10;&#9;&#9;if err := userRequest.Validate(); err != nil {&#10;&#9;&#9;&#9;u.logger.Error(&quot;Validation fail:&quot;)&#10;&#9;&#9;&#9;ctx.JSON(http.StatusBadRequest, rest.ErrorResponse{ApiError: rest.ValidationError, Message: err.Error()})&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#10;&#9;&#9;u.logger.Info(&quot;Creating new user with email:&quot;, userRequest.Email)&#10;&#10;&#9;&#9;user, err := u.userService.CreateUser(&amp;userRequest)&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;u.logger.Error(&quot;Error creating user:&quot;)&#10;&#9;&#9;&#9;ctx.JSON(http.StatusInternalServerError, rest.ErrorResponse{ApiError: rest.InternalServerErrorError, Message: &quot;Failed to create user&quot;})&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#10;&#9;&#9;u.logger.Info(&quot;Successfully created user with ID:&quot;, user.ID)&#10;&#9;&#9;ctx.JSON(http.StatusCreated, rest.NewAPIResponse(http.StatusCreated, &quot;User created successfully&quot;, user))&#10;&#9;}&#10;}&#10;&#10;func (u *UserController) UpdateUserProfile() func(ctx *gin.Context) {&#10;&#9;return func(ctx *gin.Context) {&#10;&#9;&#9;idStr := ctx.Param(&quot;id&quot;)&#10;&#10;&#9;&#9;id, err := strconv.Atoi(idStr)&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;u.logger.Error(&quot;Invalid user ID:&quot;, idStr, &quot;Error:&quot;, err)&#10;&#9;&#9;&#9;ctx.JSON(http.StatusBadRequest, rest.ErrorResponse{ApiError: rest.BadRequestError, Message: &quot;Invalid user ID format&quot;})&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#10;&#9;&#9;var updateRequest request.UpdateUserProfileRequest&#10;&#9;&#9;if err := ctx.ShouldBindJSON(&amp;updateRequest); err != nil {&#10;&#9;&#9;&#9;u.logger.Error(&quot;Error binding JSON:&quot;, err)&#10;&#9;&#9;&#9;ctx.JSON(http.StatusBadRequest, rest.ErrorResponse{ApiError: rest.BadRequestError, Message: &quot;Invalid request body&quot;})&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// Validate the update request&#10;&#9;&#9;if err := updateRequest.Validate(); err != nil {&#10;&#9;&#9;&#9;u.logger.Error(&quot;Validation failed:&quot;, err)&#10;&#9;&#9;&#9;ctx.JSON(http.StatusBadRequest, rest.ErrorResponse{ApiError: rest.ValidationError, Message: err.Error()})&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#10;&#9;&#9;u.logger.Info(&quot;Updating user profile with ID:&quot;, id)&#10;&#10;&#9;&#9;user, err := u.userService.UpdateUserProfile(int64(id), &amp;updateRequest)&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;u.logger.Error(&quot;Error updating user profile:&quot;, err)&#10;&#9;&#9;&#9;ctx.JSON(http.StatusInternalServerError, rest.ErrorResponse{ApiError: rest.InternalServerErrorError, Message: &quot;Failed to update user profile&quot;})&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#10;&#9;&#9;u.logger.Info(&quot;Successfully updated user profile with ID:&quot;, id)&#10;&#9;&#9;ctx.JSON(http.StatusOK, rest.NewAPIResponse(http.StatusOK, &quot;User profile updated successfully&quot;, user))&#10;&#9;}&#10;}&#10;&#10;func (u *UserController) UpdateUserPassword() func(ctx *gin.Context) {&#10;&#9;return func(ctx *gin.Context) {&#10;&#9;&#9;idStr := ctx.Param(&quot;id&quot;)&#10;&#10;&#9;&#9;id, err := strconv.Atoi(idStr)&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;u.logger.Error(&quot;Invalid user ID:&quot;, idStr, &quot;Error:&quot;, err)&#10;&#9;&#9;&#9;ctx.JSON(http.StatusBadRequest, rest.ErrorResponse{ApiError: rest.BadRequestError, Message: &quot;Invalid user ID format&quot;})&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#10;&#9;&#9;var passwordRequest request.UpdateUserPasswordRequest&#10;&#9;&#9;if err := ctx.ShouldBindJSON(&amp;passwordRequest); err != nil {&#10;&#9;&#9;&#9;u.logger.Error(&quot;Error binding JSON:&quot;, err)&#10;&#9;&#9;&#9;ctx.JSON(http.StatusBadRequest, rest.ErrorResponse{ApiError: rest.BadRequestError, Message: &quot;Invalid request body&quot;})&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#10;&#9;&#9;if err := passwordRequest.Validate(); err != nil {&#10;&#9;&#9;&#9;u.logger.Error(&quot;Validation failed:&quot;, err)&#10;&#9;&#9;&#9;ctx.JSON(http.StatusBadRequest, rest.ErrorResponse{ApiError: rest.ValidationError, Message: err.Error()})&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#10;&#9;&#9;u.logger.Info(&quot;Updating user password for ID:&quot;, id)&#10;&#10;&#9;&#9;user, err := u.userService.UpdateUserPassword(int64(id), &amp;passwordRequest)&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;u.logger.Error(&quot;Error updating user password:&quot;, err)&#10;&#9;&#9;&#9;ctx.JSON(http.StatusInternalServerError, rest.ErrorResponse{ApiError: rest.InternalServerErrorError, Message: &quot;Failed to update user password&quot;})&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#10;&#9;&#9;u.logger.Info(&quot;Successfully updated user password for ID:&quot;, id)&#10;&#9;&#9;ctx.JSON(http.StatusOK, rest.NewAPIResponse(http.StatusOK, &quot;User password updated successfully&quot;, user))&#10;&#9;}&#10;}&#10;&#10;func (u *UserController) UpdateToMerchantAccount() func(ctx *gin.Context) {&#10;&#9;return func(ctx *gin.Context) {&#10;&#9;&#9;idStr := ctx.Param(&quot;id&quot;)&#10;&#10;&#9;&#9;id, err := strconv.Atoi(idStr)&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;u.logger.Error(&quot;Invalid user ID:&quot;, idStr, &quot;Error:&quot;, err)&#10;&#9;&#9;&#9;ctx.JSON(http.StatusBadRequest, rest.ErrorResponse{ApiError: rest.BadRequestError, Message: &quot;Invalid user ID format&quot;})&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#10;&#9;&#9;u.logger.Info(&quot;Updating user to merchant account with ID:&quot;, id)&#10;&#10;&#9;&#9;if err := u.userService.UpdateToMerchantAccount(int64(id)); err != nil {&#10;&#9;&#9;&#9;u.logger.Error(&quot;Error updating user to merchant account with ID:&quot;, id, &quot;Error:&quot;, err)&#10;&#9;&#9;&#9;ctx.JSON(http.StatusInternalServerError, rest.ErrorResponse{ApiError: rest.InternalServerErrorError, Message: &quot;Failed to update user to merchant account&quot;})&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#10;&#9;&#9;u.logger.Info(&quot;Successfully updated user to merchant account with ID:&quot;, id)&#10;&#9;&#9;ctx.JSON(http.StatusOK, rest.NewAPIResponse(http.StatusOK, &quot;User updated to merchant account successfully&quot;, nil))&#10;&#9;}&#10;}&#10;&#10;func (u *UserController) DeleteUser() func(ctx *gin.Context) {&#10;&#9;return func(ctx *gin.Context) {&#10;&#9;&#9;idStr := ctx.Param(&quot;id&quot;)&#10;&#10;&#9;&#9;id, err := strconv.Atoi(idStr)&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;u.logger.Error(&quot;Invalid user ID:&quot;, idStr, &quot;Error:&quot;, err)&#10;&#9;&#9;&#9;ctx.JSON(http.StatusBadRequest, rest.ErrorResponse{ApiError: rest.BadRequestError, Message: &quot;Invalid user ID format&quot;})&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#10;&#9;&#9;u.logger.Info(&quot;Deleting user with ID:&quot;, id)&#10;&#10;&#9;&#9;if err := u.userService.DeleteUser(int64(id)); err != nil {&#10;&#9;&#9;&#9;u.logger.Error(&quot;Error deleting user with ID:&quot;, id, &quot;Error:&quot;, err)&#10;&#9;&#9;&#9;ctx.JSON(http.StatusInternalServerError, rest.ErrorResponse{ApiError: rest.InternalServerErrorError, Message: &quot;Failed to delete user&quot;})&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#10;&#9;&#9;u.logger.Info(&quot;Successfully deleted user with ID:&quot;, id)&#10;&#9;&#9;ctx.JSON(http.StatusNoContent, rest.NewAPIResponse(http.StatusNoContent, &quot;User deleted successfully&quot;, nil))&#10;&#9;}&#10;}&#10;" />
              <option name="updatedContent" value="package v1&#10;&#10;import (&#10;&#9;&quot;errors&quot;&#10;&#9;&quot;github.com/gin-gonic/gin&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/internal/pkg/logger&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/internal/pkg/rest&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/services/identity&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/services/identity/internal/dto/request&quot;&#10;&#9;customErr &quot;github.com/hthinh24/go-store/services/identity/internal/errors&quot;&#10;&#9;&quot;net/http&quot;&#10;&#9;&quot;strconv&quot;&#10;)&#10;&#10;type UserController struct {&#10;&#9;logger      logger.Logger&#10;&#9;userService identity.UserService&#10;}&#10;&#10;func NewUserController(logger logger.Logger, service identity.UserService) *UserController {&#10;&#9;return &amp;UserController{&#10;&#9;&#9;logger:      logger,&#10;&#9;&#9;userService: service,&#10;&#9;}&#10;}&#10;&#10;func (u *UserController) GetUserByID() func(ctx *gin.Context) {&#10;&#9;return func(ctx *gin.Context) {&#10;&#9;&#9;idStr := ctx.Param(&quot;id&quot;)&#10;&#10;&#9;&#9;id, err := strconv.Atoi(idStr)&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;u.logger.Error(&quot;Invalid user ID: &quot;, idStr, &quot;, Error: &quot;, err)&#10;&#9;&#9;&#9;ctx.JSON(http.StatusBadRequest, rest.ErrorResponse{ApiError: rest.BadRequestError, Message: &quot;Invalid user ID format&quot;})&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#10;&#9;&#9;u.logger.Info(&quot;Fetching user by ID: &quot;, id)&#10;&#10;&#9;&#9;user, err := u.userService.GetUserByID(int64(id))&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;if errors.Is(err, customErr.ErrUserNotFound{}) {&#10;&#9;&#9;&#9;&#9;u.logger.Error(&quot;User with ID: &quot;, id, &quot; not found&quot;)&#10;&#9;&#9;&#9;&#9;ctx.JSON(http.StatusNotFound, rest.ErrorResponse{ApiError: rest.NotFoundError, Message: &quot;User not found&quot;})&#10;&#9;&#9;&#9;&#9;return&#10;&#9;&#9;&#9;}&#10;&#10;&#9;&#9;&#9;u.logger.Error(&quot;Error fetching user by ID: &quot;, err)&#10;&#9;&#9;&#9;ctx.JSON(http.StatusInternalServerError, rest.ErrorResponse{ApiError: rest.InternalServerErrorError, Message: &quot;Failed to fetch user&quot;})&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#10;&#9;&#9;u.logger.Info(&quot;Successfully fetched user by ID: &quot;, id)&#10;&#9;&#9;ctx.JSON(http.StatusOK, rest.NewAPIResponse(http.StatusOK, &quot;User fetched successfully&quot;, user))&#10;&#9;}&#10;}&#10;&#10;func (u *UserController) GetUsers() func(ctx *gin.Context) {&#10;&#9;return func(ctx *gin.Context) {&#10;&#9;&#9;u.logger.Info(&quot;Get all users&quot;)&#10;&#10;&#9;&#9;users, err := u.userService.GetUsers()&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;u.logger.Error(&quot;Error fetching users: &quot;, err)&#10;&#9;&#9;&#9;ctx.JSON(http.StatusInternalServerError, rest.ErrorResponse{ApiError: rest.InternalServerErrorError, Message: &quot;Failed to fetch users&quot;})&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#10;&#9;&#9;u.logger.Info(&quot;Get all users successfully&quot;)&#10;&#9;&#9;ctx.JSON(http.StatusOK, users)&#10;&#9;}&#10;}&#10;&#10;func (u *UserController) CreateUser() func(ctx *gin.Context) {&#10;&#9;return func(ctx *gin.Context) {&#10;&#9;&#9;var userRequest request.CreateUserRequest&#10;&#9;&#9;if err := ctx.ShouldBindJSON(&amp;userRequest); err != nil {&#10;&#9;&#9;&#9;u.logger.Error(&quot;Error binding JSON: &quot;, err)&#10;&#9;&#9;&#9;ctx.JSON(http.StatusBadRequest, rest.ErrorResponse{ApiError: rest.BadRequestError, Message: &quot;Invalid request body&quot;})&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#10;&#9;&#9;if err := userRequest.Validate(); err != nil {&#10;&#9;&#9;&#9;u.logger.Error(&quot;Validation fail: &quot;, err)&#10;&#9;&#9;&#9;ctx.JSON(http.StatusBadRequest, rest.ErrorResponse{ApiError: rest.ValidationError, Message: err.Error()})&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#10;&#9;&#9;u.logger.Info(&quot;Creating new user with email: &quot;, userRequest.Email)&#10;&#10;&#9;&#9;user, err := u.userService.CreateUser(&amp;userRequest)&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;u.logger.Error(&quot;Error creating user: &quot;, err)&#10;&#9;&#9;&#9;ctx.JSON(http.StatusInternalServerError, rest.ErrorResponse{ApiError: rest.InternalServerErrorError, Message: &quot;Failed to create user&quot;})&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#10;&#9;&#9;u.logger.Info(&quot;Successfully created user with ID: &quot;, user.ID)&#10;&#9;&#9;ctx.JSON(http.StatusCreated, rest.NewAPIResponse(http.StatusCreated, &quot;User created successfully&quot;, user))&#10;&#9;}&#10;}&#10;&#10;func (u *UserController) UpdateUserProfile() func(ctx *gin.Context) {&#10;&#9;return func(ctx *gin.Context) {&#10;&#9;&#9;idStr := ctx.Param(&quot;id&quot;)&#10;&#10;&#9;&#9;id, err := strconv.Atoi(idStr)&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;u.logger.Error(&quot;Invalid user ID: &quot;, idStr, &quot;, Error: &quot;, err)&#10;&#9;&#9;&#9;ctx.JSON(http.StatusBadRequest, rest.ErrorResponse{ApiError: rest.BadRequestError, Message: &quot;Invalid user ID format&quot;})&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#10;&#9;&#9;var updateRequest request.UpdateUserProfileRequest&#10;&#9;&#9;if err := ctx.ShouldBindJSON(&amp;updateRequest); err != nil {&#10;&#9;&#9;&#9;u.logger.Error(&quot;Error binding JSON: &quot;, err)&#10;&#9;&#9;&#9;ctx.JSON(http.StatusBadRequest, rest.ErrorResponse{ApiError: rest.BadRequestError, Message: &quot;Invalid request body&quot;})&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// Validate the update request&#10;&#9;&#9;if err := updateRequest.Validate(); err != nil {&#10;&#9;&#9;&#9;u.logger.Error(&quot;Validation failed: &quot;, err)&#10;&#9;&#9;&#9;ctx.JSON(http.StatusBadRequest, rest.ErrorResponse{ApiError: rest.ValidationError, Message: err.Error()})&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#10;&#9;&#9;u.logger.Info(&quot;Updating user profile with ID: &quot;, id)&#10;&#10;&#9;&#9;user, err := u.userService.UpdateUserProfile(int64(id), &amp;updateRequest)&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;u.logger.Error(&quot;Error updating user profile: &quot;, err)&#10;&#9;&#9;&#9;ctx.JSON(http.StatusInternalServerError, rest.ErrorResponse{ApiError: rest.InternalServerErrorError, Message: &quot;Failed to update user profile&quot;})&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#10;&#9;&#9;u.logger.Info(&quot;Successfully updated user profile with ID: &quot;, id)&#10;&#9;&#9;ctx.JSON(http.StatusOK, rest.NewAPIResponse(http.StatusOK, &quot;User profile updated successfully&quot;, user))&#10;&#9;}&#10;}&#10;&#10;func (u *UserController) UpdateUserPassword() func(ctx *gin.Context) {&#10;&#9;return func(ctx *gin.Context) {&#10;&#9;&#9;idStr := ctx.Param(&quot;id&quot;)&#10;&#10;&#9;&#9;id, err := strconv.Atoi(idStr)&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;u.logger.Error(&quot;Invalid user ID: &quot;, idStr, &quot;, Error: &quot;, err)&#10;&#9;&#9;&#9;ctx.JSON(http.StatusBadRequest, rest.ErrorResponse{ApiError: rest.BadRequestError, Message: &quot;Invalid user ID format&quot;})&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#10;&#9;&#9;var passwordRequest request.UpdateUserPasswordRequest&#10;&#9;&#9;if err := ctx.ShouldBindJSON(&amp;passwordRequest); err != nil {&#10;&#9;&#9;&#9;u.logger.Error(&quot;Error binding JSON: &quot;, err)&#10;&#9;&#9;&#9;ctx.JSON(http.StatusBadRequest, rest.ErrorResponse{ApiError: rest.BadRequestError, Message: &quot;Invalid request body&quot;})&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#10;&#9;&#9;if err := passwordRequest.Validate(); err != nil {&#10;&#9;&#9;&#9;u.logger.Error(&quot;Validation failed: &quot;, err)&#10;&#9;&#9;&#9;ctx.JSON(http.StatusBadRequest, rest.ErrorResponse{ApiError: rest.ValidationError, Message: err.Error()})&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#10;&#9;&#9;u.logger.Info(&quot;Updating user password for ID: &quot;, id)&#10;&#10;&#9;&#9;user, err := u.userService.UpdateUserPassword(int64(id), &amp;passwordRequest)&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;u.logger.Error(&quot;Error updating user password: &quot;, err)&#10;&#9;&#9;&#9;ctx.JSON(http.StatusInternalServerError, rest.ErrorResponse{ApiError: rest.InternalServerErrorError, Message: &quot;Failed to update user password&quot;})&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#10;&#9;&#9;u.logger.Info(&quot;Successfully updated user password for ID: &quot;, id)&#10;&#9;&#9;ctx.JSON(http.StatusOK, rest.NewAPIResponse(http.StatusOK, &quot;User password updated successfully&quot;, user))&#10;&#9;}&#10;}&#10;&#10;func (u *UserController) UpdateToMerchantAccount() func(ctx *gin.Context) {&#10;&#9;return func(ctx *gin.Context) {&#10;&#9;&#9;idStr := ctx.Param(&quot;id&quot;)&#10;&#10;&#9;&#9;id, err := strconv.Atoi(idStr)&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;u.logger.Error(&quot;Invalid user ID: &quot;, idStr, &quot;, Error: &quot;, err)&#10;&#9;&#9;&#9;ctx.JSON(http.StatusBadRequest, rest.ErrorResponse{ApiError: rest.BadRequestError, Message: &quot;Invalid user ID format&quot;})&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#10;&#9;&#9;u.logger.Info(&quot;Updating user to merchant account with ID: &quot;, id)&#10;&#10;&#9;&#9;if err := u.userService.UpdateToMerchantAccount(int64(id)); err != nil {&#10;&#9;&#9;&#9;u.logger.Error(&quot;Error updating user to merchant account with ID: &quot;, id, &quot;, Error: &quot;, err)&#10;&#9;&#9;&#9;ctx.JSON(http.StatusInternalServerError, rest.ErrorResponse{ApiError: rest.InternalServerErrorError, Message: &quot;Failed to update user to merchant account&quot;})&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#10;&#9;&#9;u.logger.Info(&quot;Successfully updated user to merchant account with ID: &quot;, id)&#10;&#9;&#9;ctx.JSON(http.StatusOK, rest.NewAPIResponse(http.StatusOK, &quot;User updated to merchant account successfully&quot;, nil))&#10;&#9;}&#10;}&#10;&#10;func (u *UserController) DeleteUser() func(ctx *gin.Context) {&#10;&#9;return func(ctx *gin.Context) {&#10;&#9;&#9;idStr := ctx.Param(&quot;id&quot;)&#10;&#10;&#9;&#9;id, err := strconv.Atoi(idStr)&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;u.logger.Error(&quot;Invalid user ID: &quot;, idStr, &quot;, Error: &quot;, err)&#10;&#9;&#9;&#9;ctx.JSON(http.StatusBadRequest, rest.ErrorResponse{ApiError: rest.BadRequestError, Message: &quot;Invalid user ID format&quot;})&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#10;&#9;&#9;u.logger.Info(&quot;Deleting user with ID: &quot;, id)&#10;&#10;&#9;&#9;if err := u.userService.DeleteUser(int64(id)); err != nil {&#10;&#9;&#9;&#9;u.logger.Error(&quot;Error deleting user with ID: &quot;, id, &quot;, Error: &quot;, err)&#10;&#9;&#9;&#9;ctx.JSON(http.StatusInternalServerError, rest.ErrorResponse{ApiError: rest.InternalServerErrorError, Message: &quot;Failed to delete user&quot;})&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#10;&#9;&#9;u.logger.Info(&quot;Successfully deleted user with ID: &quot;, id)&#10;&#9;&#9;ctx.JSON(http.StatusNoContent, rest.NewAPIResponse(http.StatusNoContent, &quot;User deleted successfully&quot;, nil))&#10;&#9;}&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/internal/services/identity/internal/dto/request/refresh_token_request.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/internal/services/identity/internal/dto/request/refresh_token_request.go" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/internal/services/identity/internal/service/user_service.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/internal/services/identity/internal/service/user_service.go" />
              <option name="originalContent" value="package service&#10;&#10;import (&#10;&#9;&quot;context&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/services/identity/internal/controller/http/client&quot;&#10;&#9;&quot;time&quot;&#10;&#10;&#9;log &quot;github.com/hthinh24/go-store/internal/pkg/logger&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/services/identity&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/services/identity/internal/constants&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/services/identity/internal/dto/request&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/services/identity/internal/dto/response&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/services/identity/internal/entity&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/services/identity/internal/errors&quot;&#10;&#9;&quot;golang.org/x/crypto/bcrypt&quot;&#10;)&#10;&#10;type userService struct {&#10;&#9;logger         log.Logger&#10;&#9;userRepository identity.UserRepository&#10;&#9;authRepository identity.AuthRepository&#10;&#9;cartClient     client.CartClient&#10;}&#10;&#10;func NewUserService(logger log.Logger,&#10;&#9;userRepository identity.UserRepository,&#10;&#9;authRepository identity.AuthRepository,&#10;&#9;cartClient client.CartClient) identity.UserService {&#10;&#9;return &amp;userService{&#10;&#9;&#9;logger:         logger,&#10;&#9;&#9;userRepository: userRepository,&#10;&#9;&#9;authRepository: authRepository,&#10;&#9;&#9;cartClient:     cartClient,&#10;&#9;}&#10;}&#10;&#10;func (u *userService) GetUserByID(id int64) (*response.UserResponse, error) {&#10;&#9;u.logger.Info(&quot;Get user by ID:&quot;, id)&#10;&#10;&#9;user, err := u.userRepository.FindUserByID(id)&#10;&#9;if err != nil {&#10;&#9;&#9;u.logger.Error(&quot;Error fetching user by ID:&quot;, err)&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;u.logger.Info(&quot;Get user successfully&quot;)&#10;&#9;return createUserResponse(user), nil&#10;}&#10;&#10;func (u *userService) GetUsers() (*[]response.UserResponse, error) {&#10;&#9;u.logger.Info(&quot;Get all users&quot;)&#10;&#10;&#9;users, err := u.userRepository.FindUsers()&#10;&#9;if err != nil {&#10;&#9;&#9;u.logger.Error(&quot;Error fetching users:&quot;, err)&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;u.logger.Info(&quot;Get all users successfully&quot;)&#10;&#9;var userResponses []response.UserResponse&#10;&#9;for _, user := range *users {&#10;&#9;&#9;userResponses = append(userResponses, *createUserResponse(&amp;user))&#10;&#9;}&#10;&#9;return &amp;userResponses, nil&#10;}&#10;&#10;func (u *userService) CreateUser(data *request.CreateUserRequest) (*response.UserResponse, error) {&#10;&#9;u.logger.Info(&quot;Creating new user with email:&quot;, data.Email)&#10;&#10;&#9;hashedPassword, err := bcrypt.GenerateFromPassword([]byte(data.Password), bcrypt.DefaultCost)&#10;&#9;if err != nil {&#10;&#9;&#9;u.logger.Error(&quot;Error hashing password:&quot;, err)&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;data.Password = string(hashedPassword)&#10;&#9;user := u.createUserEntity(data)&#10;&#9;if err := u.userRepository.CreateUser(user); err != nil {&#10;&#9;&#9;u.logger.Error(&quot;Error creating user:&quot;, err)&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;if err := u.setUserRoleToUser(user); err != nil {&#10;&#9;&#9;u.logger.Error(&quot;Error setting user role:&quot;, err)&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;// Create a cart for the new user (only if cart client is properly configured)&#10;&#9;if u.cartClient != nil {&#10;&#9;&#9;ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)&#10;&#9;&#9;defer cancel()&#10;&#10;&#9;&#9;if err := u.cartClient.CreateCart(ctx, user.ID); err != nil {&#10;&#9;&#9;&#9;u.logger.Error(&quot;Error creating cart for user:&quot;, err)&#10;&#9;&#9;&#9;// Don't fail user creation if cart creation fails - just log the error&#10;&#9;&#9;&#9;u.logger.Warn(&quot;User created successfully but cart creation failed - user can create cart later&quot;)&#10;&#9;&#9;&#9;// Rollback user creation if needed&#10;&#9;&#9;&#9;u.userRepository.DeleteUser(user.ID)&#10;&#9;&#9;&#9;return nil, errors.ErrCartCreationFailed{}&#10;&#9;&#9;} else {&#10;&#9;&#9;&#9;u.logger.Info(&quot;Cart created successfully for user ID:&quot;, user.ID)&#10;&#9;&#9;}&#10;&#9;} else {&#10;&#9;&#9;u.logger.Info(&quot;Cart client not configured - skipping cart creation for user ID:&quot;, user.ID)&#10;&#9;}&#10;&#10;&#9;u.logger.Info(&quot;Successfully created user with ID:&quot;, user.ID)&#10;&#9;return createUserResponse(user), nil&#10;}&#10;&#10;func (u *userService) UpdateUserProfile(id int64, data *request.UpdateUserProfileRequest) (*response.UserResponse, error) {&#10;&#9;user, err := u.userRepository.FindUserByID(id)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;u.logger.Info(&quot;Updating user profile with ID:&quot;, id)&#10;&#10;&#9;updateUserEntity(user, data)&#10;&#9;if err := u.userRepository.UpdateUserProfile(user); err != nil {&#10;&#9;&#9;u.logger.Error(&quot;Error updating user profile:&quot;, err)&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;u.logger.Info(&quot;Successfully updated user profile with ID:&quot;, id)&#10;&#9;return createUserResponse(user), nil&#10;}&#10;&#10;func (u *userService) UpdateUserPassword(id int64, data *request.UpdateUserPasswordRequest) (*response.UserResponse, error) {&#10;&#9;u.logger.Info(&quot;Find user by ID:&quot;, id)&#10;&#10;&#9;user, err := u.userRepository.FindUserByID(id)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;u.logger.Info(&quot;Updating user password for ID:&quot;, id)&#10;&#10;&#9;if err := bcrypt.CompareHashAndPassword([]byte(user.Password), []byte(data.OldPassword)); err != nil {&#10;&#9;&#9;u.logger.Error(&quot;Old password does not match for user ID:&quot;, id)&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;hashedPassword, err := bcrypt.GenerateFromPassword([]byte(data.NewPassword), bcrypt.DefaultCost)&#10;&#9;if err != nil {&#10;&#9;&#9;u.logger.Error(&quot;Error hashing new password:&quot;, err)&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;user.Password = string(hashedPassword)&#10;&#9;if err := u.userRepository.UpdateUserPassword(user); err != nil {&#10;&#9;&#9;u.logger.Error(&quot;Error updating user password:&quot;, err)&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#9;u.logger.Info(&quot;Successfully updated user password for ID:&quot;, id)&#10;&#9;return createUserResponse(user), nil&#10;}&#10;&#10;func (u *userService) UpdateToMerchantAccount(userID int64) error {&#10;&#9;u.logger.Info(&quot;Updating user to merchant account with ID:&quot;, userID)&#10;&#10;&#9;// TODO - Implement logic to update user to merchant account&#10;&#10;&#9;user, err := u.userRepository.FindUserByID(userID)&#10;&#9;if err != nil {&#10;&#9;&#9;u.logger.Error(&quot;Error finding user by ID:&quot;, userID, &quot;Error:&quot;, err)&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;if user.Status != string(constants.UserStatusActive) {&#10;&#9;&#9;u.logger.Error(&quot;User is not active, cannot update to merchant account:&quot;, userID)&#10;&#9;&#9;return errors.ErrUserNotActive{}&#10;&#9;}&#10;&#10;&#9;role, err := u.authRepository.FindRoleByName(string(constants.RoleMerchant))&#10;&#9;if err != nil {&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;userRoles := createUserRoleEntity(user, role)&#10;&#9;if err := u.authRepository.AddRoleToUser(userRoles); err != nil {&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;return nil&#10;}&#10;&#10;func (u *userService) DeleteUser(id int64) error {&#10;&#9;u.logger.Info(&quot;Deleting user with ID:&quot;, id)&#10;&#10;&#9;err := u.userRepository.DeleteUser(id)&#10;&#9;if err != nil {&#10;&#9;&#9;u.logger.Error(&quot;Error deleting user with ID:&quot;, id, &quot;Error:&quot;, err)&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;u.logger.Info(&quot;Successfully deleted user with ID:&quot;, id)&#10;&#9;return nil&#10;}&#10;&#10;func (u *userService) createUserEntity(user *request.CreateUserRequest) *entity.User {&#10;&#9;return &amp;entity.User{&#10;&#9;&#9;Email:        user.Email,&#10;&#9;&#9;Password:     user.Password,&#10;&#9;&#9;ProviderID:   user.ProviderID,&#10;&#9;&#9;ProviderName: user.ProviderName,&#10;&#9;&#9;LastName:     user.LastName,&#10;&#9;&#9;FirstName:    user.FirstName,&#10;&#9;&#9;Avatar:       user.Avatar,&#10;&#9;&#9;Gender:       user.Gender,&#10;&#9;&#9;PhoneNumber:  user.PhoneNumber,&#10;&#9;&#9;DateOfBirth:  user.DateOfBirth,&#10;&#9;&#9;Status:       user.Status,&#10;&#9;}&#10;}&#10;&#10;func createUserRoleEntity(user *entity.User, role *entity.Role) *entity.UserRoles {&#10;&#9;return &amp;entity.UserRoles{&#10;&#9;&#9;UserID: user.ID,&#10;&#9;&#9;RoleID: role.ID,&#10;&#9;}&#10;}&#10;&#10;func updateUserEntity(user *entity.User, data *request.UpdateUserProfileRequest) {&#10;&#9;if data.Email != nil {&#10;&#9;&#9;user.Email = *data.Email&#10;&#9;}&#10;&#9;if data.LastName != nil {&#10;&#9;&#9;user.LastName = *data.LastName&#10;&#9;}&#10;&#9;if data.FirstName != nil {&#10;&#9;&#9;user.FirstName = *data.FirstName&#10;&#9;}&#10;&#9;if data.Avatar != nil {&#10;&#9;&#9;user.Avatar = *data.Avatar&#10;&#9;}&#10;&#9;if data.Gender != nil {&#10;&#9;&#9;user.Gender = *data.Gender&#10;&#9;}&#10;&#9;if data.PhoneNumber != nil {&#10;&#9;&#9;user.PhoneNumber = *data.PhoneNumber&#10;&#9;}&#10;&#9;if data.DateOfBirth != nil {&#10;&#9;&#9;user.DateOfBirth = *data.DateOfBirth&#10;&#9;}&#10;}&#10;&#10;func createUserResponse(user *entity.User) *response.UserResponse {&#10;&#9;return &amp;response.UserResponse{&#10;&#9;&#9;ID:          user.ID,&#10;&#9;&#9;Email:       user.Email,&#10;&#9;&#9;LastName:    user.LastName,&#10;&#9;&#9;FirstName:   user.FirstName,&#10;&#9;&#9;Avatar:      user.Avatar,&#10;&#9;&#9;Gender:      user.Gender,&#10;&#9;&#9;PhoneNumber: user.PhoneNumber,&#10;&#9;&#9;DateOfBirth: user.DateOfBirth,&#10;&#9;&#9;Status:      user.Status,&#10;&#9;}&#10;}&#10;&#10;func (u *userService) setUserRoleToUser(user *entity.User) error {&#10;&#9;role, err := u.authRepository.FindRoleByName(string(constants.RoleUser))&#10;&#9;if err != nil {&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;userRoles := createUserRoleEntity(user, role)&#10;&#10;&#9;if err := u.authRepository.AddRoleToUser(userRoles); err != nil {&#10;&#9;&#9;u.logger.Error(&quot;Error assigning role to user:&quot;, err)&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;u.logger.Info(&quot;Successfully assigned role to user with ID:&quot;, user.ID)&#10;&#9;return nil&#10;}&#10;" />
              <option name="updatedContent" value="package service&#10;&#10;import (&#10;&#9;&quot;context&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/services/identity/internal/controller/http/client&quot;&#10;&#9;&quot;time&quot;&#10;&#10;&#9;log &quot;github.com/hthinh24/go-store/internal/pkg/logger&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/services/identity&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/services/identity/internal/constants&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/services/identity/internal/dto/request&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/services/identity/internal/dto/response&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/services/identity/internal/entity&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/services/identity/internal/errors&quot;&#10;&#9;&quot;golang.org/x/crypto/bcrypt&quot;&#10;)&#10;&#10;type userService struct {&#10;&#9;logger         log.Logger&#10;&#9;userRepository identity.UserRepository&#10;&#9;authRepository identity.AuthRepository&#10;&#9;cartClient     client.CartClient&#10;}&#10;&#10;func NewUserService(logger log.Logger,&#10;&#9;userRepository identity.UserRepository,&#10;&#9;authRepository identity.AuthRepository,&#10;&#9;cartClient client.CartClient) identity.UserService {&#10;&#9;return &amp;userService{&#10;&#9;&#9;logger:         logger,&#10;&#9;&#9;userRepository: userRepository,&#10;&#9;&#9;authRepository: authRepository,&#10;&#9;&#9;cartClient:     cartClient,&#10;&#9;}&#10;}&#10;&#10;func (u *userService) GetUserByID(id int64) (*response.UserResponse, error) {&#10;&#9;u.logger.Info(&quot;Get user by ID: &quot;, id)&#10;&#10;&#9;user, err := u.userRepository.FindUserByID(id)&#10;&#9;if err != nil {&#10;&#9;&#9;u.logger.Error(&quot;Error fetching user by ID: &quot;, err)&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;u.logger.Info(&quot;Get user successfully&quot;)&#10;&#9;return createUserResponse(user), nil&#10;}&#10;&#10;func (u *userService) GetUsers() (*[]response.UserResponse, error) {&#10;&#9;u.logger.Info(&quot;Get all users&quot;)&#10;&#10;&#9;users, err := u.userRepository.FindUsers()&#10;&#9;if err != nil {&#10;&#9;&#9;u.logger.Error(&quot;Error fetching users: &quot;, err)&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;u.logger.Info(&quot;Get all users successfully&quot;)&#10;&#9;var userResponses []response.UserResponse&#10;&#9;for _, user := range *users {&#10;&#9;&#9;userResponses = append(userResponses, *createUserResponse(&amp;user))&#10;&#9;}&#10;&#9;return &amp;userResponses, nil&#10;}&#10;&#10;func (u *userService) CreateUser(data *request.CreateUserRequest) (*response.UserResponse, error) {&#10;&#9;u.logger.Info(&quot;Creating new user with email:&quot;, data.Email)&#10;&#10;&#9;hashedPassword, err := bcrypt.GenerateFromPassword([]byte(data.Password), bcrypt.DefaultCost)&#10;&#9;if err != nil {&#10;&#9;&#9;u.logger.Error(&quot;Error hashing password:&quot;, err)&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;data.Password = string(hashedPassword)&#10;&#9;user := u.createUserEntity(data)&#10;&#9;if err := u.userRepository.CreateUser(user); err != nil {&#10;&#9;&#9;u.logger.Error(&quot;Error creating user:&quot;, err)&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;if err := u.setUserRoleToUser(user); err != nil {&#10;&#9;&#9;u.logger.Error(&quot;Error setting user role:&quot;, err)&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;// Create a cart for the new user (only if cart client is properly configured)&#10;&#9;if u.cartClient != nil {&#10;&#9;&#9;ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)&#10;&#9;&#9;defer cancel()&#10;&#10;&#9;&#9;if err := u.cartClient.CreateCart(ctx, user.ID); err != nil {&#10;&#9;&#9;&#9;u.logger.Error(&quot;Error creating cart for user:&quot;, err)&#10;&#9;&#9;&#9;// Don't fail user creation if cart creation fails - just log the error&#10;&#9;&#9;&#9;u.logger.Warn(&quot;User created successfully but cart creation failed - user can create cart later&quot;)&#10;&#9;&#9;&#9;// Rollback user creation if needed&#10;&#9;&#9;&#9;u.userRepository.DeleteUser(user.ID)&#10;&#9;&#9;&#9;return nil, errors.ErrCartCreationFailed{}&#10;&#9;&#9;} else {&#10;&#9;&#9;&#9;u.logger.Info(&quot;Cart created successfully for user ID:&quot;, user.ID)&#10;&#9;&#9;}&#10;&#9;} else {&#10;&#9;&#9;u.logger.Info(&quot;Cart client not configured - skipping cart creation for user ID:&quot;, user.ID)&#10;&#9;}&#10;&#10;&#9;u.logger.Info(&quot;Successfully created user with ID:&quot;, user.ID)&#10;&#9;return createUserResponse(user), nil&#10;}&#10;&#10;func (u *userService) UpdateUserProfile(id int64, data *request.UpdateUserProfileRequest) (*response.UserResponse, error) {&#10;&#9;user, err := u.userRepository.FindUserByID(id)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;u.logger.Info(&quot;Updating user profile with ID:&quot;, id)&#10;&#10;&#9;updateUserEntity(user, data)&#10;&#9;if err := u.userRepository.UpdateUserProfile(user); err != nil {&#10;&#9;&#9;u.logger.Error(&quot;Error updating user profile:&quot;, err)&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;u.logger.Info(&quot;Successfully updated user profile with ID:&quot;, id)&#10;&#9;return createUserResponse(user), nil&#10;}&#10;&#10;func (u *userService) UpdateUserPassword(id int64, data *request.UpdateUserPasswordRequest) (*response.UserResponse, error) {&#10;&#9;u.logger.Info(&quot;Find user by ID:&quot;, id)&#10;&#10;&#9;user, err := u.userRepository.FindUserByID(id)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;u.logger.Info(&quot;Updating user password for ID:&quot;, id)&#10;&#10;&#9;if err := bcrypt.CompareHashAndPassword([]byte(user.Password), []byte(data.OldPassword)); err != nil {&#10;&#9;&#9;u.logger.Error(&quot;Old password does not match for user ID:&quot;, id)&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;hashedPassword, err := bcrypt.GenerateFromPassword([]byte(data.NewPassword), bcrypt.DefaultCost)&#10;&#9;if err != nil {&#10;&#9;&#9;u.logger.Error(&quot;Error hashing new password:&quot;, err)&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;user.Password = string(hashedPassword)&#10;&#9;if err := u.userRepository.UpdateUserPassword(user); err != nil {&#10;&#9;&#9;u.logger.Error(&quot;Error updating user password:&quot;, err)&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#9;u.logger.Info(&quot;Successfully updated user password for ID:&quot;, id)&#10;&#9;return createUserResponse(user), nil&#10;}&#10;&#10;func (u *userService) UpdateToMerchantAccount(userID int64) error {&#10;&#9;u.logger.Info(&quot;Updating user to merchant account with ID:&quot;, userID)&#10;&#10;&#9;// TODO - Implement logic to update user to merchant account&#10;&#10;&#9;user, err := u.userRepository.FindUserByID(userID)&#10;&#9;if err != nil {&#10;&#9;&#9;u.logger.Error(&quot;Error finding user by ID:&quot;, userID, &quot;Error:&quot;, err)&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;if user.Status != string(constants.UserStatusActive) {&#10;&#9;&#9;u.logger.Error(&quot;User is not active, cannot update to merchant account:&quot;, userID)&#10;&#9;&#9;return errors.ErrUserNotActive{}&#10;&#9;}&#10;&#10;&#9;role, err := u.authRepository.FindRoleByName(string(constants.RoleMerchant))&#10;&#9;if err != nil {&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;userRoles := createUserRoleEntity(user, role)&#10;&#9;if err := u.authRepository.AddRoleToUser(userRoles); err != nil {&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;return nil&#10;}&#10;&#10;func (u *userService) DeleteUser(id int64) error {&#10;&#9;u.logger.Info(&quot;Deleting user with ID:&quot;, id)&#10;&#10;&#9;err := u.userRepository.DeleteUser(id)&#10;&#9;if err != nil {&#10;&#9;&#9;u.logger.Error(&quot;Error deleting user with ID:&quot;, id, &quot;Error:&quot;, err)&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;u.logger.Info(&quot;Successfully deleted user with ID:&quot;, id)&#10;&#9;return nil&#10;}&#10;&#10;func (u *userService) createUserEntity(user *request.CreateUserRequest) *entity.User {&#10;&#9;return &amp;entity.User{&#10;&#9;&#9;Email:        user.Email,&#10;&#9;&#9;Password:     user.Password,&#10;&#9;&#9;ProviderID:   user.ProviderID,&#10;&#9;&#9;ProviderName: user.ProviderName,&#10;&#9;&#9;LastName:     user.LastName,&#10;&#9;&#9;FirstName:    user.FirstName,&#10;&#9;&#9;Avatar:       user.Avatar,&#10;&#9;&#9;Gender:       user.Gender,&#10;&#9;&#9;PhoneNumber:  user.PhoneNumber,&#10;&#9;&#9;DateOfBirth:  user.DateOfBirth,&#10;&#9;&#9;Status:       user.Status,&#10;&#9;}&#10;}&#10;&#10;func createUserRoleEntity(user *entity.User, role *entity.Role) *entity.UserRoles {&#10;&#9;return &amp;entity.UserRoles{&#10;&#9;&#9;UserID: user.ID,&#10;&#9;&#9;RoleID: role.ID,&#10;&#9;}&#10;}&#10;&#10;func updateUserEntity(user *entity.User, data *request.UpdateUserProfileRequest) {&#10;&#9;if data.Email != nil {&#10;&#9;&#9;user.Email = *data.Email&#10;&#9;}&#10;&#9;if data.LastName != nil {&#10;&#9;&#9;user.LastName = *data.LastName&#10;&#9;}&#10;&#9;if data.FirstName != nil {&#10;&#9;&#9;user.FirstName = *data.FirstName&#10;&#9;}&#10;&#9;if data.Avatar != nil {&#10;&#9;&#9;user.Avatar = *data.Avatar&#10;&#9;}&#10;&#9;if data.Gender != nil {&#10;&#9;&#9;user.Gender = *data.Gender&#10;&#9;}&#10;&#9;if data.PhoneNumber != nil {&#10;&#9;&#9;user.PhoneNumber = *data.PhoneNumber&#10;&#9;}&#10;&#9;if data.DateOfBirth != nil {&#10;&#9;&#9;user.DateOfBirth = *data.DateOfBirth&#10;&#9;}&#10;}&#10;&#10;func createUserResponse(user *entity.User) *response.UserResponse {&#10;&#9;return &amp;response.UserResponse{&#10;&#9;&#9;ID:          user.ID,&#10;&#9;&#9;Email:       user.Email,&#10;&#9;&#9;LastName:    user.LastName,&#10;&#9;&#9;FirstName:   user.FirstName,&#10;&#9;&#9;Avatar:      user.Avatar,&#10;&#9;&#9;Gender:      user.Gender,&#10;&#9;&#9;PhoneNumber: user.PhoneNumber,&#10;&#9;&#9;DateOfBirth: user.DateOfBirth,&#10;&#9;&#9;Status:      user.Status,&#10;&#9;}&#10;}&#10;&#10;func (u *userService) setUserRoleToUser(user *entity.User) error {&#10;&#9;role, err := u.authRepository.FindRoleByName(string(constants.RoleUser))&#10;&#9;if err != nil {&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;userRoles := createUserRoleEntity(user, role)&#10;&#10;&#9;if err := u.authRepository.AddRoleToUser(userRoles); err != nil {&#10;&#9;&#9;u.logger.Error(&quot;Error assigning role to user:&quot;, err)&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;u.logger.Info(&quot;Successfully assigned role to user with ID:&quot;, user.ID)&#10;&#9;return nil&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/internal/services/product/cmd/main.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/internal/services/product/cmd/main.go" />
              <option name="originalContent" value="package main&#10;&#10;import (&#10;&#9;&quot;github.com/hthinh24/go-store/internal/pkg/middleware/auth&quot;&#10;&#9;&quot;log&quot;&#10;&#10;&#9;&quot;github.com/gin-gonic/gin&quot;&#10;&#9;customLog &quot;github.com/hthinh24/go-store/internal/pkg/logger&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/services/product/internal/config&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/services/product/internal/controller&quot;&#10;&#9;repository &quot;github.com/hthinh24/go-store/services/product/internal/infra/repository/postgres&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/services/product/internal/service&quot;&#10;&#9;&quot;gorm.io/driver/postgres&quot;&#10;&#9;&quot;gorm.io/gorm&quot;&#10;)&#10;&#10;func main() {&#10;&#9;fileName := &quot;.env&quot;&#10;&#9;// Load configuration from environment variables&#10;&#9;cfg, err := config.LoadConfig(fileName)&#10;&#9;if err != nil {&#10;&#9;&#9;log.Fatalf(&quot;Failed to load config: %v&quot;, err)&#10;&#9;}&#10;&#10;&#9;// Initialize appLogger&#10;&#9;appLogger := customLog.NewAppLogger(cfg.LogLevel)&#10;&#9;appLogger.Info(&quot;Starting Product Service...&quot;)&#10;&#9;appLogger.Info(&quot;Environment: %s&quot;, cfg.Environment)&#10;&#10;&#9;// Initialize database connection&#10;&#9;db, err := initDatabase(cfg)&#10;&#9;if err != nil {&#10;&#9;&#9;appLogger.Error(&quot;Failed to connect to database: %v&quot;, err)&#10;&#9;&#9;log.Fatal(err)&#10;&#9;}&#10;&#9;appLogger.Info(&quot;Database connected successfully&quot;)&#10;&#10;&#9;// Initialize repositories&#10;&#9;productRepository := repository.NewProductRepository(&#10;&#9;&#9;customLog.WithComponent(cfg.LogLevel, &quot;PRODUCT-REPOSITORY&quot;),&#10;&#9;&#9;db)&#10;&#10;&#9;// Initialize services&#10;&#9;productService := service.NewProductService(&#10;&#9;&#9;customLog.WithComponent(cfg.LogLevel, &quot;PRODUCT-SERVICE&quot;),&#10;&#9;&#9;productRepository)&#10;&#10;&#9;// Initialize controllers&#10;&#9;productController := controller.NewProductController(&#10;&#9;&#9;customLog.WithComponent(cfg.LogLevel, &quot;PRODUCT-CONTROLLER&quot;),&#10;&#9;&#9;productService)&#10;&#10;&#9;// Setup router&#10;&#9;router := setupRouter(productController, cfg)&#10;&#10;&#9;// Start server&#10;&#9;serverAddr := cfg.GetServerAddress()&#10;&#9;appLogger.Info(&quot;Server starting on %s&quot;, serverAddr)&#10;&#9;if err := router.Run(serverAddr); err != nil {&#10;&#9;&#9;appLogger.Error(&quot;Failed to start server: %v&quot;, err)&#10;&#9;&#9;log.Fatal(err)&#10;&#9;}&#10;}&#10;&#10;func initDatabase(cfg *config.AppConfig) (*gorm.DB, error) {&#10;&#9;db, err := gorm.Open(postgres.Open(cfg.GetDatabaseURL()), &amp;gorm.Config{})&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;return db, nil&#10;}&#10;&#10;func setupRouter(productController *controller.ProductController, cfg *config.AppConfig) *gin.Engine {&#10;&#9;router := gin.Default()&#10;&#10;&#9;authMiddleware := auth.NewSharedAuthMiddleware(customLog.WithComponent(cfg.LogLevel, &quot;AUTH-MIDDLEWARE&quot;))&#10;&#10;&#9;router.GET(&quot;/health&quot;, func(c *gin.Context) {&#10;&#9;&#9;c.JSON(200, gin.H{&quot;status&quot;: &quot;healthy&quot;})&#10;&#9;})&#10;&#10;&#9;api := router.Group(&quot;/api&quot;)&#10;&#9;{&#10;&#9;&#9;v1 := api.Group(&quot;/v1&quot;)&#10;&#9;&#9;products := v1.Group(&quot;/products&quot;)&#10;&#9;&#9;{&#10;&#9;&#9;&#9;// Public routes&#10;&#9;&#9;&#9;products.GET(&quot;/:id&quot;, productController.GetProductByID())&#10;&#9;&#9;&#9;products.GET(&quot;/:id/detail&quot;, productController.GetProductDetailByID())&#10;&#9;&#9;&#9;products.GET(&quot;/skus/:id&quot;, productController.GetProductSKUByID())&#10;&#10;&#9;&#9;&#9;// Protected routes&#10;&#9;&#9;&#9;// TODO - Implement this later&#10;&#9;&#9;&#9;//products.GET(&quot;:userID/products&quot;,&#10;&#9;&#9;&#9;//&#9;authMiddleware.AuthRequired(),&#10;&#9;&#9;&#9;//&#9;productController.GetProductByUserID())&#10;&#10;&#9;&#9;&#9;products.POST(&quot;&quot;,&#10;&#9;&#9;&#9;&#9;authMiddleware.AuthRequired(),&#10;&#9;&#9;&#9;&#9;authMiddleware.RequireAnyPermission(&quot;product.create&quot;),&#10;&#9;&#9;&#9;&#9;productController.CreateProduct())&#10;&#10;&#9;&#9;&#9;products.POST(&quot;/no-sku&quot;,&#10;&#9;&#9;&#9;&#9;authMiddleware.AuthRequired(),&#10;&#9;&#9;&#9;&#9;authMiddleware.RequireAnyPermission(&quot;product.create&quot;),&#10;&#9;&#9;&#9;&#9;productController.CreateProductWithoutSKU())&#10;&#10;&#9;&#9;&#9;products.DELETE(&quot;/:id&quot;,&#10;&#9;&#9;&#9;&#9;authMiddleware.AuthRequired(),&#10;&#9;&#9;&#9;&#9;authMiddleware.RequireAnyPermission(&quot;product.delete&quot;),&#10;&#9;&#9;&#9;&#9;productController.DeleteProductByID())&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;return router&#10;}&#10;" />
              <option name="updatedContent" value="package main&#13;&#10;&#13;&#10;import (&#13;&#10;&#9;&quot;github.com/hthinh24/go-store/internal/pkg/middleware/auth&quot;&#13;&#10;&#9;&quot;log&quot;&#13;&#10;&#13;&#10;&#9;&quot;github.com/gin-gonic/gin&quot;&#13;&#10;&#9;customLog &quot;github.com/hthinh24/go-store/internal/pkg/logger&quot;&#13;&#10;&#9;&quot;github.com/hthinh24/go-store/internal/services/product/internal/config&quot;&#13;&#10;&#9;&quot;github.com/hthinh24/go-store/internal/services/product/internal/controller&quot;&#13;&#10;&#9;repository &quot;github.com/hthinh24/go-store/internal/services/product/internal/infra/repository/postgres&quot;&#13;&#10;&#9;&quot;github.com/hthinh24/go-store/internal/services/product/internal/service&quot;&#13;&#10;&#9;&quot;gorm.io/driver/postgres&quot;&#13;&#10;&#9;&quot;gorm.io/gorm&quot;&#13;&#10;)&#13;&#10;&#13;&#10;func main() {&#13;&#10;&#9;configPath := &quot;config.yaml&quot;&#13;&#10;&#13;&#10;&#9;// Load configuration using shared pkg config&#13;&#10;&#9;cfg, err := config.LoadConfig(configPath)&#13;&#10;&#9;if err != nil {&#13;&#10;&#9;&#9;log.Fatalf(&quot;Failed to load config: %v&quot;, err)&#13;&#10;&#9;}&#13;&#10;&#13;&#10;&#9;// Initialize appLogger&#13;&#10;&#9;appLogger := customLog.NewAppLogger(cfg.GetLogLevel())&#13;&#10;&#9;appLogger.Info(&quot;Starting Product Service...&quot;)&#13;&#10;&#9;appLogger.Info(&quot;Environment: %s&quot;, cfg.GetEnvironment())&#13;&#10;&#13;&#10;&#9;// Initialize database connection&#13;&#10;&#9;db, err := initDatabase(cfg)&#13;&#10;&#9;if err != nil {&#13;&#10;&#9;&#9;appLogger.Error(&quot;Failed to connect to database: %v&quot;, err)&#13;&#10;&#9;&#9;log.Fatal(err)&#13;&#10;&#9;}&#13;&#10;&#9;appLogger.Info(&quot;Database connected successfully&quot;)&#13;&#10;&#13;&#10;&#9;// Initialize repositories&#13;&#10;&#9;productRepository := repository.NewProductRepository(&#13;&#10;&#9;&#9;customLog.WithComponent(cfg.LogLevel, &quot;PRODUCT-REPOSITORY&quot;),&#13;&#10;&#9;&#9;db)&#13;&#10;&#13;&#10;&#9;// Initialize services&#13;&#10;&#9;productService := service.NewProductService(&#13;&#10;&#9;&#9;customLog.WithComponent(cfg.LogLevel, &quot;PRODUCT-SERVICE&quot;),&#13;&#10;&#9;&#9;productRepository)&#13;&#10;&#13;&#10;&#9;// Initialize controllers&#13;&#10;&#9;productController := controller.NewProductController(&#13;&#10;&#9;&#9;customLog.WithComponent(cfg.LogLevel, &quot;PRODUCT-CONTROLLER&quot;),&#13;&#10;&#9;&#9;productService)&#13;&#10;&#13;&#10;&#9;// Setup router&#13;&#10;&#9;router := setupRouter(productController, cfg)&#13;&#10;&#13;&#10;&#9;// Start server&#13;&#10;&#9;serverAddr := cfg.GetServerAddress()&#13;&#10;&#9;appLogger.Info(&quot;Server starting on %s&quot;, serverAddr)&#13;&#10;&#9;if err := router.Run(serverAddr); err != nil {&#13;&#10;&#9;&#9;appLogger.Error(&quot;Failed to start server: %v&quot;, err)&#13;&#10;&#9;&#9;log.Fatal(err)&#13;&#10;&#9;}&#13;&#10;}&#13;&#10;&#13;&#10;func initDatabase(cfg *config.AppConfig) (*gorm.DB, error) {&#13;&#10;&#9;db, err := gorm.Open(postgres.Open(cfg.GetDatabaseURL()), &amp;gorm.Config{})&#13;&#10;&#9;if err != nil {&#13;&#10;&#9;&#9;return nil, err&#13;&#10;&#9;}&#13;&#10;&#13;&#10;&#9;return db, nil&#13;&#10;}&#13;&#10;&#13;&#10;func setupRouter(productController *controller.ProductController, cfg *config.AppConfig) *gin.Engine {&#13;&#10;&#9;router := gin.Default()&#13;&#10;&#13;&#10;&#9;authMiddleware := auth.NewSharedAuthMiddleware(customLog.WithComponent(cfg.LogLevel, &quot;AUTH-MIDDLEWARE&quot;))&#13;&#10;&#13;&#10;&#9;router.GET(&quot;/health&quot;, func(c *gin.Context) {&#13;&#10;&#9;&#9;c.JSON(200, gin.H{&quot;status&quot;: &quot;healthy&quot;})&#13;&#10;&#9;})&#13;&#10;&#13;&#10;&#9;api := router.Group(&quot;/api&quot;)&#13;&#10;&#9;{&#13;&#10;&#9;&#9;v1 := api.Group(&quot;/v1&quot;)&#13;&#10;&#9;&#9;products := v1.Group(&quot;/products&quot;)&#13;&#10;&#9;&#9;{&#13;&#10;&#9;&#9;&#9;// Public routes&#13;&#10;&#9;&#9;&#9;products.GET(&quot;/:id&quot;, productController.GetProductByID())&#13;&#10;&#9;&#9;&#9;products.GET(&quot;/:id/detail&quot;, productController.GetProductDetailByID())&#13;&#10;&#9;&#9;&#9;products.GET(&quot;/skus/:id&quot;, productController.GetProductSKUByID())&#13;&#10;&#13;&#10;&#9;&#9;&#9;// Protected routes&#13;&#10;&#9;&#9;&#9;// TODO - Implement this later&#13;&#10;&#9;&#9;&#9;//products.GET(&quot;:userID/products&quot;,&#13;&#10;&#9;&#9;&#9;//&#9;authMiddleware.AuthRequired(),&#13;&#10;&#9;&#9;&#9;//&#9;productController.GetProductByUserID())&#13;&#10;&#13;&#10;&#9;&#9;&#9;products.POST(&quot;&quot;,&#13;&#10;&#9;&#9;&#9;&#9;authMiddleware.AuthRequired(),&#13;&#10;&#9;&#9;&#9;&#9;authMiddleware.RequireAnyPermission(&quot;product.create&quot;),&#13;&#10;&#9;&#9;&#9;&#9;productController.CreateProduct())&#13;&#10;&#13;&#10;&#9;&#9;&#9;products.POST(&quot;/no-sku&quot;,&#13;&#10;&#9;&#9;&#9;&#9;authMiddleware.AuthRequired(),&#13;&#10;&#9;&#9;&#9;&#9;authMiddleware.RequireAnyPermission(&quot;product.create&quot;),&#13;&#10;&#9;&#9;&#9;&#9;productController.CreateProductWithoutSKU())&#13;&#10;&#13;&#10;&#9;&#9;&#9;products.DELETE(&quot;/:id&quot;,&#13;&#10;&#9;&#9;&#9;&#9;authMiddleware.AuthRequired(),&#13;&#10;&#9;&#9;&#9;&#9;authMiddleware.RequireAnyPermission(&quot;product.delete&quot;),&#13;&#10;&#9;&#9;&#9;&#9;productController.DeleteProductByID())&#13;&#10;&#9;&#9;}&#13;&#10;&#9;}&#13;&#10;&#13;&#10;&#9;return router&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/internal/services/product/config.yaml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/internal/services/product/config.yaml" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="environment: &quot;development&quot;&#10;service_name: &quot;product&quot;&#10;&#10;# Application Configuration (host and port from .env: SERVER_HOST=localhost, SERVER_PORT=8081)&#10;app:&#10;  host: &quot;localhost&quot;&#10;  port: &quot;8081&quot;&#10;&#10;# HTTP Server Configuration&#10;http:&#10;  read_timeout: 10&#10;  write_timeout: 10&#10;  max_header_bytes: 1048576&#10;  allowed_origins: &quot;*&quot;&#10;  allowed_methods: &quot;GET,POST,PUT,DELETE,OPTIONS&quot;&#10;  allowed_headers: &quot;Content-Type,Authorization&quot;&#10;  exposed_headers: &quot;&quot;&#10;  allow_credentials: true&#10;&#10;# Database Configuration (from .env: DB_HOST=localhost, DB_PORT=5002, etc.)&#10;pg:&#10;  host: &quot;localhost&quot;&#10;  port: &quot;5002&quot;&#10;  user: &quot;postgres&quot;&#10;  password: &quot;root&quot;&#10;  database: &quot;postgres&quot;&#10;  ssl_mode: &quot;disable&quot;&#10;  max_open_conns: 25&#10;  max_idle_conns: 10&#10;  conn_max_lifetime: 3600&#10;  conn_max_idle_time: 1800&#10;&#10;# JWT Configuration (from .env: JWT_SECRET=..., JWT_EXPIRATION=15m)&#10;jwt:&#10;  secret: &quot;5z4JF/JFOVgC20QTMNyMPeW9kri5mSZ+XHnN9B8a6CmV04jFiCkzyLnbm3IEk5XrCQJm1thcCncK5WOII1GGdF46fwbtakSklUVtUIbfbY4zEcSjBSkbz8vbtRDuEIvm0BYoRHqEHMQoO3O4uwI6WMfIGtphOLiQ6zgl6bDFrF8LKjg6rT/5vJTJiDOjf5dpfWL3Kj5qRwp/MdzR9IGp75tDf9IxaxpJ/dUj/xdlUaBv4Qvlk4829JHBESfvI0PhgvYUWPKC0ZJxZN1/7G1C8VwvMzrzVjViuUccTT3tbrT6z9QWIfzjopRVdWXItpb0wwWO0Wx4oDNR8Mqg32tlkDT1tQNiWbwQQ2Q4hKRkjpk=&quot;&#10;  expiration: &quot;15m&quot;&#10;  issuer: &quot;gostore-product&quot;&#10;  audience: &quot;gostore-users&quot;&#10;&#10;# Redis Configuration (from .env: REDIS_HOST=localhost, REDIS_PORT=6002)&#10;redis:&#10;  host: &quot;localhost&quot;&#10;  port: &quot;6002&quot;&#10;  password: &quot;&quot;&#10;  db: 0&#10;  pool_size: 10&#10;  min_idle_conns: 3&#10;  dial_timeout: 5&#10;  read_timeout: 3&#10;  write_timeout: 3&#10;  idle_timeout: 300&#10;&#10;# Logging Configuration (from .env: LOG_LEVEL=info)&#10;log:&#10;  level: &quot;info&quot;&#10;  format: &quot;json&quot;&#10;  output: &quot;stdout&quot;&#10;  file_path: &quot;&quot;&#10;  max_size: 10&#10;  max_backups: 3&#10;  max_age: 28&#10;  compress: true&#10;&#10;# Services Configuration for inter-service communication (updated USER_SERVICE_URL to identity_service_url)&#10;services:&#10;  identity_service_url: &quot;http://localhost:8080&quot;&#10;  product_service_url: &quot;http://localhost:8081&quot;&#10;  cart_service_url: &quot;http://localhost:8082&quot;&#10;  order_service_url: &quot;http://localhost:8083&quot;&#10;  gateway_service_url: &quot;http://localhost:8000&quot;&#10;  notification_service_url: &quot;http://localhost:8084&quot;&#10;  payment_service_url: &quot;http://localhost:8085&quot;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/internal/services/product/internal/config/config.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/internal/services/product/internal/config/config.go" />
              <option name="originalContent" value="package config&#10;&#10;import (&#10;&#9;&quot;fmt&quot;&#10;&#9;&quot;os&quot;&#10;&#10;&#9;&quot;github.com/joho/godotenv&quot;&#10;)&#10;&#10;type AppConfig struct {&#10;&#9;// Database Configuration&#10;&#9;DBHost     string&#10;&#9;DBPort     string&#10;&#9;DBUser     string&#10;&#9;DBPassword string&#10;&#9;DBName     string&#10;&#9;DBSSLMode  string&#10;&#10;&#9;// Server Configuration&#10;&#9;ServerPort string&#10;&#9;ServerHost string&#10;&#10;&#9;// JWT Configuration&#10;&#9;JWTSecret string&#10;&#9;JWTExpire string&#10;&#10;&#9;UserServiceURL string&#10;&#10;&#9;// Log Configuration&#10;&#9;LogLevel string&#10;&#10;&#9;// Redis Configuration&#10;&#9;RedisHost     string&#10;&#9;RedisPort     string&#10;&#9;RedisPassword string&#10;&#10;&#9;// Environment&#10;&#9;Environment string&#10;}&#10;&#10;func LoadConfig(filename string) (*AppConfig, error) {&#10;&#9;// Load .env file in development&#10;&#9;if os.Getenv(&quot;ENV&quot;) != &quot;production&quot; {&#10;&#9;&#9;err := godotenv.Load(filename)&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;// Don't fail if .env file doesn't exist&#10;&#9;&#9;&#9;fmt.Println(&quot;Warning: .env file not found, using system environment variables&quot;)&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;config := &amp;AppConfig{&#10;&#9;&#9;DBHost:     getEnv(&quot;DB_HOST&quot;, &quot;localhost&quot;),&#10;&#9;&#9;DBPort:     getEnv(&quot;DB_PORT&quot;, &quot;5432&quot;),&#10;&#9;&#9;DBUser:     getEnv(&quot;DB_USER&quot;, &quot;postgres&quot;),&#10;&#9;&#9;DBPassword: getEnv(&quot;DB_PASSWORD&quot;, &quot;&quot;),&#10;&#9;&#9;DBName:     getEnv(&quot;DB_NAME&quot;, &quot;go_store_identity&quot;),&#10;&#9;&#9;DBSSLMode:  getEnv(&quot;DB_SSL_MODE&quot;, &quot;disable&quot;),&#10;&#10;&#9;&#9;JWTSecret: getEnv(&quot;JWT_SECRET&quot;, &quot;&quot;),&#10;&#9;&#9;JWTExpire: getEnv(&quot;JWT_EXPIRATION&quot;, &quot;24h&quot;),&#10;&#10;&#9;&#9;ServerPort: getEnv(&quot;SERVER_PORT&quot;, &quot;8081&quot;),&#10;&#9;&#9;ServerHost: getEnv(&quot;SERVER_HOST&quot;, &quot;localhost&quot;),&#10;&#10;&#9;&#9;UserServiceURL: getEnv(&quot;USER_SERVICE_URL&quot;, &quot;http://localhost:8080&quot;),&#10;&#10;&#9;&#9;LogLevel: getEnv(&quot;LOG_LEVEL&quot;, &quot;info&quot;),&#10;&#10;&#9;&#9;RedisHost:     getEnv(&quot;REDIS_HOST&quot;, &quot;localhost&quot;),&#10;&#9;&#9;RedisPort:     getEnv(&quot;REDIS_PORT&quot;, &quot;6379&quot;),&#10;&#9;&#9;RedisPassword: getEnv(&quot;REDIS_PASSWORD&quot;, &quot;&quot;),&#10;&#10;&#9;&#9;Environment: getEnv(&quot;ENV&quot;, &quot;development&quot;),&#10;&#9;}&#10;&#10;&#9;return config, nil&#10;}&#10;&#10;func (c *AppConfig) GetDatabaseURL() string {&#10;&#9;return fmt.Sprintf(&quot;host=%s user=%s password=%s dbname=%s port=%s sslmode=%s TimeZone=Asia/Shanghai&quot;,&#10;&#9;&#9;c.DBHost, c.DBUser, c.DBPassword, c.DBName, c.DBPort, c.DBSSLMode)&#10;}&#10;&#10;func (c *AppConfig) GetServerAddress() string {&#10;&#9;return fmt.Sprintf(&quot;%s:%s&quot;, c.ServerHost, c.ServerPort)&#10;}&#10;&#10;func (c *AppConfig) IsProduction() bool {&#10;&#9;return c.Environment == &quot;production&quot;&#10;}&#10;&#10;// getEnv gets environment variable with fallback&#10;func getEnv(key, fallback string) string {&#10;&#9;if value := os.Getenv(key); value != &quot;&quot; {&#10;&#9;&#9;return value&#10;&#9;}&#10;&#9;return fallback&#10;}&#10;" />
              <option name="updatedContent" value="package config&#13;&#10;&#13;&#10;import (&#13;&#10;&#9;&quot;fmt&quot;&#13;&#10;&#9;&quot;github.com/hthinh24/go-store/internal/pkg/config&quot;&#13;&#10;&#9;&quot;time&quot;&#13;&#10;)&#13;&#10;&#13;&#10;type AppConfig struct {&#13;&#10;&#9;*config.Config&#13;&#10;}&#13;&#10;&#13;&#10;func LoadConfig(configPath string) (*AppConfig, error) {&#13;&#10;&#9;// Load shared configuration from pkg&#13;&#10;&#9;sharedConfig, err := config.LoadConfig(configPath)&#13;&#10;&#9;if err != nil {&#13;&#10;&#9;&#9;return nil, fmt.Errorf(&quot;error loading shared config: %w&quot;, err)&#13;&#10;&#9;}&#13;&#10;&#13;&#10;&#9;appConfig := &amp;AppConfig{&#13;&#10;&#9;&#9;Config: sharedConfig,&#13;&#10;&#9;}&#13;&#10;&#13;&#10;&#9;return appConfig, nil&#13;&#10;}&#13;&#10;&#13;&#10;// Legacy getter methods for backward compatibility&#13;&#10;func (c *AppConfig) GetDBHost() string {&#13;&#10;&#9;return c.PG.Host&#13;&#10;}&#13;&#10;&#13;&#10;func (c *AppConfig) GetDBPort() string {&#13;&#10;&#9;return c.PG.Port&#13;&#10;}&#13;&#10;&#13;&#10;func (c *AppConfig) GetDBUser() string {&#13;&#10;&#9;return c.PG.User&#13;&#10;}&#13;&#10;&#13;&#10;func (c *AppConfig) GetDBPassword() string {&#13;&#10;&#9;return c.PG.Password&#13;&#10;}&#13;&#10;&#13;&#10;func (c *AppConfig) GetDBName() string {&#13;&#10;&#9;return c.PG.Database&#13;&#10;}&#13;&#10;&#13;&#10;func (c *AppConfig) GetDBSSLMode() string {&#13;&#10;&#9;return c.PG.SSLMode&#13;&#10;}&#13;&#10;&#13;&#10;func (c *AppConfig) GetJWTSecret() string {&#13;&#10;&#9;return c.JWT.Secret&#13;&#10;}&#13;&#10;&#13;&#10;func (c *AppConfig) GetJWTExpire() string {&#13;&#10;&#9;return c.JWT.Expiration&#13;&#10;}&#13;&#10;&#13;&#10;func (c *AppConfig) GetJWTExpiresIn() time.Duration {&#13;&#10;&#9;duration, _ := time.ParseDuration(c.JWT.Expiration)&#13;&#10;&#9;return duration&#13;&#10;}&#13;&#10;&#13;&#10;func (c *AppConfig) GetServerPort() string {&#13;&#10;&#9;return c.App.Port&#13;&#10;}&#13;&#10;&#13;&#10;func (c *AppConfig) GetServerHost() string {&#13;&#10;&#9;return c.App.Host&#13;&#10;}&#13;&#10;&#13;&#10;func (c *AppConfig) GetUserServiceURL() string {&#13;&#10;&#9;return c.Services.GetServiceURL(&quot;identity&quot;)&#13;&#10;}&#13;&#10;&#13;&#10;func (c *AppConfig) GetLogLevel() string {&#13;&#10;&#9;return c.Log.Level&#13;&#10;}&#13;&#10;&#13;&#10;func (c *AppConfig) GetRedisHost() string {&#13;&#10;&#9;return c.Redis.Host&#13;&#10;}&#13;&#10;&#13;&#10;func (c *AppConfig) GetRedisPort() string {&#13;&#10;&#9;return c.Redis.Port&#13;&#10;}&#13;&#10;&#13;&#10;func (c *AppConfig) GetRedisPassword() string {&#13;&#10;&#9;return c.Redis.Password&#13;&#10;}&#13;&#10;&#13;&#10;func (c *AppConfig) GetEnvironment() string {&#13;&#10;&#9;return c.Environment&#13;&#10;}&#13;&#10;&#13;&#10;func (c *AppConfig) GetDatabaseURL() string {&#13;&#10;&#9;return fmt.Sprintf(&quot;host=%s user=%s password=%s dbname=%s port=%s sslmode=%s TimeZone=Asia/Shanghai&quot;,&#13;&#10;&#9;&#9;c.PG.Host, c.PG.User, c.PG.Password, c.PG.Database, c.PG.Port, c.PG.SSLMode)&#13;&#10;}&#13;&#10;&#13;&#10;func (c *AppConfig) GetServerAddress() string {&#13;&#10;&#9;return fmt.Sprintf(&quot;%s:%s&quot;, c.App.Host, c.App.Port)&#13;&#10;}&#13;&#10;&#13;&#10;func (c *AppConfig) IsProduction() bool {&#13;&#10;&#9;return c.Environment == &quot;production&quot;&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/internal/services/product/internal/infra/repository/postgres/product_repository.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/internal/services/product/internal/infra/repository/postgres/product_repository.go" />
              <option name="originalContent" value="package postgres&#10;&#10;import (&#10;&#9;&quot;strings&quot;&#10;&#10;&#9;&quot;github.com/hthinh24/go-store/internal/pkg/logger&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/services/product&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/services/product/internal/dto/repository&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/services/product/internal/entity&quot;&#10;&#9;productErrors &quot;github.com/hthinh24/go-store/services/product/internal/errors&quot;&#10;&#9;&quot;gorm.io/gorm&quot;&#10;)&#10;&#10;type productRepository struct {&#10;&#9;logger logger.Logger&#10;&#9;db     *gorm.DB&#10;}&#10;&#10;func NewProductRepository(logger logger.Logger, db *gorm.DB) *productRepository {&#10;&#9;return &amp;productRepository{&#10;&#9;&#9;logger: logger,&#10;&#9;&#9;db:     db,&#10;&#9;}&#10;}&#10;&#10;// Transaction methods&#10;func (p *productRepository) WithTransaction() (product.ProductRepository, error) {&#10;&#9;p.logger.Info(&quot;Creating transactional repository&quot;)&#10;&#10;&#9;tx := p.db.Begin()&#10;&#9;if tx.Error != nil {&#10;&#9;&#9;p.logger.Error(&quot;Failed to begin transaction:&quot;, tx.Error)&#10;&#9;&#9;return nil, tx.Error&#10;&#9;}&#10;&#10;&#9;return &amp;productRepository{&#10;&#9;&#9;logger: p.logger,&#10;&#9;&#9;db:     tx,&#10;&#9;}, nil&#10;}&#10;&#10;func (p *productRepository) Commit() error {&#10;&#9;p.logger.Info(&quot;Committing transaction&quot;)&#10;&#10;&#9;if err := p.db.Commit().Error; err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Failed to commit transaction:&quot;, err)&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;p.logger.Info(&quot;Transaction committed successfully&quot;)&#10;&#9;return nil&#10;}&#10;&#10;func (p *productRepository) Rollback() error {&#10;&#9;p.logger.Info(&quot;Rolling back transaction&quot;)&#10;&#10;&#9;if err := p.db.Rollback().Error; err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Failed to rollback transaction:&quot;, err)&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;p.logger.Info(&quot;Transaction rolled back successfully&quot;)&#10;&#9;return nil&#10;}&#10;&#10;func (p *productRepository) FindProductByID(id int64) (*entity.Product, error) {&#10;&#9;p.logger.Info(&quot;Finding product by ID:&quot;, id)&#10;&#10;&#9;var product entity.Product&#10;&#9;if err := p.db.Where(&quot;id = ?&quot;, id).First(&amp;product).Error; err != nil {&#10;&#9;&#9;return nil, productErrors.ErrProductNotFound{}&#10;&#9;}&#10;&#10;&#9;return &amp;product, nil&#10;}&#10;&#10;func (p *productRepository) FindProductAttributesInfoByProductID(productID int64) (*[]entity.ProductAttributeInfo, error) {&#10;&#9;p.logger.Info(&quot;Finding product attributes info by product ID:&quot;, productID)&#10;&#10;&#9;var productAttributesInfo []entity.ProductAttributeInfo&#10;&#9;if err := p.db.Where(&quot;product_id = ?&quot;, productID).Find(&amp;productAttributesInfo).Error; err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Failed to find product attributes info by product ID: &quot;, productID, &quot;, Error: &quot;, err)&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;p.logger.Info(&quot;Found product attributes info:&quot;, productAttributesInfo)&#10;&#9;return &amp;productAttributesInfo, nil&#10;}&#10;&#10;func (p *productRepository) FindProductOptionsInfoByProductID(productID int64) (*[]entity.ProductOptionInfo, error) {&#10;&#9;p.logger.Info(&quot;Finding product options info by product ID:&quot;, productID)&#10;&#10;&#9;var productOptionsInfo []entity.ProductOptionInfo&#10;&#9;if err := p.db.Where(&quot;product_id = ?&quot;, productID).Find(&amp;productOptionsInfo).Error; err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Failed to find product options info by product ID: &quot;, productID, &quot;, Error: &quot;, err)&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;p.logger.Info(&quot;Found product options info:&quot;, productOptionsInfo)&#10;&#9;return &amp;productOptionsInfo, nil&#10;}&#10;&#10;func (p *productRepository) FindProductSKUsByProductID(id int64) (*[]repository.ProductSKUDetail, error) {&#10;&#9;p.logger.Info(&quot;Finding product SKUs by product ID:&quot;, id)&#10;&#10;&#9;var productSKUsWithInventory []repository.ProductSKUDetail&#10;&#9;if err := p.db.&#10;&#9;&#9;Table(entity.ProductSKU{}.TableName()+&quot; AS ps&quot;).&#10;&#9;&#9;Select(&quot;ps.id, ps.sku, ps.sku_signature, ps.extra_price, &quot;+&#10;&#9;&#9;&#9;&quot;ps.sale_type, ps.sale_value, ps.sale_start_date, &quot;+&#10;&#9;&#9;&#9;&quot;ps.sale_end_date, ps.status, ps.product_id, pi.available_stock as stock&quot;).&#10;&#9;&#9;Joins(&quot;JOIN product_inventory AS pi ON ps.id = pi.product_sku_id&quot;).&#10;&#9;&#9;Where(&quot;ps.product_id = ?&quot;, id).&#10;&#9;&#9;Find(&amp;productSKUsWithInventory).Error; err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Failed to find product SKUs by product ID: &quot;, id, &quot;, Error: &quot;, err)&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;return &amp;productSKUsWithInventory, nil&#10;}&#10;&#10;func (p *productRepository) FindProductSKUByID(skuID int64) (*repository.ProductSKUDetail, error) {&#10;&#9;p.logger.Info(&quot;Finding product SKU by ID:&quot;, skuID)&#10;&#10;&#9;var productSKU repository.ProductSKUDetail&#10;&#9;if err := p.db.&#10;&#9;&#9;Table(entity.ProductSKU{}.TableName()+&quot; AS ps&quot;).&#10;&#9;&#9;Select(&quot;ps.id, ps.sku, ps.sku_signature, ps.extra_price, &quot;+&#10;&#9;&#9;&#9;&quot;ps.sale_type, ps.sale_value, ps.sale_start_date, &quot;+&#10;&#9;&#9;&#9;&quot;ps.sale_end_date, ps.status, ps.product_id, pi.available_stock as stock&quot;).&#10;&#9;&#9;Joins(&quot;JOIN product_inventory AS pi ON ps.id = pi.product_sku_id&quot;).&#10;&#9;&#9;Where(&quot;ps.id = ?&quot;, skuID).&#10;&#9;&#9;First(&amp;productSKU).Error; err != nil {&#10;&#9;&#9;if err == gorm.ErrRecordNotFound {&#10;&#9;&#9;&#9;p.logger.Error(&quot;Product SKU not found with ID:&quot;, skuID)&#10;&#9;&#9;&#9;return nil, productErrors.ErrProductSKUNotFound{}&#10;&#9;&#9;}&#10;&#9;&#9;p.logger.Error(&quot;Failed to find product SKU by ID: &quot;, skuID, &quot;, Error: &quot;, err)&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;p.logger.Info(&quot;Found product SKU with ID: &quot;, productSKU.ID, &quot;, SKU: &quot;, productSKU.SKU, &quot;, Status: &quot;, productSKU.Status)&#10;&#9;return &amp;productSKU, nil&#10;}&#10;&#10;func (p *productRepository) FindProductAttributesByIDs(productAttributeIDs []int64) (*[]entity.ProductAttribute, error) {&#10;&#9;p.logger.Info(&quot;Finding product attributes by IDs:&quot;, productAttributeIDs)&#10;&#10;&#9;var productAttributes []entity.ProductAttribute&#10;&#9;if err := p.db.Where(&quot;id IN ?&quot;, productAttributeIDs).Find(&amp;productAttributes).Error; err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Failed to find product attributes by IDs: &quot;, productAttributeIDs, &quot;, Error: &quot;, err)&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;p.logger.Info(&quot;Found product attributes:&quot;, productAttributes)&#10;&#9;return &amp;productAttributes, nil&#10;}&#10;&#10;func (p *productRepository) FindProductOptionsByIDs(productOptionIDs []int64) (*[]entity.ProductOption, error) {&#10;&#9;p.logger.Info(&quot;Finding product options by IDs:&quot;, productOptionIDs)&#10;&#10;&#9;var productOptions []entity.ProductOption&#10;&#9;if err := p.db.Where(&quot;id IN ?&quot;, productOptionIDs).Find(&amp;productOptions).Error; err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Failed to find product options by IDs: &quot;, productOptionIDs, &quot;, Error: &quot;, err)&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;p.logger.Info(&quot;Found product options:&quot;, productOptions)&#10;&#9;return &amp;productOptions, nil&#10;}&#10;&#10;func (p *productRepository) CreateProduct(product *entity.Product) error {&#10;&#9;p.logger.Info(&quot;Creating product:&quot;, product)&#10;&#10;&#9;if err := p.db.Create(product).Error; err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Failed to create product: &quot;, product, &quot;, Error: &quot;, err)&#10;&#10;&#9;&#9;// Check for specific database constraint violations&#10;&#9;&#9;errMsg := strings.ToLower(err.Error())&#10;&#10;&#9;&#9;// Check for duplicate slug constraint&#10;&#9;&#9;if strings.Contains(errMsg, &quot;duplicate&quot;) &amp;&amp; strings.Contains(errMsg, &quot;slug&quot;) {&#10;&#9;&#9;&#9;return productErrors.ErrProductAlreadyExists{Slug: product.Slug}&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// Check for duplicate name constraint&#10;&#9;&#9;if strings.Contains(errMsg, &quot;duplicate&quot;) &amp;&amp; strings.Contains(errMsg, &quot;name&quot;) {&#10;&#9;&#9;&#9;return productErrors.ErrProductAlreadyExists{Name: product.Name}&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// Check for foreign key violations&#10;&#9;&#9;if strings.Contains(errMsg, &quot;foreign key&quot;) {&#10;&#9;&#9;&#9;if strings.Contains(errMsg, &quot;category&quot;) {&#10;&#9;&#9;&#9;&#9;return productErrors.ErrCategoryNotFound{ID: product.CategoryID}&#10;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;if strings.Contains(errMsg, &quot;brand&quot;) {&#10;&#9;&#9;&#9;&#9;return productErrors.ErrBrandNotFound{ID: product.BrandID}&#10;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;if strings.Contains(errMsg, &quot;user&quot;) {&#10;&#9;&#9;&#9;&#9;return productErrors.ErrUserNotFound{ID: product.UserID}&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// Check for check constraint violations&#10;&#9;&#9;if strings.Contains(errMsg, &quot;check&quot;) || strings.Contains(errMsg, &quot;constraint&quot;) {&#10;&#9;&#9;&#9;if strings.Contains(errMsg, &quot;price&quot;) {&#10;&#9;&#9;&#9;&#9;return productErrors.ErrInvalidProductData{Field: &quot;price&quot;, Message: &quot;price must be greater than 0&quot;}&#10;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;if strings.Contains(errMsg, &quot;status&quot;) {&#10;&#9;&#9;&#9;&#9;return productErrors.ErrInvalidProductData{Field: &quot;status&quot;, Message: &quot;invalid status value&quot;}&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// Generic database transaction error&#10;&#9;&#9;return productErrors.ErrDatabaseTransaction{Operation: &quot;create product&quot;}&#10;&#9;}&#10;&#10;&#9;p.logger.Info(&quot;Product created successfully:&quot;, product.ID)&#10;&#9;return nil&#10;}&#10;&#10;func (p *productRepository) CreateProductAttributeInfo(productAttributeInfos *[]entity.ProductAttributeInfo) error {&#10;&#9;p.logger.Info(&quot;Creating product attribute infos:&quot;, productAttributeInfos)&#10;&#10;&#9;if err := p.db.Create(productAttributeInfos).Error; err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Failed to create product attribute infos: &quot;, productAttributeInfos, &quot;, Error: &quot;, err)&#10;&#10;&#9;&#9;errMsg := strings.ToLower(err.Error())&#10;&#10;&#9;&#9;// Check for foreign key violations&#10;&#9;&#9;if strings.Contains(errMsg, &quot;foreign key&quot;) {&#10;&#9;&#9;&#9;if strings.Contains(errMsg, &quot;product_attribute&quot;) {&#10;&#9;&#9;&#9;&#9;return productErrors.ErrAttributeNotFound{ID: 0} // We'd need to parse which specific ID failed&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#10;&#9;&#9;return productErrors.ErrDatabaseTransaction{Operation: &quot;create product attribute info&quot;}&#10;&#9;}&#10;&#10;&#9;p.logger.Info(&quot;Product attribute infos created successfully&quot;)&#10;&#9;return nil&#10;}&#10;&#10;func (p *productRepository) CreateProductOptionInfo(productOptionInfos *[]entity.ProductOptionInfo) error {&#10;&#9;p.logger.Info(&quot;Creating product option infos:&quot;, productOptionInfos)&#10;&#10;&#9;if err := p.db.Create(productOptionInfos).Error; err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Failed to create product option infos: &quot;, productOptionInfos, &quot;, Error: &quot;, err)&#10;&#10;&#9;&#9;errMsg := strings.ToLower(err.Error())&#10;&#10;&#9;&#9;// Check for foreign key violations&#10;&#9;&#9;if strings.Contains(errMsg, &quot;foreign key&quot;) {&#10;&#9;&#9;&#9;if strings.Contains(errMsg, &quot;product_option&quot;) {&#10;&#9;&#9;&#9;&#9;return productErrors.ErrOptionNotFound{ID: 0} // We'd need to parse which specific ID failed&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#10;&#9;&#9;return productErrors.ErrDatabaseTransaction{Operation: &quot;create product option info&quot;}&#10;&#9;}&#10;&#10;&#9;p.logger.Info(&quot;Product option infos created successfully&quot;)&#10;&#9;return nil&#10;}&#10;&#10;func (p *productRepository) CreateProductAttributeValuesIfNotExist(productAttributeValues *[]entity.ProductAttributeValue) error {&#10;&#9;p.logger.Info(&quot;Creating product attribute values&quot;)&#10;&#10;&#9;for _, value := range *productAttributeValues {&#10;&#9;&#9;if err := p.db.Where(&quot;value = ?&quot;, value.Value).FirstOrCreate(&amp;value).Error; err != nil {&#10;&#9;&#9;&#9;p.logger.Error(&quot;Failed to create or find product attribute value:&quot;, value, &quot;Error:&quot;, err)&#10;&#9;&#9;&#9;return err&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;p.logger.Info(&quot;Product attribute values created successfully&quot;)&#10;&#9;return nil&#10;}&#10;&#10;func (p *productRepository) CreateProductProductAttributeValues(i *[]entity.ProductProductAttributeValue) error {&#10;&#9;p.logger.Info(&quot;Creating product product attribute values:&quot;, i)&#10;&#10;&#9;if err := p.db.Create(i).Error; err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Failed to create product product attribute values:&quot;, i, &quot;Error:&quot;, err)&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;p.logger.Info(&quot;Product product attribute values created successfully&quot;)&#10;&#9;return nil&#10;}&#10;&#10;func (p *productRepository) CreateProductSKUs(productSKUs *[]entity.ProductSKU) error {&#10;&#9;p.logger.Info(&quot;Creating product SKUs:&quot;, productSKUs)&#10;&#10;&#9;if err := p.db.Create(productSKUs).Error; err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Failed to create product SKUs:&quot;, productSKUs, &quot;Error:&quot;, err)&#10;&#10;&#9;&#9;errMsg := strings.ToLower(err.Error())&#10;&#10;&#9;&#9;// Check for duplicate SKU constraint&#10;&#9;&#9;if strings.Contains(errMsg, &quot;duplicate&quot;) &amp;&amp; strings.Contains(errMsg, &quot;sku&quot;) {&#10;&#9;&#9;&#9;// Extract SKU from productSKUs if possible&#10;&#9;&#9;&#9;if len(*productSKUs) &gt; 0 {&#10;&#9;&#9;&#9;&#9;return productErrors.ErrSKUAlreadyExists{SKU: (*productSKUs)[0].SKU}&#10;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;return productErrors.ErrSKUAlreadyExists{SKU: &quot;unknown&quot;}&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// Check for invalid price&#10;&#9;&#9;if strings.Contains(errMsg, &quot;check&quot;) &amp;&amp; strings.Contains(errMsg, &quot;price&quot;) {&#10;&#9;&#9;&#9;return productErrors.ErrInvalidSKUData{SKU: &quot;unknown&quot;, Message: &quot;price must be greater than or equal to 0&quot;}&#10;&#9;&#9;}&#10;&#10;&#9;&#9;return productErrors.ErrDatabaseTransaction{Operation: &quot;create product SKUs&quot;}&#10;&#9;}&#10;&#10;&#9;p.logger.Info(&quot;Product SKUs created successfully&quot;)&#10;&#9;return nil&#10;}&#10;&#10;func (p *productRepository) CreateProductInventories(inventories *[]entity.ProductInventory) error {&#10;&#9;p.logger.Info(&quot;Creating product inventories:&quot;, inventories)&#10;&#10;&#9;if err := p.db.Create(inventories).Error; err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Failed to create product inventories:&quot;, inventories, &quot;Error:&quot;, err)&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;p.logger.Info(&quot;Product inventories created successfully&quot;)&#10;&#9;return nil&#10;}&#10;&#10;func (p *productRepository) CreateProductOptionCombinations(productOptionCombinations *[]entity.ProductOptionCombination) error {&#10;&#9;p.logger.Info(&quot;Creating product option combinations:&quot;, productOptionCombinations)&#10;&#10;&#9;if err := p.db.Create(productOptionCombinations).Error; err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Failed to create product option combinations:&quot;, productOptionCombinations, &quot;Error:&quot;, err)&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;p.logger.Info(&quot;Product option combinations created successfully&quot;)&#10;&#9;return nil&#10;}&#10;&#10;func (p *productRepository) CreateProductOptionValuesIfNotExist(productOptionValues *[]entity.ProductOptionValue) error {&#10;&#9;p.logger.Info(&quot;Creating product option values if not exist:&quot;, productOptionValues)&#10;&#10;&#9;for _, value := range *productOptionValues {&#10;&#9;&#9;if err := p.db.Where(&quot;value = ?&quot;, value.Value).FirstOrCreate(&amp;value).Error; err != nil {&#10;&#9;&#9;&#9;p.logger.Error(&quot;Failed to create or find product option value:&quot;, value, &quot;Error:&quot;, err)&#10;&#9;&#9;&#9;return err&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;p.logger.Info(&quot;Product option values created or found successfully&quot;)&#10;&#9;return nil&#10;}&#10;&#10;func (p *productRepository) DeleteProduct(id int64) error {&#10;&#9;p.logger.Info(&quot;Deleting product with ID:&quot;, id)&#10;&#10;&#9;if err := p.db.Where(&quot;id = ?&quot;, id).Delete(&amp;entity.Product{}).Error; err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Failed to delete product with ID:&quot;, id, &quot;Error:&quot;, err)&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;p.logger.Info(&quot;Product deleted successfully:&quot;, id)&#10;&#9;return nil&#10;}&#10;" />
              <option name="updatedContent" value="package postgres&#10;&#10;import (&#10;&#9;&quot;strings&quot;&#10;&#10;&#9;&quot;github.com/hthinh24/go-store/internal/pkg/logger&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/services/product&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/services/product/internal/dto/repository&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/services/product/internal/entity&quot;&#10;&#9;productErrors &quot;github.com/hthinh24/go-store/services/product/internal/errors&quot;&#10;&#9;&quot;gorm.io/gorm&quot;&#10;)&#10;&#10;type productRepository struct {&#10;&#9;logger logger.Logger&#10;&#9;db     *gorm.DB&#10;}&#10;&#10;func NewProductRepository(logger logger.Logger, db *gorm.DB) *productRepository {&#10;&#9;return &amp;productRepository{&#10;&#9;&#9;logger: logger,&#10;&#9;&#9;db:     db,&#10;&#9;}&#10;}&#10;&#10;// Transaction methods&#10;func (p *productRepository) WithTransaction() (product.ProductRepository, error) {&#10;&#9;p.logger.Info(&quot;Creating transactional repository&quot;)&#10;&#10;&#9;tx := p.db.Begin()&#10;&#9;if tx.Error != nil {&#10;&#9;&#9;p.logger.Error(&quot;Failed to begin transaction:&quot;, tx.Error)&#10;&#9;&#9;return nil, tx.Error&#10;&#9;}&#10;&#10;&#9;return &amp;productRepository{&#10;&#9;&#9;logger: p.logger,&#10;&#9;&#9;db:     tx,&#10;&#9;}, nil&#10;}&#10;&#10;func (p *productRepository) Commit() error {&#10;&#9;p.logger.Info(&quot;Committing transaction&quot;)&#10;&#10;&#9;if err := p.db.Commit().Error; err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Failed to commit transaction:&quot;, err)&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;p.logger.Info(&quot;Transaction committed successfully&quot;)&#10;&#9;return nil&#10;}&#10;&#10;func (p *productRepository) Rollback() error {&#10;&#9;p.logger.Info(&quot;Rolling back transaction&quot;)&#10;&#10;&#9;if err := p.db.Rollback().Error; err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Failed to rollback transaction:&quot;, err)&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;p.logger.Info(&quot;Transaction rolled back successfully&quot;)&#10;&#9;return nil&#10;}&#10;&#10;func (p *productRepository) FindProductByID(id int64) (*entity.Product, error) {&#10;&#9;p.logger.Info(&quot;Finding product by ID: &quot;, id)&#10;&#10;&#9;var product entity.Product&#10;&#9;if err := p.db.Where(&quot;id = ?&quot;, id).First(&amp;product).Error; err != nil {&#10;&#9;&#9;return nil, productErrors.ErrProductNotFound{}&#10;&#9;}&#10;&#10;&#9;return &amp;product, nil&#10;}&#10;&#10;func (p *productRepository) FindProductAttributesInfoByProductID(productID int64) (*[]entity.ProductAttributeInfo, error) {&#10;&#9;p.logger.Info(&quot;Finding product attributes info by product ID: &quot;, productID)&#10;&#10;&#9;var productAttributesInfo []entity.ProductAttributeInfo&#10;&#9;if err := p.db.Where(&quot;product_id = ?&quot;, productID).Find(&amp;productAttributesInfo).Error; err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Failed to find product attributes info by product ID: &quot;, productID, &quot;, Error: &quot;, err)&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;p.logger.Info(&quot;Found product attributes info: &quot;, productAttributesInfo)&#10;&#9;return &amp;productAttributesInfo, nil&#10;}&#10;&#10;func (p *productRepository) FindProductOptionsInfoByProductID(productID int64) (*[]entity.ProductOptionInfo, error) {&#10;&#9;p.logger.Info(&quot;Finding product options info by product ID: &quot;, productID)&#10;&#10;&#9;var productOptionsInfo []entity.ProductOptionInfo&#10;&#9;if err := p.db.Where(&quot;product_id = ?&quot;, productID).Find(&amp;productOptionsInfo).Error; err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Failed to find product options info by product ID: &quot;, productID, &quot;, Error: &quot;, err)&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;p.logger.Info(&quot;Found product options info: &quot;, productOptionsInfo)&#10;&#9;return &amp;productOptionsInfo, nil&#10;}&#10;&#10;func (p *productRepository) FindProductSKUsByProductID(id int64) (*[]repository.ProductSKUDetail, error) {&#10;&#9;p.logger.Info(&quot;Finding product SKUs by product ID: &quot;, id)&#10;&#10;&#9;var productSKUsWithInventory []repository.ProductSKUDetail&#10;&#9;if err := p.db.&#10;&#9;&#9;Table(entity.ProductSKU{}.TableName()+&quot; AS ps&quot;).&#10;&#9;&#9;Select(&quot;ps.id, ps.sku, ps.sku_signature, ps.extra_price, &quot;+&#10;&#9;&#9;&#9;&quot;ps.sale_type, ps.sale_value, ps.sale_start_date, &quot;+&#10;&#9;&#9;&#9;&quot;ps.sale_end_date, ps.status, ps.product_id, pi.available_stock as stock&quot;).&#10;&#9;&#9;Joins(&quot;JOIN product_inventory AS pi ON ps.id = pi.product_sku_id&quot;).&#10;&#9;&#9;Where(&quot;ps.product_id = ?&quot;, id).&#10;&#9;&#9;Find(&amp;productSKUsWithInventory).Error; err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Failed to find product SKUs by product ID: &quot;, id, &quot;, Error: &quot;, err)&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;return &amp;productSKUsWithInventory, nil&#10;}&#10;&#10;func (p *productRepository) FindProductSKUByID(skuID int64) (*repository.ProductSKUDetail, error) {&#10;&#9;p.logger.Info(&quot;Finding product SKU by ID: &quot;, skuID)&#10;&#10;&#9;var productSKU repository.ProductSKUDetail&#10;&#9;if err := p.db.&#10;&#9;&#9;Table(entity.ProductSKU{}.TableName()+&quot; AS ps&quot;).&#10;&#9;&#9;Select(&quot;ps.id, ps.sku, ps.sku_signature, ps.extra_price, &quot;+&#10;&#9;&#9;&#9;&quot;ps.sale_type, ps.sale_value, ps.sale_start_date, &quot;+&#10;&#9;&#9;&#9;&quot;ps.sale_end_date, ps.status, ps.product_id, pi.available_stock as stock&quot;).&#10;&#9;&#9;Joins(&quot;JOIN product_inventory AS pi ON ps.id = pi.product_sku_id&quot;).&#10;&#9;&#9;Where(&quot;ps.id = ?&quot;, skuID).&#10;&#9;&#9;First(&amp;productSKU).Error; err != nil {&#10;&#9;&#9;if err == gorm.ErrRecordNotFound {&#10;&#9;&#9;&#9;p.logger.Error(&quot;Product SKU not found with ID: &quot;, skuID)&#10;&#9;&#9;&#9;return nil, productErrors.ErrProductSKUNotFound{}&#10;&#9;&#9;}&#10;&#9;&#9;p.logger.Error(&quot;Failed to find product SKU by ID: &quot;, skuID, &quot;, Error: &quot;, err)&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;p.logger.Info(&quot;Found product SKU with ID: &quot;, productSKU.ID, &quot;, SKU: &quot;, productSKU.SKU, &quot;, Status: &quot;, productSKU.Status)&#10;&#9;return &amp;productSKU, nil&#10;}&#10;&#10;func (p *productRepository) FindProductAttributesByIDs(productAttributeIDs []int64) (*[]entity.ProductAttribute, error) {&#10;&#9;p.logger.Info(&quot;Finding product attributes by IDs: &quot;, productAttributeIDs)&#10;&#10;&#9;var productAttributes []entity.ProductAttribute&#10;&#9;if err := p.db.Where(&quot;id IN ?&quot;, productAttributeIDs).Find(&amp;productAttributes).Error; err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Failed to find product attributes by IDs: &quot;, productAttributeIDs, &quot;, Error: &quot;, err)&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;p.logger.Info(&quot;Found product attributes: &quot;, productAttributes)&#10;&#9;return &amp;productAttributes, nil&#10;}&#10;&#10;func (p *productRepository) FindProductOptionsByIDs(productOptionIDs []int64) (*[]entity.ProductOption, error) {&#10;&#9;p.logger.Info(&quot;Finding product options by IDs: &quot;, productOptionIDs)&#10;&#10;&#9;var productOptions []entity.ProductOption&#10;&#9;if err := p.db.Where(&quot;id IN ?&quot;, productOptionIDs).Find(&amp;productOptions).Error; err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Failed to find product options by IDs: &quot;, productOptionIDs, &quot;, Error: &quot;, err)&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;p.logger.Info(&quot;Found product options: &quot;, productOptions)&#10;&#9;return &amp;productOptions, nil&#10;}&#10;&#10;func (p *productRepository) CreateProduct(product *entity.Product) error {&#10;&#9;p.logger.Info(&quot;Creating product: &quot;, product)&#10;&#10;&#9;if err := p.db.Create(product).Error; err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Failed to create product: &quot;, product, &quot;, Error: &quot;, err)&#10;&#10;&#9;&#9;// Check for specific database constraint violations&#10;&#9;&#9;errMsg := strings.ToLower(err.Error())&#10;&#10;&#9;&#9;// Check for duplicate slug constraint&#10;&#9;&#9;if strings.Contains(errMsg, &quot;duplicate&quot;) &amp;&amp; strings.Contains(errMsg, &quot;slug&quot;) {&#10;&#9;&#9;&#9;return productErrors.ErrProductAlreadyExists{Slug: product.Slug}&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// Check for duplicate name constraint&#10;&#9;&#9;if strings.Contains(errMsg, &quot;duplicate&quot;) &amp;&amp; strings.Contains(errMsg, &quot;name&quot;) {&#10;&#9;&#9;&#9;return productErrors.ErrProductAlreadyExists{Name: product.Name}&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// Check for foreign key violations&#10;&#9;&#9;if strings.Contains(errMsg, &quot;foreign key&quot;) {&#10;&#9;&#9;&#9;if strings.Contains(errMsg, &quot;category&quot;) {&#10;&#9;&#9;&#9;&#9;return productErrors.ErrCategoryNotFound{ID: product.CategoryID}&#10;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;if strings.Contains(errMsg, &quot;brand&quot;) {&#10;&#9;&#9;&#9;&#9;return productErrors.ErrBrandNotFound{ID: product.BrandID}&#10;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;if strings.Contains(errMsg, &quot;user&quot;) {&#10;&#9;&#9;&#9;&#9;return productErrors.ErrUserNotFound{ID: product.UserID}&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// Check for check constraint violations&#10;&#9;&#9;if strings.Contains(errMsg, &quot;check&quot;) || strings.Contains(errMsg, &quot;constraint&quot;) {&#10;&#9;&#9;&#9;if strings.Contains(errMsg, &quot;price&quot;) {&#10;&#9;&#9;&#9;&#9;return productErrors.ErrInvalidProductData{Field: &quot;price&quot;, Message: &quot;price must be greater than 0&quot;}&#10;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;if strings.Contains(errMsg, &quot;status&quot;) {&#10;&#9;&#9;&#9;&#9;return productErrors.ErrInvalidProductData{Field: &quot;status&quot;, Message: &quot;invalid status value&quot;}&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// Generic database transaction error&#10;&#9;&#9;return productErrors.ErrDatabaseTransaction{Operation: &quot;create product&quot;}&#10;&#9;}&#10;&#10;&#9;p.logger.Info(&quot;Product created successfully: &quot;, product.ID)&#10;&#9;return nil&#10;}&#10;&#10;func (p *productRepository) CreateProductAttributeInfo(productAttributeInfos *[]entity.ProductAttributeInfo) error {&#10;&#9;p.logger.Info(&quot;Creating product attribute infos: &quot;, productAttributeInfos)&#10;&#10;&#9;if err := p.db.Create(productAttributeInfos).Error; err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Failed to create product attribute infos: &quot;, productAttributeInfos, &quot;, Error: &quot;, err)&#10;&#10;&#9;&#9;errMsg := strings.ToLower(err.Error())&#10;&#10;&#9;&#9;// Check for foreign key violations&#10;&#9;&#9;if strings.Contains(errMsg, &quot;foreign key&quot;) {&#10;&#9;&#9;&#9;if strings.Contains(errMsg, &quot;product_attribute&quot;) {&#10;&#9;&#9;&#9;&#9;return productErrors.ErrAttributeNotFound{ID: 0} // We'd need to parse which specific ID failed&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#10;&#9;&#9;return productErrors.ErrDatabaseTransaction{Operation: &quot;create product attribute info&quot;}&#10;&#9;}&#10;&#10;&#9;p.logger.Info(&quot;Product attribute infos created successfully&quot;)&#10;&#9;return nil&#10;}&#10;&#10;func (p *productRepository) CreateProductOptionInfo(productOptionInfos *[]entity.ProductOptionInfo) error {&#10;&#9;p.logger.Info(&quot;Creating product option infos: &quot;, productOptionInfos)&#10;&#10;&#9;if err := p.db.Create(productOptionInfos).Error; err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Failed to create product option infos: &quot;, productOptionInfos, &quot;, Error: &quot;, err)&#10;&#10;&#9;&#9;errMsg := strings.ToLower(err.Error())&#10;&#10;&#9;&#9;// Check for foreign key violations&#10;&#9;&#9;if strings.Contains(errMsg, &quot;foreign key&quot;) {&#10;&#9;&#9;&#9;if strings.Contains(errMsg, &quot;product_option&quot;) {&#10;&#9;&#9;&#9;&#9;return productErrors.ErrOptionNotFound{ID: 0} // We'd need to parse which specific ID failed&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#10;&#9;&#9;return productErrors.ErrDatabaseTransaction{Operation: &quot;create product option info&quot;}&#10;&#9;}&#10;&#10;&#9;p.logger.Info(&quot;Product option infos created successfully&quot;)&#10;&#9;return nil&#10;}&#10;&#10;func (p *productRepository) CreateProductAttributeValuesIfNotExist(productAttributeValues *[]entity.ProductAttributeValue) error {&#10;&#9;p.logger.Info(&quot;Creating product attribute values&quot;)&#10;&#10;&#9;for _, value := range *productAttributeValues {&#10;&#9;&#9;if err := p.db.Where(&quot;value = ?&quot;, value.Value).FirstOrCreate(&amp;value).Error; err != nil {&#10;&#9;&#9;&#9;p.logger.Error(&quot;Failed to create or find product attribute value: &quot;, value, &quot;, Error: &quot;, err)&#10;&#9;&#9;&#9;return err&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;p.logger.Info(&quot;Product attribute values created successfully&quot;)&#10;&#9;return nil&#10;}&#10;&#10;func (p *productRepository) CreateProductProductAttributeValues(i *[]entity.ProductProductAttributeValue) error {&#10;&#9;p.logger.Info(&quot;Creating product product attribute values: &quot;, i)&#10;&#10;&#9;if err := p.db.Create(i).Error; err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Failed to create product product attribute values: &quot;, i, &quot;, Error: &quot;, err)&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;p.logger.Info(&quot;Product product attribute values created successfully&quot;)&#10;&#9;return nil&#10;}&#10;&#10;func (p *productRepository) CreateProductSKUs(productSKUs *[]entity.ProductSKU) error {&#10;&#9;p.logger.Info(&quot;Creating product SKUs: &quot;, productSKUs)&#10;&#10;&#9;if err := p.db.Create(productSKUs).Error; err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Failed to create product SKUs: &quot;, productSKUs, &quot;, Error: &quot;, err)&#10;&#10;&#9;&#9;errMsg := strings.ToLower(err.Error())&#10;&#10;&#9;&#9;// Check for duplicate SKU constraint&#10;&#9;&#9;if strings.Contains(errMsg, &quot;duplicate&quot;) &amp;&amp; strings.Contains(errMsg, &quot;sku&quot;) {&#10;&#9;&#9;&#9;// Extract SKU from productSKUs if possible&#10;&#9;&#9;&#9;if len(*productSKUs) &gt; 0 {&#10;&#9;&#9;&#9;&#9;return productErrors.ErrSKUAlreadyExists{SKU: (*productSKUs)[0].SKU}&#10;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;return productErrors.ErrSKUAlreadyExists{SKU: &quot;unknown&quot;}&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// Check for invalid price&#10;&#9;&#9;if strings.Contains(errMsg, &quot;check&quot;) &amp;&amp; strings.Contains(errMsg, &quot;price&quot;) {&#10;&#9;&#9;&#9;return productErrors.ErrInvalidSKUData{SKU: &quot;unknown&quot;, Message: &quot;price must be greater than or equal to 0&quot;}&#10;&#9;&#9;}&#10;&#10;&#9;&#9;return productErrors.ErrDatabaseTransaction{Operation: &quot;create product SKUs&quot;}&#10;&#9;}&#10;&#10;&#9;p.logger.Info(&quot;Product SKUs created successfully&quot;)&#10;&#9;return nil&#10;}&#10;&#10;func (p *productRepository) CreateProductInventories(inventories *[]entity.ProductInventory) error {&#10;&#9;p.logger.Info(&quot;Creating product inventories: &quot;, inventories)&#10;&#10;&#9;if err := p.db.Create(inventories).Error; err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Failed to create product inventories: &quot;, inventories, &quot;, Error: &quot;, err)&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;p.logger.Info(&quot;Product inventories created successfully&quot;)&#10;&#9;return nil&#10;}&#10;&#10;func (p *productRepository) CreateProductOptionCombinations(productOptionCombinations *[]entity.ProductOptionCombination) error {&#10;&#9;p.logger.Info(&quot;Creating product option combinations: &quot;, productOptionCombinations)&#10;&#10;&#9;if err := p.db.Create(productOptionCombinations).Error; err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Failed to create product option combinations: &quot;, productOptionCombinations, &quot;, Error: &quot;, err)&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;p.logger.Info(&quot;Product option combinations created successfully&quot;)&#10;&#9;return nil&#10;}&#10;&#10;func (p *productRepository) CreateProductOptionValuesIfNotExist(productOptionValues *[]entity.ProductOptionValue) error {&#10;&#9;p.logger.Info(&quot;Creating product option values if not exist: &quot;, productOptionValues)&#10;&#10;&#9;for _, value := range *productOptionValues {&#10;&#9;&#9;if err := p.db.Where(&quot;value = ?&quot;, value.Value).FirstOrCreate(&amp;value).Error; err != nil {&#10;&#9;&#9;&#9;p.logger.Error(&quot;Failed to create or find product option value: &quot;, value, &quot;, Error: &quot;, err)&#10;&#9;&#9;&#9;return err&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;p.logger.Info(&quot;Product option values created or found successfully&quot;)&#10;&#9;return nil&#10;}&#10;&#10;func (p *productRepository) DeleteProduct(id int64) error {&#10;&#9;p.logger.Info(&quot;Deleting product with ID: &quot;, id)&#10;&#10;&#9;if err := p.db.Where(&quot;id = ?&quot;, id).Delete(&amp;entity.Product{}).Error; err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Failed to delete product with ID: &quot;, id, &quot;, Error: &quot;, err)&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;p.logger.Info(&quot;Product deleted successfully: &quot;, id)&#10;&#9;return nil&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/internal/services/product/internal/service/product_service.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/internal/services/product/internal/service/product_service.go" />
              <option name="originalContent" value="package service&#10;&#10;import (&#10;&#9;&quot;github.com/hthinh24/go-store/internal/pkg/logger&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/services/product&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/services/product/internal/constants&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/services/product/internal/dto/repository&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/services/product/internal/dto/request&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/services/product/internal/dto/response&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/services/product/internal/entity&quot;&#10;&#9;&quot;strings&quot;&#10;)&#10;&#10;type productService struct {&#10;&#9;logger            logger.Logger&#10;&#9;productRepository product.ProductRepository&#10;}&#10;&#10;// NewProductService creates a new instance of ProductService&#10;func NewProductService(logger logger.Logger, productRepository product.ProductRepository) product.ProductService {&#10;&#9;return &amp;productService{&#10;&#9;&#9;logger:            logger,&#10;&#9;&#9;productRepository: productRepository,&#10;&#9;}&#10;}&#10;&#10;func (p *productService) GetProductByID(id int64) (*response.ProductResponse, error) {&#10;&#9;p.logger.Info(&quot;Get product with ID: &quot;, id)&#10;&#10;&#9;productEntity, err := p.productRepository.FindProductByID(id)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;p.logger.Info(&quot;Product retrieved successfully, ID: &quot;, productEntity.ID)&#10;&#9;return p.createProductResponse(productEntity), nil&#10;}&#10;&#10;func (p *productService) GetProductDetailByID(id int64) (*response.ProductDetailResponse, error) {&#10;&#9;p.logger.Info(&quot;Get product with ID: &quot;, id)&#10;&#10;&#9;productEntity, err := p.productRepository.FindProductByID(id)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;p.logger.Info(&quot;Product retrieved successfully, ID: &quot;, productEntity.ID)&#10;&#9;return p.createProductDetailResponse(productEntity), nil&#10;}&#10;&#10;func (p *productService) GetProductSKUByID(skuID int64) (*response.ProductSKUDetailResponse, error) {&#10;&#9;p.logger.Info(&quot;Get product SKU with ID: &quot;, skuID)&#10;&#10;&#9;productSKUEntity, err := p.productRepository.FindProductSKUByID(skuID)&#10;&#9;if err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Error retrieving product SKU with ID: &quot;, skuID, &quot;, Error: &quot;, err)&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;product, err := p.productRepository.FindProductByID(productSKUEntity.ProductID)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;p.logger.Info(&quot;Product SKU retrieved successfully, ID: &quot;, productSKUEntity.ID)&#10;&#9;return p.createProductSKUWithInventoryResponse(product.BasePrice, productSKUEntity), nil&#10;}&#10;&#10;func (p *productService) CreateProduct(data *request.CreateProductRequest) (*response.ProductDetailResponse, error) {&#10;&#9;p.logger.Info(&quot;Creating product with name&quot;, data.Name)&#10;&#10;&#9;// Create Product Entity from request data&#10;&#9;productEntity := p.createProductEntity(data)&#10;&#10;&#9;// Create transactional repository&#10;&#9;txRepo, err := p.productRepository.WithTransaction()&#10;&#9;if err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Failed to create transaction:&quot;, err)&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;// Ensure rollback on error or panic&#10;&#9;defer func() {&#10;&#9;&#9;if r := recover(); r != nil {&#10;&#9;&#9;&#9;txRepo.Rollback()&#10;&#9;&#9;&#9;panic(r)&#10;&#9;&#9;}&#10;&#9;}()&#10;&#10;&#9;// 1. Create &amp; Insert the base product entity&#10;&#9;if err := txRepo.CreateProduct(productEntity); err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Error creating product:&quot;, err)&#10;&#9;&#9;txRepo.Rollback()&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;// 2. Create &amp; Insert product attribute info&#10;&#9;if err := p.processCreateProductAttributeInfoWithTx(txRepo, productEntity.ID, data.ProductAttributes); err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Error creating product attribute info:&quot;, err)&#10;&#9;&#9;txRepo.Rollback()&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;// 3. Create &amp; Insert product option info&#10;&#9;if err := p.processCreateProductOptionInfoWithTx(txRepo, productEntity.ID, data.OptionValues); err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Error creating product option info:&quot;, err)&#10;&#9;&#9;txRepo.Rollback()&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;// 4. Create &amp; Insert product attribute values&#10;&#9;if err := p.processCreateProductAttributesWithTx(txRepo, data.ProductAttributes); err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Error creating product attributes:&quot;, err)&#10;&#9;&#9;txRepo.Rollback()&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;// 5. Create &amp; Insert product SKUs&#10;&#9;if err := p.processCreateProductSKUsWithTx(txRepo, productEntity.ID, productEntity.Name, &amp;data.ProductSKUs); err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Error creating product SKUs:&quot;, err)&#10;&#9;&#9;txRepo.Rollback()&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;// 6. Create &amp; Insert product option combinations&#10;&#9;if err := p.processCreateProductOptionCombinationsWithTx(txRepo, productEntity.ID, data.OptionValues); err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Error creating product option combinations:&quot;, err)&#10;&#9;&#9;txRepo.Rollback()&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;// Commit the transaction&#10;&#9;if err := txRepo.Commit(); err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Failed to commit transaction:&quot;, err)&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;p.logger.Info(&quot;Product created successfully, ID: &quot;, productEntity.ID)&#10;&#9;return p.createProductDetailResponse(productEntity), nil&#10;}&#10;&#10;func (p *productService) DeleteProduct(id int64) error {&#10;&#9;p.logger.Info(&quot;Deleting product with ID: &quot;, id)&#10;&#10;&#9;err := p.productRepository.DeleteProduct(id)&#10;&#9;if err != nil {&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;p.logger.Info(&quot;Product deleted successfully, ID: &quot;, id)&#10;&#9;return nil&#10;}&#10;&#10;func (p *productService) processCreateProductAttributeInfoWithTx(txRepo product.ProductRepository, productID int64, attributeMap map[int64][]string) error {&#10;&#9;var attributeIDs []int64&#10;&#9;var productAttributeInfoEntities []entity.ProductAttributeInfo&#10;&#10;&#9;for attributeID, _ := range attributeMap {&#10;&#9;&#9;attributeIDs = append(attributeIDs, attributeID)&#10;&#9;}&#10;&#10;&#9;// 1. Find product attributes by IDs&#10;&#9;productAttributes, err := txRepo.FindProductAttributesByIDs(attributeIDs)&#10;&#9;if err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Error finding product attributes by IDs, error: &quot;, err)&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;// 2. Create product attribute info entities from the attribute map&#10;&#9;for _, attribute := range *productAttributes {&#10;&#9;&#9;if values, ok := attributeMap[attribute.ID]; ok {&#10;&#9;&#9;&#9;for _, value := range values {&#10;&#9;&#9;&#9;&#9;productAttributeInfoEntity := p.createProductAttributeInfoEntity(productID, attribute.Name, value)&#10;&#9;&#9;&#9;&#9;productAttributeInfoEntities = append(productAttributeInfoEntities, *productAttributeInfoEntity)&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;// 3. Save product attribute info entities to the repository&#10;&#9;if err := txRepo.CreateProductAttributeInfo(&amp;productAttributeInfoEntities); err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Error saving product attribute info to repository, error: &quot;, err)&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;return nil&#10;}&#10;&#10;func (p *productService) processCreateProductOptionInfoWithTx(txRepo product.ProductRepository, productID int64, optionMap map[int64][]string) error {&#10;&#9;var productOptionIDs []int64&#10;&#9;var productOptionInfoEntities []entity.ProductOptionInfo&#10;&#10;&#9;for productOptionID, _ := range optionMap {&#10;&#9;&#9;productOptionIDs = append(productOptionIDs, productOptionID)&#10;&#9;}&#10;&#10;&#9;// 1. Find product options by IDs&#10;&#9;productOptions, err := txRepo.FindProductOptionsByIDs(productOptionIDs)&#10;&#9;if err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Error finding product options by IDs, error: &quot;, err)&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;// 2. Create product option info entities from the option map&#10;&#9;for _, option := range *productOptions {&#10;&#9;&#9;if values, ok := optionMap[option.ID]; ok {&#10;&#9;&#9;&#9;for _, value := range values {&#10;&#9;&#9;&#9;&#9;productOptionInfoEntity := p.createProductOptionInfoEntity(productID, option.Name, value)&#10;&#9;&#9;&#9;&#9;productOptionInfoEntities = append(productOptionInfoEntities, *productOptionInfoEntity)&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;// 3. Save product option info entities to the repository&#10;&#9;if err := txRepo.CreateProductOptionInfo(&amp;productOptionInfoEntities); err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Error saving product option info to repository, error: &quot;, err)&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;return nil&#10;}&#10;&#10;func (p *productService) processCreateProductAttributesWithTx(txRepo product.ProductRepository, attributeValues map[int64][]string) error {&#10;&#9;// 1. Create product attribute values entities from the attribute values map&#10;&#9;var productAttributeValueEntities []entity.ProductAttributeValue&#10;&#9;for attributeID, values := range attributeValues {&#10;&#9;&#9;for _, value := range values {&#10;&#9;&#9;&#9;productAttributeValueEntity := p.createProductAttributeValueEntity(attributeID, value)&#10;&#9;&#9;&#9;productAttributeValueEntities = append(productAttributeValueEntities, *productAttributeValueEntity)&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;// 2. Save product attribute values to the repository&#10;&#9;err := txRepo.CreateProductAttributeValuesIfNotExist(&amp;productAttributeValueEntities)&#10;&#9;if err != nil {&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;return nil&#10;}&#10;&#10;func (p *productService) processCreateProductSKUsWithTx(txRepo product.ProductRepository, productID int64, productName string, productSKUData *[]request.CreateProductSKURequest) error {&#10;&#9;// 1. Create product SKU entities from the product SKU data&#10;&#9;var productSKUEntities []entity.ProductSKU&#10;&#9;for _, sku := range *productSKUData {&#10;&#9;&#9;productSKUEntity := p.createProductSKUEntity(productID, productName, &amp;sku)&#10;&#9;&#9;productSKUEntities = append(productSKUEntities, *productSKUEntity)&#10;&#9;}&#10;&#10;&#9;// 2. Save product SKUs to the repository&#10;&#9;if err := txRepo.CreateProductSKUs(&amp;productSKUEntities); err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Error saving product SKUs to repository, error: &quot;, err)&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;// 3. Create product inventory entities based on product SKUs and stock data&#10;&#9;var productInventoryEntities []entity.ProductInventory&#10;&#9;for i, productSKUEntity := range productSKUEntities {&#10;&#9;&#9;productInventory := p.createProductInventoryEntity(&amp;productSKUEntity, (*productSKUData)[i].Stock)&#10;&#9;&#9;productInventoryEntities = append(productInventoryEntities, *productInventory)&#10;&#9;}&#10;&#10;&#9;// 4. Save product inventory entities to repository&#10;&#9;if err := txRepo.CreateProductInventories(&amp;productInventoryEntities); err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Error saving product inventory to repository, error: &quot;, err)&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;return nil&#10;}&#10;&#10;func (p *productService) processCreateProductOptionCombinationsWithTx(txRepo product.ProductRepository, id int64, optionValues map[int64][]string) error {&#10;&#9;var productOptionCombinationEntities []entity.ProductOptionCombination&#10;&#10;&#9;// 1. Create product option combination entities from the option values map&#10;&#9;displayOrder := int32(1)&#10;&#9;for option, _ := range optionValues {&#10;&#9;&#9;productOptionCombinationEntity := p.createProductOptionCombinationEntity(id, option, int32(displayOrder))&#10;&#9;&#9;productOptionCombinationEntities = append(productOptionCombinationEntities, *productOptionCombinationEntity)&#10;&#9;&#9;displayOrder++&#10;&#9;}&#10;&#10;&#9;// 2. Save product option combinations to the repository&#10;&#9;if err := txRepo.CreateProductOptionCombinations(&amp;productOptionCombinationEntities); err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Error saving product option combinations to repository, error: &quot;, err)&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;// 3. Create product option value entities from the option values map&#10;&#9;var productOptionValueEntities []entity.ProductOptionValue&#10;&#9;for optionID, values := range optionValues {&#10;&#9;&#9;for _, value := range values {&#10;&#9;&#9;&#9;productOptionValueEntity := p.createProductOptionValueEntity(optionID, value)&#10;&#9;&#9;&#9;productOptionValueEntities = append(productOptionValueEntities, *productOptionValueEntity)&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;// 4. Create product option values in the repository if they do not already exist&#10;&#9;if err := txRepo.CreateProductOptionValuesIfNotExist(&amp;productOptionValueEntities); err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Error saving product option values to repository, error: &quot;, err)&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;return nil&#10;}&#10;&#10;func (p *productService) createProductEntity(data *request.CreateProductRequest) *entity.Product {&#10;&#9;return &amp;entity.Product{&#10;&#9;&#9;Name:             data.Name,&#10;&#9;&#9;Description:      data.Description,&#10;&#9;&#9;ShortDescription: data.ShortDescription,&#10;&#9;&#9;ImageURL:         data.ImageURL,&#10;&#9;&#9;Slug:             data.Slug,&#10;&#9;&#9;BasePrice:        data.BasePrice,&#10;&#9;&#9;SalePrice:        data.SalePrice,&#10;&#9;&#9;IsFeatured:       data.IsFeatured,&#10;&#9;&#9;SaleStartDate:    data.SaleStartDate,&#10;&#9;&#9;SaleEndDate:      data.SaleEndDate,&#10;&#9;&#9;Status:           data.Status,&#10;&#9;&#9;BrandID:          data.BrandID,&#10;&#9;&#9;CategoryID:       data.CategoryID,&#10;&#9;&#9;UserID:           data.UserID,&#10;&#9;}&#10;}&#10;&#10;func (p *productService) createProductAttributeInfoEntity(productID int64, attributeName string, attributeValue string) *entity.ProductAttributeInfo {&#10;&#9;return &amp;entity.ProductAttributeInfo{&#10;&#9;&#9;AttributeName:  attributeName,&#10;&#9;&#9;AttributeValue: attributeValue,&#10;&#9;&#9;ProductID:      productID,&#10;&#9;}&#10;}&#10;&#10;func (p *productService) createProductOptionInfoEntity(productID int64, optionName string, optionValue string) *entity.ProductOptionInfo {&#10;&#9;return &amp;entity.ProductOptionInfo{&#10;&#9;&#9;OptionName:  optionName,&#10;&#9;&#9;OptionValue: optionValue,&#10;&#9;&#9;ProductID:   productID,&#10;&#9;}&#10;}&#10;&#10;func (p *productService) createProductAttributeValueEntity(productAttributeID int64, value string) *entity.ProductAttributeValue {&#10;&#9;return &amp;entity.ProductAttributeValue{&#10;&#9;&#9;ProductAttributeID: productAttributeID,&#10;&#9;&#9;Value:              value,&#10;&#9;}&#10;}&#10;&#10;func (p *productService) createProductSKUEntity(productID int64, productName string, data *request.CreateProductSKURequest) *entity.ProductSKU {&#10;&#9;return &amp;entity.ProductSKU{&#10;&#9;&#9;SKU:           data.SKU,&#10;&#9;&#9;SKUSignature:  p.generateSKUSignature(productName, data.SKU),&#10;&#9;&#9;ExtraPrice:    data.ExtraPrice,&#10;&#9;&#9;SaleType:      data.SaleType,&#10;&#9;&#9;SaleValue:     data.SaleValue,&#10;&#9;&#9;SaleStartDate: data.SaleStartDate,&#10;&#9;&#9;SaleEndDate:   data.SaleEndDate,&#10;&#9;&#9;Status:        string(constants.ProductStatusActive),&#10;&#9;&#9;ProductID:     productID,&#10;&#9;}&#10;}&#10;&#10;func (p *productService) createProductInventoryEntity(productSKU *entity.ProductSKU, stock int32) *entity.ProductInventory {&#10;&#9;return &amp;entity.ProductInventory{&#10;&#9;&#9;ProductID:      productSKU.ProductID,&#10;&#9;&#9;ProductSKUID:   productSKU.ID,&#10;&#9;&#9;AvailableStock: stock,&#10;&#9;&#9;ReservedStock:  0,&#10;&#9;&#9;DamagedStock:   0,&#10;&#9;}&#10;}&#10;&#10;func (p *productService) createProductOptionCombinationEntity(productID int64, productOptionID int64, displayOrder int32) *entity.ProductOptionCombination {&#10;&#9;return &amp;entity.ProductOptionCombination{&#10;&#9;&#9;ProductID:       productID,&#10;&#9;&#9;ProductOptionID: productOptionID,&#10;&#9;&#9;DisplayOrder:    displayOrder,&#10;&#9;}&#10;}&#10;&#10;func (p *productService) createProductOptionValueEntity(id int64, value string) *entity.ProductOptionValue {&#10;&#9;return &amp;entity.ProductOptionValue{&#10;&#9;&#9;ProductOptionID: id,&#10;&#9;&#9;Value:           value,&#10;&#9;}&#10;}&#10;&#10;func (p *productService) createProductResponse(product *entity.Product) *response.ProductResponse {&#10;&#9;return &amp;response.ProductResponse{&#10;&#9;&#9;ID:               product.ID,&#10;&#9;&#9;Name:             product.Name,&#10;&#9;&#9;ShortDescription: product.ShortDescription,&#10;&#9;&#9;ImageURL:         product.ImageURL,&#10;&#9;&#9;BasePrice:        product.BasePrice,&#10;&#9;&#9;SalePrice:        product.SalePrice,&#10;&#9;&#9;IsFeatured:       product.IsFeatured,&#10;&#9;&#9;SaleStartDate:    product.SaleStartDate,&#10;&#9;&#9;SaleEndDate:      product.SaleEndDate,&#10;&#9;&#9;Status:           product.Status,&#10;&#9;&#9;BrandID:          product.BrandID,&#10;&#9;&#9;CategoryID:       product.CategoryID,&#10;&#9;&#9;UserID:           product.UserID,&#10;&#9;}&#10;}&#10;&#10;func (p *productService) createProductDetailResponse(product *entity.Product) *response.ProductDetailResponse {&#10;&#9;// 1. Fetch product attributes and options&#10;&#9;productAttributes, err := p.productRepository.FindProductAttributesInfoByProductID(product.ID)&#10;&#9;if err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Error fetching product attributes for product ID: &quot;, product.ID, &quot;, Error: &quot;, err)&#10;&#9;&#9;return nil&#10;&#9;}&#10;&#9;productOptions, err := p.productRepository.FindProductOptionsInfoByProductID(product.ID)&#10;&#9;if err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Error fetching product options for product ID: &quot;, product.ID, &quot;, Error: &quot;, err)&#10;&#9;&#9;return nil&#10;&#9;}&#10;&#10;&#9;// 3. Fetch product SKUs&#10;&#9;productSKUWithInventories, err := p.productRepository.FindProductSKUsByProductID(product.ID)&#10;&#9;if productSKUWithInventories == nil {&#10;&#9;&#9;p.logger.Error(&quot;No product SKUs found for product ID&quot;, product.ID)&#10;&#9;&#9;return nil&#10;&#9;}&#10;&#10;&#9;// 2. Create response objects for attributes and options&#10;&#9;var attributeValues []*response.ProductWithAttributeValuesResponse&#10;&#9;var optionValues []*response.ProductWithOptionValuesResponse&#10;&#9;for _, attribute := range *productAttributes {&#10;&#9;&#9;attributeValues = append(attributeValues, p.createProductWithAttributeValuesResponse(&amp;attribute))&#10;&#9;}&#10;&#9;for _, option := range *productOptions {&#10;&#9;&#9;optionValues = append(optionValues, p.createProductWithOptionValuesResponse(&amp;option))&#10;&#9;}&#10;&#10;&#9;var productSKUResponses []*response.ProductSKUDetailResponse&#10;&#9;for _, sku := range *productSKUWithInventories {&#10;&#9;&#9;productSKUResponse := p.createProductSKUWithInventoryResponse(product.BasePrice, &amp;sku)&#10;&#9;&#9;productSKUResponses = append(productSKUResponses, productSKUResponse)&#10;&#9;}&#10;&#10;&#9;return &amp;response.ProductDetailResponse{&#10;&#9;&#9;ID:               product.ID,&#10;&#9;&#9;Name:             product.Name,&#10;&#9;&#9;Description:      product.Description,&#10;&#9;&#9;ShortDescription: product.ShortDescription,&#10;&#9;&#9;ImageURL:         product.ImageURL,&#10;&#9;&#9;Slug:             product.Slug,&#10;&#9;&#9;BasePrice:        product.BasePrice,&#10;&#9;&#9;SalePrice:        product.SalePrice,&#10;&#9;&#9;IsFeatured:       product.IsFeatured,&#10;&#9;&#9;SaleStartDate:    product.SaleStartDate,&#10;&#9;&#9;SaleEndDate:      product.SaleEndDate,&#10;&#9;&#9;Status:           product.Status,&#10;&#9;&#9;BrandID:          product.BrandID,&#10;&#9;&#9;CategoryID:       product.CategoryID,&#10;&#9;&#9;UserID:           product.UserID,&#10;&#9;&#9;Version:          product.Version,&#10;&#9;&#9;AttributeValues:  &amp;attributeValues,&#10;&#9;&#9;ProductSKUs:      &amp;productSKUResponses,&#10;&#9;&#9;OptionValues:     &amp;optionValues,&#10;&#9;}&#10;&#10;}&#10;&#10;func (p *productService) createProductWithAttributeValuesResponse(attribute *entity.ProductAttributeInfo) *response.ProductWithAttributeValuesResponse {&#10;&#9;return &amp;response.ProductWithAttributeValuesResponse{&#10;&#9;&#9;ID:              attribute.ID,&#10;&#9;&#9;AttributeName:   attribute.AttributeName,&#10;&#9;&#9;AttributeValues: attribute.AttributeValue,&#10;&#9;}&#10;}&#10;&#10;func (p *productService) createProductWithOptionValuesResponse(option *entity.ProductOptionInfo) *response.ProductWithOptionValuesResponse {&#10;&#9;return &amp;response.ProductWithOptionValuesResponse{&#10;&#9;&#9;ID:           option.ID,&#10;&#9;&#9;OptionNames:  option.OptionName,&#10;&#9;&#9;OptionValues: option.OptionValue,&#10;&#9;}&#10;}&#10;&#10;func (p *productService) createProductSKUWithInventoryResponse(&#10;&#9;productPrice float64,&#10;&#9;productSKUDetail *repository.ProductSKUDetail,&#10;) *response.ProductSKUDetailResponse {&#10;&#9;productSKUPrice := p.calculateProductSKUPrice(productPrice, productSKUDetail.ExtraPrice)&#10;&#9;return &amp;response.ProductSKUDetailResponse{&#10;&#9;&#9;ID:            productSKUDetail.ID,&#10;&#9;&#9;SKU:           productSKUDetail.SKU,&#10;&#9;&#9;SKUSignature:  productSKUDetail.SKUSignature,&#10;&#9;&#9;Price:         productSKUPrice,&#10;&#9;&#9;SalePrice:     p.calculateProductSKUSalePrice(productSKUPrice, productSKUDetail.SaleType, productSKUDetail.SaleValue),&#10;&#9;&#9;SaleStartDate: productSKUDetail.SaleStartDate,&#10;&#9;&#9;SaleEndDate:   productSKUDetail.SaleEndDate,&#10;&#9;&#9;Stock:         productSKUDetail.Stock,&#10;&#9;&#9;Status:        productSKUDetail.Status,&#10;&#9;&#9;ProductID:     productSKUDetail.ProductID,&#10;&#9;}&#10;}&#10;&#10;func (p *productService) generateSKUSignature(name string, sku string) string {&#10;&#9;skuSignature := strings.ToLower(name + &quot;-&quot; + sku)&#10;&#9;skuSignature = strings.ReplaceAll(sku, &quot; &quot;, &quot;-&quot;)&#10;&#10;&#9;return skuSignature&#10;}&#10;&#10;func (p *productService) calculateProductSKUPrice(productPrice float64, extraPrice float64) float64 {&#10;&#9;if extraPrice &lt; 0 {&#10;&#9;&#9;return productPrice&#10;&#9;}&#10;&#10;&#9;finalPrice := productPrice + productPrice*extraPrice&#10;&#9;return finalPrice&#10;}&#10;&#10;func (p *productService) calculateProductSKUSalePrice(productSKUPrice float64, saleType *string, saleValue *float64) *float64 {&#10;&#9;if saleType == nil || saleValue == nil {&#10;&#9;&#9;return nil&#10;&#9;}&#10;&#10;&#9;if *saleType == constants.SaleTypePercentage {&#10;&#9;&#9;// Calculate sale price as a percentage discount&#10;&#9;&#9;finalPrice := productSKUPrice - (productSKUPrice * *saleValue)&#10;&#9;&#9;return &amp;finalPrice&#10;&#9;} else if *saleType == constants.SaleTypeFixed {&#10;&#9;&#9;finalPrice := productSKUPrice - *saleValue&#10;&#9;&#9;if finalPrice &lt; 0 {&#10;&#9;&#9;&#9;finalPrice = 0&#10;&#9;&#9;}&#10;&#9;&#9;return &amp;finalPrice&#10;&#9;}&#10;&#10;&#9;return nil&#10;}&#10;&#10;// CreateProductWithoutSKU Help to create a product without SKU (for case app only have backend API)&#10;func (p *productService) CreateProductWithoutSKU(data *request.CreateProductWithoutSKURequest) (*response.ProductDetailResponse, error) {&#10;&#9;p.logger.Info(&quot;Creating product without SKU with name: &quot;, data.Name)&#10;&#10;&#9;// Generate all SKU combinations automatically from option values&#10;&#9;productSKUs, err := p.generateAllSKUCombinations(data.Name, data.OptionValues)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;// Create the full CreateProductRequest with generated SKUs&#10;&#9;createProductRequest := &amp;request.CreateProductRequest{&#10;&#9;&#9;Name:              data.Name,&#10;&#9;&#9;Description:       data.Description,&#10;&#9;&#9;ShortDescription:  data.ShortDescription,&#10;&#9;&#9;ImageURL:          data.ImageURL,&#10;&#9;&#9;Slug:              data.Slug,&#10;&#9;&#9;BasePrice:         data.BasePrice,&#10;&#9;&#9;SalePrice:         data.SalePrice,&#10;&#9;&#9;IsFeatured:        data.IsFeatured,&#10;&#9;&#9;SaleStartDate:     data.SaleStartDate,&#10;&#9;&#9;SaleEndDate:       data.SaleEndDate,&#10;&#9;&#9;Status:            string(constants.ProductStatusActive),&#10;&#9;&#9;BrandID:           data.BrandID,&#10;&#9;&#9;CategoryID:        data.CategoryID,&#10;&#9;&#9;UserID:            data.UserID,&#10;&#9;&#9;ProductAttributes: data.ProductAttributes,&#10;&#9;&#9;OptionValues:      data.OptionValues,&#10;&#9;&#9;ProductSKUs:       *productSKUs,&#10;&#9;}&#10;&#10;&#9;// Call the existing CreateProduct function&#10;&#9;return p.CreateProduct(createProductRequest)&#10;}&#10;&#10;// generateAllSKUCombinations generates all possible SKU combinations from option values&#10;func (p *productService) generateAllSKUCombinations(productName string, optionValues map[int64][]string) (*[]request.CreateProductSKURequest, error) {&#10;&#9;// Clean up option values - remove empty options&#10;&#9;cleanedOptions := make(map[int64][]string)&#10;&#9;optionIDs := make([]int64, 0)&#10;&#10;&#9;for optionID, values := range optionValues {&#10;&#9;&#9;if len(values) &gt; 0 {&#10;&#9;&#9;&#9;cleanedOptions[optionID] = values&#10;&#9;&#9;&#9;optionIDs = append(optionIDs, optionID)&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;// If no options, create a single default SKU&#10;&#9;if len(cleanedOptions) == 0 {&#10;&#9;&#9;defaultSKU := []request.CreateProductSKURequest{&#10;&#9;&#9;&#9;{&#10;&#9;&#9;&#9;&#9;SKU:        productName + &quot;_default&quot;,&#10;&#9;&#9;&#9;&#9;ExtraPrice: 0,&#10;&#9;&#9;&#9;&#9;Stock:      100,&#10;&#9;&#9;&#9;},&#10;&#9;&#9;}&#10;&#9;&#9;return &amp;defaultSKU, nil&#10;&#9;}&#10;&#10;&#9;// Generate all combinations using cartesian product&#10;&#9;combinations := p.generateCartesianProduct(cleanedOptions, optionIDs)&#10;&#10;&#9;// Create SKU requests from combinations&#10;&#9;var productSKUs []request.CreateProductSKURequest&#10;&#9;for _, combination := range combinations {&#10;&#9;&#9;sku := p.buildSKUFromCombination(productName, combination, optionIDs)&#10;&#9;&#9;price := constants.DefaultPrice&#10;&#9;&#9;stock := constants.DefaultStock&#10;&#10;&#9;&#9;productSKUs = append(productSKUs, request.CreateProductSKURequest{&#10;&#9;&#9;&#9;SKU:        sku,&#10;&#9;&#9;&#9;ExtraPrice: price,&#10;&#9;&#9;&#9;Stock:      int32(stock),&#10;&#9;&#9;})&#10;&#9;}&#10;&#10;&#9;return &amp;productSKUs, nil&#10;}&#10;&#10;// generateCartesianProduct generates all possible combinations of option values&#10;func (p *productService) generateCartesianProduct(optionValues map[int64][]string, optionIDs []int64) []map[int64]string {&#10;&#9;if len(optionIDs) == 0 {&#10;&#9;&#9;return []map[int64]string{}&#10;&#9;}&#10;&#10;&#9;// Start with the first option&#10;&#9;var result []map[int64]string&#10;&#9;firstOptionID := optionIDs[0]&#10;&#9;firstValues := optionValues[firstOptionID]&#10;&#10;&#9;for _, value := range firstValues {&#10;&#9;&#9;combination := make(map[int64]string)&#10;&#9;&#9;combination[firstOptionID] = value&#10;&#9;&#9;result = append(result, combination)&#10;&#9;}&#10;&#10;&#9;// Add remaining options one by one&#10;&#9;for i := 1; i &lt; len(optionIDs); i++ {&#10;&#9;&#9;optionID := optionIDs[i]&#10;&#9;&#9;values := optionValues[optionID]&#10;&#10;&#9;&#9;var newResult []map[int64]string&#10;&#9;&#9;for _, existingCombination := range result {&#10;&#9;&#9;&#9;for _, value := range values {&#10;&#9;&#9;&#9;&#9;newCombination := make(map[int64]string)&#10;&#9;&#9;&#9;&#9;// Copy existing combination&#10;&#9;&#9;&#9;&#9;for k, v := range existingCombination {&#10;&#9;&#9;&#9;&#9;&#9;newCombination[k] = v&#10;&#9;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;&#9;// Add new option value&#10;&#9;&#9;&#9;&#9;newCombination[optionID] = value&#10;&#9;&#9;&#9;&#9;newResult = append(newResult, newCombination)&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#9;&#9;result = newResult&#10;&#9;}&#10;&#10;&#9;return result&#10;}&#10;&#10;// buildSKUFromCombination builds SKU string from option combination&#10;func (p *productService) buildSKUFromCombination(productName string, combination map[int64]string, optionIDs []int64) string {&#10;&#9;skuParts := []string{productName}&#10;&#10;&#9;// Add option values in consistent order&#10;&#9;for _, optionID := range optionIDs {&#10;&#9;&#9;if value, exists := combination[optionID]; exists {&#10;&#9;&#9;&#9;// Clean up value for SKU (remove spaces, special chars)&#10;&#9;&#9;&#9;cleanValue := strings.ReplaceAll(value, &quot; &quot;, &quot;&quot;)&#10;&#9;&#9;&#9;skuParts = append(skuParts, cleanValue)&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;return strings.Join(skuParts, &quot;_&quot;)&#10;}&#10;" />
              <option name="updatedContent" value="package service&#10;&#10;import (&#10;&#9;&quot;github.com/hthinh24/go-store/internal/pkg/logger&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/services/product&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/services/product/internal/constants&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/services/product/internal/dto/repository&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/services/product/internal/dto/request&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/services/product/internal/dto/response&quot;&#10;&#9;&quot;github.com/hthinh24/go-store/services/product/internal/entity&quot;&#10;&#9;&quot;strings&quot;&#10;)&#10;&#10;type productService struct {&#10;&#9;logger            logger.Logger&#10;&#9;productRepository product.ProductRepository&#10;}&#10;&#10;// NewProductService creates a new instance of ProductService&#10;func NewProductService(logger logger.Logger, productRepository product.ProductRepository) product.ProductService {&#10;&#9;return &amp;productService{&#10;&#9;&#9;logger:            logger,&#10;&#9;&#9;productRepository: productRepository,&#10;&#9;}&#10;}&#10;&#10;func (p *productService) GetProductByID(id int64) (*response.ProductResponse, error) {&#10;&#9;p.logger.Info(&quot;Get product with ID: &quot;, id)&#10;&#10;&#9;productEntity, err := p.productRepository.FindProductByID(id)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;p.logger.Info(&quot;Product retrieved successfully, ID: &quot;, productEntity.ID)&#10;&#9;return p.createProductResponse(productEntity), nil&#10;}&#10;&#10;func (p *productService) GetProductDetailByID(id int64) (*response.ProductDetailResponse, error) {&#10;&#9;p.logger.Info(&quot;Get product with ID: &quot;, id)&#10;&#10;&#9;productEntity, err := p.productRepository.FindProductByID(id)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;p.logger.Info(&quot;Product retrieved successfully, ID: &quot;, productEntity.ID)&#10;&#9;return p.createProductDetailResponse(productEntity), nil&#10;}&#10;&#10;func (p *productService) GetProductSKUByID(skuID int64) (*response.ProductSKUDetailResponse, error) {&#10;&#9;p.logger.Info(&quot;Get product SKU with ID: &quot;, skuID)&#10;&#10;&#9;productSKUEntity, err := p.productRepository.FindProductSKUByID(skuID)&#10;&#9;if err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Error retrieving product SKU with ID: &quot;, skuID, &quot;, Error: &quot;, err)&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;product, err := p.productRepository.FindProductByID(productSKUEntity.ProductID)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;p.logger.Info(&quot;Product SKU retrieved successfully, ID: &quot;, productSKUEntity.ID)&#10;&#9;return p.createProductSKUWithInventoryResponse(product.BasePrice, productSKUEntity), nil&#10;}&#10;&#10;func (p *productService) CreateProduct(data *request.CreateProductRequest) (*response.ProductDetailResponse, error) {&#10;&#9;p.logger.Info(&quot;Creating product with name: &quot;, data.Name)&#10;&#10;&#9;// Create Product Entity from request data&#10;&#9;productEntity := p.createProductEntity(data)&#10;&#10;&#9;// Create transactional repository&#10;&#9;txRepo, err := p.productRepository.WithTransaction()&#10;&#9;if err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Failed to create transaction: &quot;, err)&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;// Ensure rollback on error or panic&#10;&#9;defer func() {&#10;&#9;&#9;if r := recover(); r != nil {&#10;&#9;&#9;&#9;txRepo.Rollback()&#10;&#9;&#9;&#9;panic(r)&#10;&#9;&#9;}&#10;&#9;}()&#10;&#10;&#9;// 1. Create &amp; Insert the base product entity&#10;&#9;if err := txRepo.CreateProduct(productEntity); err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Error creating product: &quot;, err)&#10;&#9;&#9;txRepo.Rollback()&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;// 2. Create &amp; Insert product attribute info&#10;&#9;if err := p.processCreateProductAttributeInfoWithTx(txRepo, productEntity.ID, data.ProductAttributes); err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Error creating product attribute info: &quot;, err)&#10;&#9;&#9;txRepo.Rollback()&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;// 3. Create &amp; Insert product option info&#10;&#9;if err := p.processCreateProductOptionInfoWithTx(txRepo, productEntity.ID, data.OptionValues); err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Error creating product option info: &quot;, err)&#10;&#9;&#9;txRepo.Rollback()&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;// 4. Create &amp; Insert product attribute values&#10;&#9;if err := p.processCreateProductAttributesWithTx(txRepo, data.ProductAttributes); err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Error creating product attributes: &quot;, err)&#10;&#9;&#9;txRepo.Rollback()&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;// 5. Create &amp; Insert product SKUs&#10;&#9;if err := p.processCreateProductSKUsWithTx(txRepo, productEntity.ID, productEntity.Name, &amp;data.ProductSKUs); err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Error creating product SKUs: &quot;, err)&#10;&#9;&#9;txRepo.Rollback()&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;// 6. Create &amp; Insert product option combinations&#10;&#9;if err := p.processCreateProductOptionCombinationsWithTx(txRepo, productEntity.ID, data.OptionValues); err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Error creating product option combinations: &quot;, err)&#10;&#9;&#9;txRepo.Rollback()&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;// Commit the transaction&#10;&#9;if err := txRepo.Commit(); err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Failed to commit transaction: &quot;, err)&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;p.logger.Info(&quot;Product created successfully, ID: &quot;, productEntity.ID)&#10;&#9;return p.createProductDetailResponse(productEntity), nil&#10;}&#10;&#10;func (p *productService) DeleteProduct(id int64) error {&#10;&#9;p.logger.Info(&quot;Deleting product with ID: &quot;, id)&#10;&#10;&#9;err := p.productRepository.DeleteProduct(id)&#10;&#9;if err != nil {&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;p.logger.Info(&quot;Product deleted successfully, ID: &quot;, id)&#10;&#9;return nil&#10;}&#10;&#10;func (p *productService) processCreateProductAttributeInfoWithTx(txRepo product.ProductRepository, productID int64, attributeMap map[int64][]string) error {&#10;&#9;var attributeIDs []int64&#10;&#9;var productAttributeInfoEntities []entity.ProductAttributeInfo&#10;&#10;&#9;for attributeID, _ := range attributeMap {&#10;&#9;&#9;attributeIDs = append(attributeIDs, attributeID)&#10;&#9;}&#10;&#10;&#9;// 1. Find product attributes by IDs&#10;&#9;productAttributes, err := txRepo.FindProductAttributesByIDs(attributeIDs)&#10;&#9;if err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Error finding product attributes by IDs: &quot;, err)&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;// 2. Create product attribute info entities from the attribute map&#10;&#9;for _, attribute := range *productAttributes {&#10;&#9;&#9;if values, ok := attributeMap[attribute.ID]; ok {&#10;&#9;&#9;&#9;for _, value := range values {&#10;&#9;&#9;&#9;&#9;productAttributeInfoEntity := p.createProductAttributeInfoEntity(productID, attribute.Name, value)&#10;&#9;&#9;&#9;&#9;productAttributeInfoEntities = append(productAttributeInfoEntities, *productAttributeInfoEntity)&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;// 3. Save product attribute info entities to the repository&#10;&#9;if err := txRepo.CreateProductAttributeInfo(&amp;productAttributeInfoEntities); err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Error saving product attribute info to repository: &quot;, err)&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;return nil&#10;}&#10;&#10;func (p *productService) processCreateProductOptionInfoWithTx(txRepo product.ProductRepository, productID int64, optionMap map[int64][]string) error {&#10;&#9;var productOptionIDs []int64&#10;&#9;var productOptionInfoEntities []entity.ProductOptionInfo&#10;&#10;&#9;for productOptionID, _ := range optionMap {&#10;&#9;&#9;productOptionIDs = append(productOptionIDs, productOptionID)&#10;&#9;}&#10;&#10;&#9;// 1. Find product options by IDs&#10;&#9;productOptions, err := txRepo.FindProductOptionsByIDs(productOptionIDs)&#10;&#9;if err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Error finding product options by IDs: &quot;, err)&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;// 2. Create product option info entities from the option map&#10;&#9;for _, option := range *productOptions {&#10;&#9;&#9;if values, ok := optionMap[option.ID]; ok {&#10;&#9;&#9;&#9;for _, value := range values {&#10;&#9;&#9;&#9;&#9;productOptionInfoEntity := p.createProductOptionInfoEntity(productID, option.Name, value)&#10;&#9;&#9;&#9;&#9;productOptionInfoEntities = append(productOptionInfoEntities, *productOptionInfoEntity)&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;// 3. Save product option info entities to the repository&#10;&#9;if err := txRepo.CreateProductOptionInfo(&amp;productOptionInfoEntities); err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Error saving product option info to repository: &quot;, err)&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;return nil&#10;}&#10;&#10;func (p *productService) processCreateProductAttributesWithTx(txRepo product.ProductRepository, attributeValues map[int64][]string) error {&#10;&#9;// 1. Create product attribute values entities from the attribute values map&#10;&#9;var productAttributeValueEntities []entity.ProductAttributeValue&#10;&#9;for attributeID, values := range attributeValues {&#10;&#9;&#9;for _, value := range values {&#10;&#9;&#9;&#9;productAttributeValueEntity := p.createProductAttributeValueEntity(attributeID, value)&#10;&#9;&#9;&#9;productAttributeValueEntities = append(productAttributeValueEntities, *productAttributeValueEntity)&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;// 2. Save product attribute values to the repository&#10;&#9;err := txRepo.CreateProductAttributeValuesIfNotExist(&amp;productAttributeValueEntities)&#10;&#9;if err != nil {&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;return nil&#10;}&#10;&#10;func (p *productService) processCreateProductSKUsWithTx(txRepo product.ProductRepository, productID int64, productName string, productSKUData *[]request.CreateProductSKURequest) error {&#10;&#9;// 1. Create product SKU entities from the product SKU data&#10;&#9;var productSKUEntities []entity.ProductSKU&#10;&#9;for _, sku := range *productSKUData {&#10;&#9;&#9;productSKUEntity := p.createProductSKUEntity(productID, productName, &amp;sku)&#10;&#9;&#9;productSKUEntities = append(productSKUEntities, *productSKUEntity)&#10;&#9;}&#10;&#10;&#9;// 2. Save product SKUs to the repository&#10;&#9;if err := txRepo.CreateProductSKUs(&amp;productSKUEntities); err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Error saving product SKUs to repository: &quot;, err)&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;// 3. Create product inventory entities based on product SKUs and stock data&#10;&#9;var productInventoryEntities []entity.ProductInventory&#10;&#9;for i, productSKUEntity := range productSKUEntities {&#10;&#9;&#9;productInventory := p.createProductInventoryEntity(&amp;productSKUEntity, (*productSKUData)[i].Stock)&#10;&#9;&#9;productInventoryEntities = append(productInventoryEntities, *productInventory)&#10;&#9;}&#10;&#10;&#9;// 4. Save product inventory entities to repository&#10;&#9;if err := txRepo.CreateProductInventories(&amp;productInventoryEntities); err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Error saving product inventory to repository: &quot;, err)&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;return nil&#10;}&#10;&#10;func (p *productService) processCreateProductOptionCombinationsWithTx(txRepo product.ProductRepository, id int64, optionValues map[int64][]string) error {&#10;&#9;var productOptionCombinationEntities []entity.ProductOptionCombination&#10;&#10;&#9;// 1. Create product option combination entities from the option values map&#10;&#9;displayOrder := int32(1)&#10;&#9;for option, _ := range optionValues {&#10;&#9;&#9;productOptionCombinationEntity := p.createProductOptionCombinationEntity(id, option, int32(displayOrder))&#10;&#9;&#9;productOptionCombinationEntities = append(productOptionCombinationEntities, *productOptionCombinationEntity)&#10;&#9;&#9;displayOrder++&#10;&#9;}&#10;&#10;&#9;// 2. Save product option combinations to the repository&#10;&#9;if err := txRepo.CreateProductOptionCombinations(&amp;productOptionCombinationEntities); err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Error saving product option combinations to repository: &quot;, err)&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;// 3. Create product option value entities from the option values map&#10;&#9;var productOptionValueEntities []entity.ProductOptionValue&#10;&#9;for optionID, values := range optionValues {&#10;&#9;&#9;for _, value := range values {&#10;&#9;&#9;&#9;productOptionValueEntity := p.createProductOptionValueEntity(optionID, value)&#10;&#9;&#9;&#9;productOptionValueEntities = append(productOptionValueEntities, *productOptionValueEntity)&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;// 4. Create product option values in the repository if they do not already exist&#10;&#9;if err := txRepo.CreateProductOptionValuesIfNotExist(&amp;productOptionValueEntities); err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Error saving product option values to repository: &quot;, err)&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;return nil&#10;}&#10;&#10;func (p *productService) createProductEntity(data *request.CreateProductRequest) *entity.Product {&#10;&#9;return &amp;entity.Product{&#10;&#9;&#9;Name:             data.Name,&#10;&#9;&#9;Description:      data.Description,&#10;&#9;&#9;ShortDescription: data.ShortDescription,&#10;&#9;&#9;ImageURL:         data.ImageURL,&#10;&#9;&#9;Slug:             data.Slug,&#10;&#9;&#9;BasePrice:        data.BasePrice,&#10;&#9;&#9;SalePrice:        data.SalePrice,&#10;&#9;&#9;IsFeatured:       data.IsFeatured,&#10;&#9;&#9;SaleStartDate:    data.SaleStartDate,&#10;&#9;&#9;SaleEndDate:      data.SaleEndDate,&#10;&#9;&#9;Status:           data.Status,&#10;&#9;&#9;BrandID:          data.BrandID,&#10;&#9;&#9;CategoryID:       data.CategoryID,&#10;&#9;&#9;UserID:           data.UserID,&#10;&#9;}&#10;}&#10;&#10;func (p *productService) createProductAttributeInfoEntity(productID int64, attributeName string, attributeValue string) *entity.ProductAttributeInfo {&#10;&#9;return &amp;entity.ProductAttributeInfo{&#10;&#9;&#9;AttributeName:  attributeName,&#10;&#9;&#9;AttributeValue: attributeValue,&#10;&#9;&#9;ProductID:      productID,&#10;&#9;}&#10;}&#10;&#10;func (p *productService) createProductOptionInfoEntity(productID int64, optionName string, optionValue string) *entity.ProductOptionInfo {&#10;&#9;return &amp;entity.ProductOptionInfo{&#10;&#9;&#9;OptionName:  optionName,&#10;&#9;&#9;OptionValue: optionValue,&#10;&#9;&#9;ProductID:   productID,&#10;&#9;}&#10;}&#10;&#10;func (p *productService) createProductAttributeValueEntity(productAttributeID int64, value string) *entity.ProductAttributeValue {&#10;&#9;return &amp;entity.ProductAttributeValue{&#10;&#9;&#9;ProductAttributeID: productAttributeID,&#10;&#9;&#9;Value:              value,&#10;&#9;}&#10;}&#10;&#10;func (p *productService) createProductSKUEntity(productID int64, productName string, data *request.CreateProductSKURequest) *entity.ProductSKU {&#10;&#9;return &amp;entity.ProductSKU{&#10;&#9;&#9;SKU:           data.SKU,&#10;&#9;&#9;SKUSignature:  p.generateSKUSignature(productName, data.SKU),&#10;&#9;&#9;ExtraPrice:    data.ExtraPrice,&#10;&#9;&#9;SaleType:      data.SaleType,&#10;&#9;&#9;SaleValue:     data.SaleValue,&#10;&#9;&#9;SaleStartDate: data.SaleStartDate,&#10;&#9;&#9;SaleEndDate:   data.SaleEndDate,&#10;&#9;&#9;Status:        string(constants.ProductStatusActive),&#10;&#9;&#9;ProductID:     productID,&#10;&#9;}&#10;}&#10;&#10;func (p *productService) createProductInventoryEntity(productSKU *entity.ProductSKU, stock int32) *entity.ProductInventory {&#10;&#9;return &amp;entity.ProductInventory{&#10;&#9;&#9;ProductID:      productSKU.ProductID,&#10;&#9;&#9;ProductSKUID:   productSKU.ID,&#10;&#9;&#9;AvailableStock: stock,&#10;&#9;&#9;ReservedStock:  0,&#10;&#9;&#9;DamagedStock:   0,&#10;&#9;}&#10;}&#10;&#10;func (p *productService) createProductOptionCombinationEntity(productID int64, productOptionID int64, displayOrder int32) *entity.ProductOptionCombination {&#10;&#9;return &amp;entity.ProductOptionCombination{&#10;&#9;&#9;ProductID:       productID,&#10;&#9;&#9;ProductOptionID: productOptionID,&#10;&#9;&#9;DisplayOrder:    displayOrder,&#10;&#9;}&#10;}&#10;&#10;func (p *productService) createProductOptionValueEntity(id int64, value string) *entity.ProductOptionValue {&#10;&#9;return &amp;entity.ProductOptionValue{&#10;&#9;&#9;ProductOptionID: id,&#10;&#9;&#9;Value:           value,&#10;&#9;}&#10;}&#10;&#10;func (p *productService) createProductResponse(product *entity.Product) *response.ProductResponse {&#10;&#9;return &amp;response.ProductResponse{&#10;&#9;&#9;ID:               product.ID,&#10;&#9;&#9;Name:             product.Name,&#10;&#9;&#9;ShortDescription: product.ShortDescription,&#10;&#9;&#9;ImageURL:         product.ImageURL,&#10;&#9;&#9;BasePrice:        product.BasePrice,&#10;&#9;&#9;SalePrice:        product.SalePrice,&#10;&#9;&#9;IsFeatured:       product.IsFeatured,&#10;&#9;&#9;SaleStartDate:    product.SaleStartDate,&#10;&#9;&#9;SaleEndDate:      product.SaleEndDate,&#10;&#9;&#9;Status:           product.Status,&#10;&#9;&#9;BrandID:          product.BrandID,&#10;&#9;&#9;CategoryID:       product.CategoryID,&#10;&#9;&#9;UserID:           product.UserID,&#10;&#9;}&#10;}&#10;&#10;func (p *productService) createProductDetailResponse(product *entity.Product) *response.ProductDetailResponse {&#10;&#9;// 1. Fetch product attributes and options&#10;&#9;productAttributes, err := p.productRepository.FindProductAttributesInfoByProductID(product.ID)&#10;&#9;if err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Error fetching product attributes for product ID: &quot;, product.ID, &quot;, Error: &quot;, err)&#10;&#9;&#9;return nil&#10;&#9;}&#10;&#9;productOptions, err := p.productRepository.FindProductOptionsInfoByProductID(product.ID)&#10;&#9;if err != nil {&#10;&#9;&#9;p.logger.Error(&quot;Error fetching product options for product ID: &quot;, product.ID, &quot;, Error: &quot;, err)&#10;&#9;&#9;return nil&#10;&#9;}&#10;&#10;&#9;// 3. Fetch product SKUs&#10;&#9;productSKUWithInventories, err := p.productRepository.FindProductSKUsByProductID(product.ID)&#10;&#9;if productSKUWithInventories == nil {&#10;&#9;&#9;p.logger.Error(&quot;No product SKUs found for product ID: &quot;, product.ID)&#10;&#9;&#9;return nil&#10;&#9;}&#10;&#10;&#9;// 2. Create response objects for attributes and options&#10;&#9;var attributeValues []*response.ProductWithAttributeValuesResponse&#10;&#9;var optionValues []*response.ProductWithOptionValuesResponse&#10;&#9;for _, attribute := range *productAttributes {&#10;&#9;&#9;attributeValues = append(attributeValues, p.createProductWithAttributeValuesResponse(&amp;attribute))&#10;&#9;}&#10;&#9;for _, option := range *productOptions {&#10;&#9;&#9;optionValues = append(optionValues, p.createProductWithOptionValuesResponse(&amp;option))&#10;&#9;}&#10;&#10;&#9;var productSKUResponses []*response.ProductSKUDetailResponse&#10;&#9;for _, sku := range *productSKUWithInventories {&#10;&#9;&#9;productSKUResponse := p.createProductSKUWithInventoryResponse(product.BasePrice, &amp;sku)&#10;&#9;&#9;productSKUResponses = append(productSKUResponses, productSKUResponse)&#10;&#9;}&#10;&#10;&#9;return &amp;response.ProductDetailResponse{&#10;&#9;&#9;ID:               product.ID,&#10;&#9;&#9;Name:             product.Name,&#10;&#9;&#9;Description:      product.Description,&#10;&#9;&#9;ShortDescription: product.ShortDescription,&#10;&#9;&#9;ImageURL:         product.ImageURL,&#10;&#9;&#9;Slug:             product.Slug,&#10;&#9;&#9;BasePrice:        product.BasePrice,&#10;&#9;&#9;SalePrice:        product.SalePrice,&#10;&#9;&#9;IsFeatured:       product.IsFeatured,&#10;&#9;&#9;SaleStartDate:    product.SaleStartDate,&#10;&#9;&#9;SaleEndDate:      product.SaleEndDate,&#10;&#9;&#9;Status:           product.Status,&#10;&#9;&#9;BrandID:          product.BrandID,&#10;&#9;&#9;CategoryID:       product.CategoryID,&#10;&#9;&#9;UserID:           product.UserID,&#10;&#9;&#9;Version:          product.Version,&#10;&#9;&#9;AttributeValues:  &amp;attributeValues,&#10;&#9;&#9;ProductSKUs:      &amp;productSKUResponses,&#10;&#9;&#9;OptionValues:     &amp;optionValues,&#10;&#9;}&#10;&#10;}&#10;&#10;func (p *productService) createProductWithAttributeValuesResponse(attribute *entity.ProductAttributeInfo) *response.ProductWithAttributeValuesResponse {&#10;&#9;return &amp;response.ProductWithAttributeValuesResponse{&#10;&#9;&#9;ID:              attribute.ID,&#10;&#9;&#9;AttributeName:   attribute.AttributeName,&#10;&#9;&#9;AttributeValues: attribute.AttributeValue,&#10;&#9;}&#10;}&#10;&#10;func (p *productService) createProductWithOptionValuesResponse(option *entity.ProductOptionInfo) *response.ProductWithOptionValuesResponse {&#10;&#9;return &amp;response.ProductWithOptionValuesResponse{&#10;&#9;&#9;ID:           option.ID,&#10;&#9;&#9;OptionNames:  option.OptionName,&#10;&#9;&#9;OptionValues: option.OptionValue,&#10;&#9;}&#10;}&#10;&#10;func (p *productService) createProductSKUWithInventoryResponse(&#10;&#9;productPrice float64,&#10;&#9;productSKUDetail *repository.ProductSKUDetail,&#10;) *response.ProductSKUDetailResponse {&#10;&#9;productSKUPrice := p.calculateProductSKUPrice(productPrice, productSKUDetail.ExtraPrice)&#10;&#9;return &amp;response.ProductSKUDetailResponse{&#10;&#9;&#9;ID:            productSKUDetail.ID,&#10;&#9;&#9;SKU:           productSKUDetail.SKU,&#10;&#9;&#9;SKUSignature:  productSKUDetail.SKUSignature,&#10;&#9;&#9;Price:         productSKUPrice,&#10;&#9;&#9;SalePrice:     p.calculateProductSKUSalePrice(productSKUPrice, productSKUDetail.SaleType, productSKUDetail.SaleValue),&#10;&#9;&#9;SaleStartDate: productSKUDetail.SaleStartDate,&#10;&#9;&#9;SaleEndDate:   productSKUDetail.SaleEndDate,&#10;&#9;&#9;Stock:         productSKUDetail.Stock,&#10;&#9;&#9;Status:        productSKUDetail.Status,&#10;&#9;&#9;ProductID:     productSKUDetail.ProductID,&#10;&#9;}&#10;}&#10;&#10;func (p *productService) generateSKUSignature(name string, sku string) string {&#10;&#9;skuSignature := strings.ToLower(name + &quot;-&quot; + sku)&#10;&#9;skuSignature = strings.ReplaceAll(sku, &quot; &quot;, &quot;-&quot;)&#10;&#10;&#9;return skuSignature&#10;}&#10;&#10;func (p *productService) calculateProductSKUPrice(productPrice float64, extraPrice float64) float64 {&#10;&#9;if extraPrice &lt; 0 {&#10;&#9;&#9;return productPrice&#10;&#9;}&#10;&#10;&#9;finalPrice := productPrice + productPrice*extraPrice&#10;&#9;return finalPrice&#10;}&#10;&#10;func (p *productService) calculateProductSKUSalePrice(productSKUPrice float64, saleType *string, saleValue *float64) *float64 {&#10;&#9;if saleType == nil || saleValue == nil {&#10;&#9;&#9;return nil&#10;&#9;}&#10;&#10;&#9;if *saleType == constants.SaleTypePercentage {&#10;&#9;&#9;// Calculate sale price as a percentage discount&#10;&#9;&#9;finalPrice := productSKUPrice - (productSKUPrice * *saleValue)&#10;&#9;&#9;return &amp;finalPrice&#10;&#9;} else if *saleType == constants.SaleTypeFixed {&#10;&#9;&#9;finalPrice := productSKUPrice - *saleValue&#10;&#9;&#9;if finalPrice &lt; 0 {&#10;&#9;&#9;&#9;finalPrice = 0&#10;&#9;&#9;}&#10;&#9;&#9;return &amp;finalPrice&#10;&#9;}&#10;&#10;&#9;return nil&#10;}&#10;&#10;// CreateProductWithoutSKU Help to create a product without SKU (for case app only have backend API)&#10;func (p *productService) CreateProductWithoutSKU(data *request.CreateProductWithoutSKURequest) (*response.ProductDetailResponse, error) {&#10;&#9;p.logger.Info(&quot;Creating product without SKU with name: &quot;, data.Name)&#10;&#10;&#9;// Generate all SKU combinations automatically from option values&#10;&#9;productSKUs, err := p.generateAllSKUCombinations(data.Name, data.OptionValues)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;// Create the full CreateProductRequest with generated SKUs&#10;&#9;createProductRequest := &amp;request.CreateProductRequest{&#10;&#9;&#9;Name:              data.Name,&#10;&#9;&#9;Description:       data.Description,&#10;&#9;&#9;ShortDescription:  data.ShortDescription,&#10;&#9;&#9;ImageURL:          data.ImageURL,&#10;&#9;&#9;Slug:              data.Slug,&#10;&#9;&#9;BasePrice:         data.BasePrice,&#10;&#9;&#9;SalePrice:         data.SalePrice,&#10;&#9;&#9;IsFeatured:        data.IsFeatured,&#10;&#9;&#9;SaleStartDate:     data.SaleStartDate,&#10;&#9;&#9;SaleEndDate:       data.SaleEndDate,&#10;&#9;&#9;Status:            string(constants.ProductStatusActive),&#10;&#9;&#9;BrandID:           data.BrandID,&#10;&#9;&#9;CategoryID:        data.CategoryID,&#10;&#9;&#9;UserID:            data.UserID,&#10;&#9;&#9;ProductAttributes: data.ProductAttributes,&#10;&#9;&#9;OptionValues:      data.OptionValues,&#10;&#9;&#9;ProductSKUs:       *productSKUs,&#10;&#9;}&#10;&#10;&#9;// Call the existing CreateProduct function&#10;&#9;return p.CreateProduct(createProductRequest)&#10;}&#10;&#10;// generateAllSKUCombinations generates all possible SKU combinations from option values&#10;func (p *productService) generateAllSKUCombinations(productName string, optionValues map[int64][]string) (*[]request.CreateProductSKURequest, error) {&#10;&#9;// Clean up option values - remove empty options&#10;&#9;cleanedOptions := make(map[int64][]string)&#10;&#9;optionIDs := make([]int64, 0)&#10;&#10;&#9;for optionID, values := range optionValues {&#10;&#9;&#9;if len(values) &gt; 0 {&#10;&#9;&#9;&#9;cleanedOptions[optionID] = values&#10;&#9;&#9;&#9;optionIDs = append(optionIDs, optionID)&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;// If no options, create a single default SKU&#10;&#9;if len(cleanedOptions) == 0 {&#10;&#9;&#9;defaultSKU := []request.CreateProductSKURequest{&#10;&#9;&#9;&#9;{&#10;&#9;&#9;&#9;&#9;SKU:        productName + &quot;_default&quot;,&#10;&#9;&#9;&#9;&#9;ExtraPrice: 0,&#10;&#9;&#9;&#9;&#9;Stock:      100,&#10;&#9;&#9;&#9;},&#10;&#9;&#9;}&#10;&#9;&#9;return &amp;defaultSKU, nil&#10;&#9;}&#10;&#10;&#9;// Generate all combinations using cartesian product&#10;&#9;combinations := p.generateCartesianProduct(cleanedOptions, optionIDs)&#10;&#10;&#9;// Create SKU requests from combinations&#10;&#9;var productSKUs []request.CreateProductSKURequest&#10;&#9;for _, combination := range combinations {&#10;&#9;&#9;sku := p.buildSKUFromCombination(productName, combination, optionIDs)&#10;&#9;&#9;price := constants.DefaultPrice&#10;&#9;&#9;stock := constants.DefaultStock&#10;&#10;&#9;&#9;productSKUs = append(productSKUs, request.CreateProductSKURequest{&#10;&#9;&#9;&#9;SKU:        sku,&#10;&#9;&#9;&#9;ExtraPrice: price,&#10;&#9;&#9;&#9;Stock:      int32(stock),&#10;&#9;&#9;})&#10;&#9;}&#10;&#10;&#9;return &amp;productSKUs, nil&#10;}&#10;&#10;// generateCartesianProduct generates all possible combinations of option values&#10;func (p *productService) generateCartesianProduct(optionValues map[int64][]string, optionIDs []int64) []map[int64]string {&#10;&#9;if len(optionIDs) == 0 {&#10;&#9;&#9;return []map[int64]string{}&#10;&#9;}&#10;&#10;&#9;// Start with the first option&#10;&#9;var result []map[int64]string&#10;&#9;firstOptionID := optionIDs[0]&#10;&#9;firstValues := optionValues[firstOptionID]&#10;&#10;&#9;for _, value := range firstValues {&#10;&#9;&#9;combination := make(map[int64]string)&#10;&#9;&#9;combination[firstOptionID] = value&#10;&#9;&#9;result = append(result, combination)&#10;&#9;}&#10;&#10;&#9;// Add remaining options one by one&#10;&#9;for i := 1; i &lt; len(optionIDs); i++ {&#10;&#9;&#9;optionID := optionIDs[i]&#10;&#9;&#9;values := optionValues[optionID]&#10;&#10;&#9;&#9;var newResult []map[int64]string&#10;&#9;&#9;for _, existingCombination := range result {&#10;&#9;&#9;&#9;for _, value := range values {&#10;&#9;&#9;&#9;&#9;newCombination := make(map[int64]string)&#10;&#9;&#9;&#9;&#9;// Copy existing combination&#10;&#9;&#9;&#9;&#9;for k, v := range existingCombination {&#10;&#9;&#9;&#9;&#9;&#9;newCombination[k] = v&#10;&#9;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;&#9;// Add new option value&#10;&#9;&#9;&#9;&#9;newCombination[optionID] = value&#10;&#9;&#9;&#9;&#9;newResult = append(newResult, newCombination)&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#9;&#9;result = newResult&#10;&#9;}&#10;&#10;&#9;return result&#10;}&#10;&#10;// buildSKUFromCombination builds SKU string from option combination&#10;func (p *productService) buildSKUFromCombination(productName string, combination map[int64]string, optionIDs []int64) string {&#10;&#9;skuParts := []string{productName}&#10;&#10;&#9;// Add option values in consistent order&#10;&#9;for _, optionID := range optionIDs {&#10;&#9;&#9;if value, exists := combination[optionID]; exists {&#10;&#9;&#9;&#9;// Clean up value for SKU (remove spaces, special chars)&#10;&#9;&#9;&#9;cleanValue := strings.ReplaceAll(value, &quot; &quot;, &quot;&quot;)&#10;&#9;&#9;&#9;skuParts = append(skuParts, cleanValue)&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;return strings.Join(skuParts, &quot;_&quot;)&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>